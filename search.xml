<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人简介</title>
    <url>/2021/08/08/AAA/</url>
    <content><![CDATA[<h2 id="YYT的个人博客"><a href="#YYT的个人博客" class="headerlink" title="YYT的个人博客"></a>YYT的个人博客</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大家好，这是我的个人博客</span><br><span class="line">这篇是我的第一篇博文，先熟悉一下编辑环境。</span><br><span class="line">本人主要学习Java后端开发</span><br><span class="line">包含Spring SpringMVC MyBatis Hibernate 等框架</span><br><span class="line">以及SPringBoot themeleaf jquery ajax JavaScript HTML5 CSS等前后端框架</span><br><span class="line">同时也在学习机器学习的相关知识，包括模式识别</span><br><span class="line">以后我会在这里分享各种学习心得和遇到的问题</span><br><span class="line">博主还处于学习阶段 如有不足望您指教！</span><br><span class="line">希望得到您的指导！</span><br><span class="line">邮箱 ：1217928966@qq.com</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Git发布</title>
    <url>/2021/08/14/Git/</url>
    <content><![CDATA[<h2 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a>Git操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在gitee上新建项目仓库</span><br><span class="line">2.在文件夹中右键选择clone</span><br><span class="line">	a.Git Clone</span><br><span class="line">	b.从远程库复制链接</span><br><span class="line">	c. </span><br><span class="line">		URL 填入链接</span><br><span class="line">		Directory 填本地文件夹名称</span><br><span class="line">		勾选Branch 填入 master</span><br><span class="line">		点击 ok</span><br><span class="line">    d.新建  .gitignore.txt   文件	</span><br><span class="line">			内填：（上传可忽略文件）</span><br><span class="line"></span><br><span class="line">				# Default ignored files</span><br><span class="line">				.idea/</span><br><span class="line">				target/</span><br><span class="line">				*.iml</span><br><span class="line">3.将想要上传的代码文件移动这个文件夹内	</span><br><span class="line">4.右键选择add(将这些文件加入暂存区)</span><br><span class="line">5.右键选择commit(这一步是为了将暂存区内容添加到本地仓库中)</span><br><span class="line">	a.填写提交备注信息</span><br><span class="line">	b.勾选 Set author date  Set author</span><br><span class="line">	c.选择Commit &amp; Push</span><br><span class="line">6.刷新远程库 完成操作</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2021/08/08/Maven/</url>
    <content><![CDATA[<h2 id="第一章-Maven介绍"><a href="#第一章-Maven介绍" class="headerlink" title="第一章 Maven介绍"></a>第一章 Maven介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maven是一个采用纯Java编写的开源项目管理工具。采用了一种被称之为POM(project object model)概念来管理项目，所有的项目配置信息都被定义在一个叫做pom.xml的文件中，通过该文件，maven可以管理项目的整个生命周期，包括编译，测试，打包，发布，运行等等。目前Apache下绝大多数项目都已经采用maven进行管理。而maven本身还支持多种插件，可以方便,灵活的控制项目。一句话：maven是一个项目管理和构建工具，主要对项目做编译，测试，打包，发布，运行等操作。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第二章-Maven安装"><a href="#第二章-Maven安装" class="headerlink" title="第二章 Maven安装"></a>第二章 Maven安装</h2><blockquote>
<p>下载</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://maven.apache.org/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>环境配置</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">和JDK的环境配置类似</span><br><span class="line">MAVEN_HOME=maven安装路径</span><br><span class="line">path=%MAVEN_HOME%\bin</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第三章-Maven项目创建"><a href="#第三章-Maven项目创建" class="headerlink" title="第三章 Maven项目创建"></a>第三章 Maven项目创建</h2><h3 id="3-1-命令创建"><a href="#3-1-命令创建" class="headerlink" title="3.1 命令创建"></a>3.1 命令创建</h3><blockquote>
<p>普通Java工程</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=com.qianfeng -DartifactId=myapp01 -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false</span><br><span class="line"></span><br><span class="line">mvn: 指定使用maven构建工具</span><br><span class="line">archetype:generate ：原型生成器</span><br><span class="line">-D ： pom.xml文件中的一个属性,如果不存在就生成，如果存在就覆盖</span><br><span class="line">groupId： 项目属于哪个组</span><br><span class="line">artifactId：项目名称</span><br><span class="line">archetypeArtifactId: 指定插件</span><br><span class="line">interactiveMode: 是否开启交互模式</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JavaWeb工程</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=com.qianfeng -DartifactId=mywebapp01 -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false</span><br></pre></td></tr></table></figure>

<h3 id="3-2-集成开发工具"><a href="#3-2-集成开发工具" class="headerlink" title="3.2 集成开发工具"></a>3.2 集成开发工具</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">演示集成Eclipse和IDEA</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第四章-阿里云私服配置"><a href="#第四章-阿里云私服配置" class="headerlink" title="第四章 阿里云私服配置"></a>第四章 阿里云私服配置</h2><h3 id="4-1-阿里云Maven私服配置"><a href="#4-1-阿里云Maven私服配置" class="headerlink" title="4.1 阿里云Maven私服配置"></a>4.1 阿里云Maven私服配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">  &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">  &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">  &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        </span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-修改本地-m2-仓库"><a href="#4-2-修改本地-m2-仓库" class="headerlink" title="4.2 修改本地(.m2)仓库"></a>4.2 修改本地(.m2)仓库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Maven的第一次运行命令的时候会从云端下载很多的文件,这些文件都保存到了我们本机的.m2这个maven的默认仓库里,这个仓库默认在windows电脑的C盘用户目录下,随着添加的依赖越来越多,这时候这个文件夹会越来越大,所以可以重新指定默认本地仓库的位置.</span><br><span class="line"></span><br><span class="line">设置方式：</span><br><span class="line">1. 找到我们Maven的安装位置</span><br><span class="line">2. 里面有一个conf文件夹</span><br><span class="line">3. conf里面有一个settings.xml文件</span><br><span class="line">   &lt;localRepository&gt;D:\soft\maven_repository&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第五章-Maven依赖特性"><a href="#第五章-Maven依赖特性" class="headerlink" title="第五章 Maven依赖特性"></a>第五章 Maven依赖特性</h2><h3 id="5-1-依赖范围介绍"><a href="#5-1-依赖范围介绍" class="headerlink" title="5.1 依赖范围介绍"></a>5.1 依赖范围介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maven 项目不同的阶段引入到classpath中的依赖是不同的，例如，编译时，maven 会将与编译相关的依赖引入classpath中，测试时，maven会将测试相关的的依赖引入到classpath中，运行时，maven会将与运行相关的依赖引入classpath中，而依赖范围就是用来控制依赖于这三种classpath的关系.</span><br><span class="line"></span><br><span class="line">例子:</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">其scope标签就是依赖范围的配置，默认是compile,可选配置有test、provided、runtime、system、import</span><br></pre></td></tr></table></figure>

<h3 id="5-2-依赖范围分类"><a href="#5-2-依赖范围分类" class="headerlink" title="5.2 依赖范围分类"></a>5.2 依赖范围分类</h3><ul>
<li><p>编译依赖范围（compile）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该范围就是默认依赖范围，此依赖范围对于编译、测试、运行三种classpath都有效，举个简单的例子，假如项目中有spring-core的依赖，那么spring-core不管是在编译，测试，还是运行都会被用到，因此spring-core必须是编译范围（构件默认的是编译范围，所以依赖范围是编译范围的无须显示指定）</span><br></pre></td></tr></table></figure></li>
<li><p>测试依赖范围(test)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用此依赖范围的依赖，只对测试classpath有效，在编译主代码和项目运行时，都将无法使用该依赖，最典型的例子就是 Junit, 构件在测试时才需要，所以它的依赖范围是测试，因此它的依赖范围需要显示指定为&lt;scope&gt;test&lt;/scope&gt; ,当然不显示指定依赖范围也不会报错，但是该依赖会被加入到编译和运行的classpath中,造成不必要的浪费</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>已提供依赖范围(provided)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用该依赖范围的maven依赖，只对编译和测试的classpath有效，对运行的classpath无效，典型的例子就是servlet-api， 编译和测试该项目的时候需要该依赖，但是在运行时，web容器已经提供的该依赖，所以运行时就不再需要此依赖，如果不显示指定该依赖范围，并且容器依赖的版本和maven依赖的版本不一致的话，可能会引起版本冲突，造成不良影响</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.0&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>运行时依赖范围(runtime)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用该依赖范围的maven依赖，只对测试和运行的classpath有效，对编译的classpath无效，典型例子就是JDBC的驱动实现，项目主代码编译的时候只需要JDK提供的JDBC接口，只有在测试和运行的时候才需要实现上述接口的具体JDBC驱动</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>导入依赖范围(import)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该依赖范围不会对三种classpath产生影响，该依赖范围只能与dependencyManagement元素配合使用，其功能为将目标pom文件中dependencyManagement的配置导入合并到当前pom的dependencyManagement中</span><br></pre></td></tr></table></figure></li>
<li><p>系统依赖范围（system）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该依赖与classpath的关系与 provided依赖范围完全一致，但是系统依赖范围必须通过配置systemPath元素来显示指定依赖文件的路径，此类依赖不是由maven仓库解析的，而且往往与本机系统绑定，可能造成构件的不可移植，因此谨慎使用，systemPath元素可以引用环境变量</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-3-依赖传递"><a href="#5-3-依赖传递" class="headerlink" title="5.3 依赖传递"></a>5.3 依赖传递</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假如有Maven项目A，项目B依赖A，项目C依赖B。那么我们可以说 C依赖A。也就是说，依赖的关系为：C—&gt;B—&gt;A。那么我们执行项目C时，会自动把B、A都下载导入到C项目的jar包文件夹中，这就是依赖的传递性</span><br></pre></td></tr></table></figure>

<h3 id="5-4-依赖传递的排除"><a href="#5-4-依赖传递的排除" class="headerlink" title="5.4 依赖传递的排除"></a>5.4 依赖传递的排除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如上，C—&gt;B—&gt;A。加入现在不想执行C时把A下载进来，那么我们可以用&lt;exclusions&gt;标签</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.sc.&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;B&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">         &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">              &lt;!--被排除的依赖包坐标--&gt;</span><br><span class="line">              &lt;groupId&gt;com.sc.&lt;/groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;A&lt;/artifactId&gt;</span><br><span class="line">              &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">         &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-依赖冲突与解决"><a href="#5-5-依赖冲突与解决" class="headerlink" title="5.5 依赖冲突与解决"></a>5.5 依赖冲突与解决</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">依赖冲突：一个项目A，通过不同依赖传递路径依赖于X，若在不同路径下传递过来的X版本不同，那么A应该导入哪个版本的X包呢？</span><br><span class="line"></span><br><span class="line">冲突解决方案:</span><br><span class="line"></span><br><span class="line">1：如果依赖路径的长度不同，则“短路优先”：</span><br><span class="line"></span><br><span class="line">     A—&gt;B—&gt;C—&gt;D—&gt;E—&gt;X(version 0.0.1)</span><br><span class="line"></span><br><span class="line">     A—&gt;F—&gt;X(version 0.0.2)</span><br><span class="line"></span><br><span class="line">     则A依赖于X(version 0.0.2)。</span><br><span class="line"></span><br><span class="line">2：依赖路径长度相同情况下，则“先声明优先”：</span><br><span class="line"></span><br><span class="line">     A—&gt;E—&gt;X(version 0.0.1)</span><br><span class="line"></span><br><span class="line">     A—&gt;F—&gt;X(version 0.0.2)</span><br><span class="line"></span><br><span class="line">     则在项目A的&lt;dependencies&gt;&lt;/dependencies&gt;中，E、F哪个在前则A依赖哪条路径的X</span><br></pre></td></tr></table></figure>

<h3 id="5-6-继承"><a href="#5-6-继承" class="headerlink" title="5.6 继承"></a>5.6 继承</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">继承，和java中的继承相当，作用就是复用</span><br></pre></td></tr></table></figure>

<ul>
<li><p>父类是dependencies标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当父类使用dependencies管理依赖时,子类可以直接继承父类的所有依赖</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">		&lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">		&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>父类是dependencyManagement标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当父类使用dependencyManagement管理依赖时，父类的依赖不会直接继承到子类,子类还需要添加依赖，但是版本不需要添加,父类会统一管理版本，这样可以灵活控制依赖,避免没有必要的依赖也被子类继承过去.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">父类:</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">			&lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">		&lt;/dependency&gt;</span><br><span class="line">	&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">子类:</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">	&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-7-import使用"><a href="#5-7-import使用" class="headerlink" title="5.7 import使用"></a>5.7 import使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import只在dependencyManagement元素下才有效果，作用是将目标POM中的dependencyManagement配置导入并合并到当前POM的dependencyManagement元素中</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;4.3.10.RELEASE&lt;/version&gt;</span><br><span class="line">	&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">	&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-8-properties属性"><a href="#5-8-properties属性" class="headerlink" title="5.8 properties属性"></a>5.8 properties属性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过&lt;properties&gt;元素用户可以自定义一个或多个maven属性，然后在POM的其他地方使用$&#123;属性名&#125;的方式引用该属性，这种做法的最大意义在于消除重复和统一管理.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">	&lt;!-- 定义 spring版本号 --&gt;</span><br><span class="line">	&lt;spring.version&gt;4.3.10.RELEASE&lt;/spring.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;</span><br><span class="line">	&lt;!-- 使用$&#123;&#125;引入 --&gt;</span><br><span class="line">	&lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">	&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">	&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第六章-Maven的常见命令"><a href="#第六章-Maven的常见命令" class="headerlink" title="第六章 Maven的常见命令"></a>第六章 Maven的常见命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、mvn compile 编译,将Java 源程序编译成 class 字节码文件。</span><br><span class="line">2、mvn test 测试，并生成测试报告</span><br><span class="line">3、mvn clean 将以前编译得到的旧的 class 字节码文件删除</span><br><span class="line">4、mvn pakage 打包,动态 web工程打 war包，Java工程打 jar 包。</span><br><span class="line">5、mvn install 将项目生成 jar 包放在仓库中，以便别的模块调用</span><br><span class="line"></span><br><span class="line">命令还可以连着一起使用</span><br><span class="line">mvn clean install -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第七章-Maven的插件介绍"><a href="#第七章-Maven的插件介绍" class="headerlink" title="第七章 Maven的插件介绍"></a>第七章 Maven的插件介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jetty插件，功能和tomcat类似，一个web服务器插件</span><br><span class="line"></span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;9.2.2.v20140723&lt;/version&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line"></span><br><span class="line">修改启动端口号命令: mvn -Djetty.port=9999 jetty:run 对应此版本</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第八章-Maven私服安装和配置"><a href="#第八章-Maven私服安装和配置" class="headerlink" title="第八章 Maven私服安装和配置"></a>第八章 Maven私服安装和配置</h2><ul>
<li><p>windows系统下进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows下安装版本 nexus-2.14.14-01-bundle.zip,如果需要安装包,登陆官网获取,或者加群联系群主</span><br><span class="line"></span><br><span class="line">1. 解压之后的nexus目录结构</span><br><span class="line">|--nexus-2.5.0-04</span><br><span class="line">	|--bin</span><br><span class="line">		|--jsw(这里面是 不同系统版本下的脚本)</span><br><span class="line">		|--nexus（lunix支持 install uninstall start stop 四个命令）</span><br><span class="line">		|--nexus.bat(windows 同上)</span><br><span class="line">	|--conf</span><br><span class="line">		|--examples</span><br><span class="line">		|--jetty.xml</span><br><span class="line">		|--logback.xml</span><br><span class="line">		|--nexus.properties（只用修改这里面的项目及主要是jetty bind的IP和端口）</span><br><span class="line">	|--lib（nexus web工程需要的Jar包）</span><br><span class="line">	|--logs（日志输出目录）</span><br><span class="line">	|--nexus（nexus war包解压后）</span><br><span class="line">	|--tmp（tmp）</span><br><span class="line">	|--LICENSE.txt</span><br><span class="line">	|--NOTICE.txt</span><br><span class="line">|--sonatype-work</span><br><span class="line"></span><br><span class="line">2. 注册服务,将解压之后的nexus注册到windows服务中</span><br><span class="line">    在bin目录下执行</span><br><span class="line">    nexus install 注册为服务</span><br><span class="line">    nexus uninstall 删除服务</span><br><span class="line"></span><br><span class="line">3. 修改端口号</span><br><span class="line">在nexus-2.14.14-01-bundle\nexus-2.14.14-01\conf\nexus.properties修改端口号为: application-port=8081</span><br><span class="line"></span><br><span class="line">4. 启动nexus</span><br><span class="line">    在bin目录下执行 nexus start 命令启动服务</span><br><span class="line"></span><br><span class="line">错误解决:</span><br><span class="line"></span><br><span class="line">出现错误</span><br><span class="line">Started as Service</span><br><span class="line">Launching a JVM...</span><br><span class="line">Unable to execute Java command.  系统找不到指定的文件。 (0x2)</span><br><span class="line"></span><br><span class="line">说明JDK安装路径和nexus指定的jdk执行路径不相同导致</span><br><span class="line"></span><br><span class="line">解决方式: </span><br><span class="line">在Nexus安装目录下，找到【\~\bin\jsw\conf】文件夹，打开【wrapper.conf】文件</span><br><span class="line">找到 # Set the JVM executable</span><br><span class="line">设置 wrapper.java.command=jdk的java命令的地址</span><br><span class="line">比如: wrapper.java.command=C:\soft\Java\jdk1.8.0_171\bin\java</span><br><span class="line"></span><br><span class="line">修改完成重新启动:</span><br><span class="line"></span><br><span class="line">访问：</span><br><span class="line">http://127.0.0.1:8081/nexus</span><br><span class="line">用户名: admin  密码: admin123</span><br></pre></td></tr></table></figure></li>
<li><p>其他操作系统(略)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">其他操作系统安装方式,请参考官网</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第九章-Maven私服相关的常见配置"><a href="#第九章-Maven私服相关的常见配置" class="headerlink" title="第九章 Maven私服相关的常见配置"></a>第九章 Maven私服相关的常见配置</h2><h3 id="9-1-从私服获取数据"><a href="#9-1-从私服获取数据" class="headerlink" title="9.1 从私服获取数据"></a>9.1 从私服获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果只是从私服获取依赖那么只需要在maven的setting.xml配置文件中配置镜像地址，镜像地址设置public群组,nexus有一个群组属性将多个库聚合到一起,所以直接引用public库即可</span><br><span class="line"></span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;public&lt;/id&gt; </span><br><span class="line">    &lt;name&gt;public repositroy&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://192.168.43.211:8081/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;        </span><br><span class="line">&lt;/mirror&gt;</span><br><span class="line"></span><br><span class="line">    id: 起一个标记</span><br><span class="line">    name: 介绍</span><br><span class="line">    url: 组仓库的地址</span><br><span class="line">    mirrorOf: 引组里面哪些仓库,“*”为全部</span><br></pre></td></tr></table></figure>

<h3 id="9-2-将自己的项目上传到私服"><a href="#9-2-将自己的项目上传到私服" class="headerlink" title="9.2 将自己的项目上传到私服"></a>9.2 将自己的项目上传到私服</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 需要在setting.xml配置文件中添加私服的用户名和密码</span><br><span class="line">&lt;server&gt;</span><br><span class="line">  &lt;id&gt;public&lt;/id&gt;</span><br><span class="line">  &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">  &lt;password&gt;admin123&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line">&lt;server&gt;</span><br><span class="line">	&lt;id&gt;releases&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;admin123&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line">&lt;server&gt;</span><br><span class="line">	&lt;id&gt;snapshots&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;admin123&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line"></span><br><span class="line">2. 在项目的pom.xml中配置将项目上传到Maven私服的哪个仓库中.</span><br><span class="line">&lt;distributionManagement&gt;</span><br><span class="line">    &lt;!-- 上传稳定版或者发行版 --&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;releases&lt;/id&gt;  &lt;!-- id对应server密码的id --&gt;</span><br><span class="line">        &lt;url&gt;http://192.168.43.211:8081/nexus/content/repositories/releases/&lt;/url&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">    &lt;!-- 上传开发板,或者不稳定版 --&gt;</span><br><span class="line">    &lt;snapshotRepository&gt;</span><br><span class="line">        &lt;id&gt;snapshots&lt;/id&gt;  &lt;!-- id对应server密码的id --&gt;</span><br><span class="line">        &lt;url&gt;http://192.168.43.211:8081/nexus/content/repositories/snapshots/&lt;/url&gt;</span><br><span class="line">    &lt;/snapshotRepository&gt;</span><br><span class="line">&lt;/distributionManagement&gt;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-引入其他开发者上传到私服的项目依赖"><a href="#9-3-引入其他开发者上传到私服的项目依赖" class="headerlink" title="9.3 引入其他开发者上传到私服的项目依赖"></a>9.3 引入其他开发者上传到私服的项目依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在Maven的setting.xml中配置mirror(上面已经介绍)</span><br><span class="line">2. 在Maven的setting.xml中配置profile</span><br><span class="line">&lt;profile&gt;</span><br><span class="line">  &lt;id&gt;dev&lt;/id&gt; </span><br><span class="line">  &lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">      &lt;id&gt;public&lt;/id&gt;  &lt;!-- 自定义 url为组的地址,也就是public即可,因为组内包含多个仓库 --&gt;</span><br><span class="line">      &lt;url&gt;http://192.168.43.211:8081/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">      &lt;releases&gt;</span><br><span class="line">        &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">      &lt;/releases&gt;</span><br><span class="line">      &lt;snapshots&gt;</span><br><span class="line">        &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">        &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;</span><br><span class="line">      &lt;/snapshots&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">  &lt;/repositories&gt;</span><br><span class="line">&lt;/profile&gt;</span><br><span class="line"></span><br><span class="line">3. 在maven的setting.xml中配activefile</span><br><span class="line">&lt;activeProfiles&gt;</span><br><span class="line">    &lt;!-- 指定profile --&gt;</span><br><span class="line">    &lt;activeProfile&gt;dev&lt;/activeProfile&gt;</span><br><span class="line">&lt;/activeProfiles&gt;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>算法详解</title>
    <url>/2021/08/07/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<h1 id="有效括号"><a href="#有效括号" class="headerlink" title="有效括号"></a>有效括号</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, Character&gt; pairs = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">            pairs.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            pairs.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">            pairs.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (pairs.containsKey(ch)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != pairs.get(ch)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; xStack;</span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        xStack.push(x);</span><br><span class="line">        minStack.push(Math.min(minStack.peek(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        xStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> xStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; A, B;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        A.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B.isEmpty()) <span class="keyword">return</span> B.removeLast();   <span class="comment">//B不为空 </span></span><br><span class="line">        <span class="comment">//removeLast 移除并返回最后一个元素；</span></span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;                <span class="comment">//A为空 </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!A.isEmpty())</span><br><span class="line">            B.addLast(A.removeLast());</span><br><span class="line">        <span class="keyword">return</span> B.removeLast();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">单调队列：</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">1</span> - k; j &lt; nums.length; i++, j++) &#123;</span><br><span class="line">            <span class="comment">// 删除 deque 中对应的 nums[i-1]</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; deque.peekFirst() == nums[i - <span class="number">1</span>])</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            <span class="comment">// 保持 deque 递减</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(nums[j]);</span><br><span class="line">            <span class="comment">// 记录窗口最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)</span><br><span class="line">                res[i] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;nums.length;n++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[n]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[n]),n&#125;;<span class="comment">//true</span></span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(nums[n],n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="零移动"><a href="#零移动" class="headerlink" title="零移动"></a>零移动</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">两次遍历    </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums==<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">                    nums[j++] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//非0元素统计完了，剩下的都是0了</span></span><br><span class="line">            <span class="comment">//所以第二次遍历把末尾的元素都赋为0即可</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=j;i&lt;nums.length;++i) &#123;</span><br><span class="line">                nums[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一次遍历</span><br><span class="line"></span><br><span class="line">（双指针）</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums==<span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//两个指针i和j</span></span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">                <span class="comment">//当前元素!=0，就把其交换到左边，等于0的交换到右边</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j++] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="盛水最多容器"><a href="#盛水最多容器" class="headerlink" title="盛水最多容器"></a>盛水最多容器</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> area = Math.min(height[i], height[j]) * (j - i);</span><br><span class="line">            ans = Math.max(ans, area);</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt;= height[j]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="x的平方根"><a href="#x的平方根" class="headerlink" title="x的平方根"></a>x的平方根</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">暴力枚举</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">           <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( sum&lt;x &amp;&amp; (<span class="keyword">int</span>)(x/j)&gt;=j)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                sum=i*i;           </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">二分查找法</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 特殊值判断</span></span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = x / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 在区间 [left..right] 查找目标元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// 注意：这里为了避免乘法溢出，改用除法</span></span><br><span class="line">                <span class="keyword">if</span> (mid &gt; x / mid) &#123;</span><br><span class="line">                    <span class="comment">// 下一轮搜索区间是 [left..mid - 1]</span></span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 下一轮搜索区间是 [mid..right]</span></span><br><span class="line">                    left = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length-<span class="number">1</span>;       </span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=i+(j-i)/<span class="number">2</span>;</span><br><span class="line">            *****x=i+(j-i)/<span class="number">2</span>  </span><br><span class="line">                因为假如i和j都是一个很大的数,那么i+j会溢出,</span><br><span class="line">                而(j-i)/<span class="number">2</span>+i 先做减法不会溢出</span><br><span class="line">                所以好处 是让x变量避免溢出</span><br><span class="line">            <span class="keyword">if</span>(nums[x]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[x]&gt;target)&#123;</span><br><span class="line">                j=x-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i=x+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp=cur.next;</span><br><span class="line">            cur.next=pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">递归</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;   </span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;  </span><br><span class="line">           <span class="keyword">if</span>(head!=<span class="keyword">null</span> &amp;&amp; head.next!=<span class="keyword">null</span>)&#123;  </span><br><span class="line">                 ListNode cur=head.next; </span><br><span class="line">               head.next=swapPairs(cur.next); </span><br><span class="line">               cur.next=head;       </span><br><span class="line">               <span class="keyword">return</span> cur;    </span><br><span class="line">                     &#125;       </span><br><span class="line">         <span class="keyword">return</span> head;                             </span><br><span class="line">     &#125;&#125;</span><br><span class="line"></span><br><span class="line">迭代</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">      <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;   </span><br><span class="line">            ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);   </span><br><span class="line">            dummyHead.next = head;      </span><br><span class="line">          	ListNode temp = dummyHead;</span><br><span class="line">              <span class="keyword">while</span> (temp.next != <span class="keyword">null</span> &amp;&amp; temp.next.next != <span class="keyword">null</span>) &#123; </span><br><span class="line">                           ListNode node1 = temp.next;    </span><br><span class="line">                          ListNode node2 = temp.next.next;      </span><br><span class="line">                          temp.next = node2;     </span><br><span class="line">                          node1.next = node2.next;   </span><br><span class="line">                          node2.next = node1;         </span><br><span class="line">                          temp = node1;                                         </span><br><span class="line">             	 &#125;                            </span><br><span class="line">          <span class="keyword">return</span> dummyHead.next;                   </span><br><span class="line">      &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两两交换链表中的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">哈希表</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;   </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;  </span><br><span class="line">          HashSet&lt;ListNode&gt; set=<span class="keyword">new</span> HashSet&lt;ListNode&gt;();    </span><br><span class="line">             <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;        </span><br><span class="line">                <span class="keyword">if</span>(!set.add(head))&#123;         </span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">true</span>;        </span><br><span class="line">                         &#125;          </span><br><span class="line">                          head=head.next;   </span><br><span class="line">                              &#125;       </span><br><span class="line">                               <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">           &#125;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a><strong>合并两个排序的链表</strong></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">	list1:&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;  list2&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;</span><br><span class="line">输出结果：</span><br><span class="line">		  &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">    </span><br><span class="line">代码：    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode p = list1;</span><br><span class="line">        ListNode q = list2;</span><br><span class="line">        ListNode r = dummy;</span><br><span class="line">		<span class="comment">//链表为升序 即比较头结点大小即可</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val &lt; q.val) &#123;</span><br><span class="line">                r.next=p;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               r.next=q;</span><br><span class="line">               q=q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            r = r.next;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//若其中一个链表为空  将剩下链表全部填入新链表即可</span></span><br><span class="line">        <span class="keyword">if</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.next = p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.next = q;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















































]]></content>
  </entry>
  <entry>
    <title>日志</title>
    <url>/2021/08/08/%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="第一章-日志是什么"><a href="#第一章-日志是什么" class="headerlink" title="第一章 日志是什么"></a>第一章 日志是什么</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、记录程序的运行轨迹</span><br><span class="line">2、定位程序运行中出现的问题</span><br><span class="line">3、查找程序运行过程中的关键信息等.</span><br></pre></td></tr></table></figure>



<h2 id="第二章-认识常见的Java日志"><a href="#第二章-认识常见的Java日志" class="headerlink" title="第二章 认识常见的Java日志"></a>第二章 认识常见的Java日志</h2><h3 id="第1节-Logging-JUL"><a href="#第1节-Logging-JUL" class="headerlink" title="第1节 Logging(JUL)"></a>第1节 Logging(JUL)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java自带的日志工具类,在 JDK 1.5 开始就已经有了,在 java.util.logging 包下</span><br><span class="line"></span><br><span class="line">官网地址: https://docs.oracle.com/javase/8/docs/technotes/guides/logging/overview.html</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第2节-Log4j"><a href="#第2节-Log4j" class="headerlink" title="第2节 Log4j"></a>第2节 Log4j</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Log4j 是 Apache 的一个开源日志框架,也是市场占有率最多的一个框架.</span><br><span class="line"></span><br><span class="line">但是log4j在2015年8月宣布不在维护了.作者在此基础上有重新写了一个Log4j2</span><br><span class="line"></span><br><span class="line">官网地址: https://logging.apache.org/log4j/2.x/</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第3节-commons-logging-JCL"><a href="#第3节-commons-logging-JCL" class="headerlink" title="第3节 commons-logging(JCL)"></a>第3节 commons-logging(JCL)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">它是apache提供的日志门面接口,有个这门面接口用户就可以选择不同的日志实现,而不需要改动日志的定义,符合面向接口编程思想</span><br><span class="line"></span><br><span class="line">官网地址: http://commons.apache.org/proper/commons-logging/</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第4节-Slf4j"><a href="#第4节-Slf4j" class="headerlink" title="第4节 Slf4j"></a>第4节 Slf4j</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全称:Simple Logging Facade for Java,即简单日志门面接口,和commons-logging是一样的,它们都不是具体的日志框架,只是门面接口,要想使用需要具体的日志框架(log4j,logback等)</span><br><span class="line"></span><br><span class="line">官网地址: http://www.slf4j.org/</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第5节-Logback"><a href="#第5节-Logback" class="headerlink" title="第5节 Logback"></a>第5节 Logback</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Logback是Slf4j的原生实现框架,同样也是出自Log4j一个人之手,拥有比log4j更多的优点、特性和更做强的性能,现在基本都用来代替log4j成为主流</span><br><span class="line"></span><br><span class="line">官网地址: https://logback.qos.ch/</span><br></pre></td></tr></table></figure>

<h3 id="第6节-日志的关系"><a href="#第6节-日志的关系" class="headerlink" title="第6节 日志的关系"></a>第6节 日志的关系</h3><p><a href="https://note.youdao.com/yws/api/personal/file/WEBc31918be417c7352c90006f492ebc139?method=download&shareKey=8b630bcd611a531b104a60622f6d7bf6"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBc31918be417c7352c90006f492ebc139?method=download&shareKey=8b630bcd611a531b104a60622f6d7bf6" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<h2 id="第三章-Java日志的最佳实践"><a href="#第三章-Java日志的最佳实践" class="headerlink" title="第三章 Java日志的最佳实践"></a>第三章 Java日志的最佳实践</h2><h3 id="第1节-Log4j日志"><a href="#第1节-Log4j日志" class="headerlink" title="第1节 Log4j日志"></a>第1节 Log4j日志</h3><h4 id="1-1-Log4j简介"><a href="#1-1-Log4j简介" class="headerlink" title="1.1 Log4j简介"></a>1.1 Log4j简介</h4><ul>
<li><p>依赖添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;  </span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;  </span><br><span class="line">    &lt;version&gt;1.2.17&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>日志级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Log4J在Level类中定义了OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE、ALL八种日志级别</span><br><span class="line"></span><br><span class="line">一般只使用4个级别,优先级从高到低为 ERROR &gt; WARN &gt; INFO &gt; DEBUG</span><br></pre></td></tr></table></figure></li>
<li><p>日志组成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Log4J 主要由 Loggers(日志记录器)、Appenders(输出端)和Layout(日志格式化器)组成</span><br><span class="line"></span><br><span class="line">1、Loggers 控制日志的输出级别与日志是否输出</span><br><span class="line">2、Appenders 指定日志的输出方式(输出到控制台、文件等)</span><br><span class="line">3、Layout 控制日志信息的输出格式</span><br></pre></td></tr></table></figure>

<h4 id="1-2-Log4j-常用API"><a href="#1-2-Log4j-常用API" class="headerlink" title="1.2 Log4j 常用API"></a>1.2 Log4j 常用API</h4></li>
<li><p>Appender(输出端)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Appender 用来指定日志输出到哪个地方,可以同时指定日志的输出目的地</span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr>
<th align="left">输出端 类型</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ConsoleAppender</td>
<td align="left">将日志输出到控制台</td>
</tr>
<tr>
<td align="left">FileAppender</td>
<td align="left">将日志输出到文件中</td>
</tr>
<tr>
<td align="left">DailyRollingFileAppender</td>
<td align="left">将日志输出到一个日志文件,并且时间(每天或者每时,每分等)输出到一个新的文件</td>
</tr>
<tr>
<td align="left">RollingFileAppender</td>
<td align="left">将日志信息输出到一个日志文件,并且指定文件的尺寸,当文件大 小达到指定尺寸时,会自动把文件改名,同时产生一个新的文件</td>
</tr>
<tr>
<td align="left">JDBCAppender</td>
<td align="left">把日志信息保存到数据库中</td>
</tr>
</tbody></table>
<ul>
<li>Layout(日志格式化器)</li>
</ul>
<table>
<thead>
<tr>
<th align="left">格式化器类型</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HTMLLayout</td>
<td align="left">格式化日志输出为HTML表格形式</td>
</tr>
<tr>
<td align="left">SimpleLayout</td>
<td align="left">简单的日志输出格式化,打印的日志格式为(info - message)</td>
</tr>
<tr>
<td align="left">PatternLayout</td>
<td align="left">最强大的格式化期,可以根据自定义格式输出日志,如果没有指定转换格式,就是用默认的转换格式</td>
</tr>
</tbody></table>
<ul>
<li><p>日志输出格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%m   输出代码中指定的日志信息</span><br><span class="line">%p   输出优先级，及 DEBUG、INFO 等</span><br><span class="line">%n   换行符（Windows平台的换行符为 &quot;\n&quot;，Unix 平台为 &quot;\n&quot;）</span><br><span class="line">%r   输出自应用启动到输出该 log 信息耗费的毫秒数</span><br><span class="line">%c   输出打印语句所属的类的全名</span><br><span class="line">%t   输出产生该日志的线程全名</span><br><span class="line"></span><br><span class="line">%d   输出服务器当前时间，默认格式为ISO8601，也可以在后面指定格式。如：%d&#123;yyyy年MM月dd日 HH:mm:ss&#125;</span><br><span class="line"></span><br><span class="line">%l   输出日志时间发生的位置，包括类名、发生的线程，以及在代码中的行数，如：Test.main(Test.java:10)</span><br><span class="line"></span><br><span class="line">%F   输出日志消息产生时所在的文件名称</span><br><span class="line"></span><br><span class="line">%L   输出代码中的行号</span><br><span class="line"></span><br><span class="line">%x   输出和当前线程相关的 NDC（嵌套诊断环境）</span><br><span class="line"></span><br><span class="line">%%   输出一个 &quot;%&quot; 字符</span><br><span class="line"></span><br><span class="line">可以在 % 与字符之间加上修饰符来控制最小宽度、最大宽度和文本的对其方式。如：</span><br><span class="line">%5c   输出category名称，最小宽度是5，category&lt;5，默认的情况下右对齐</span><br><span class="line">%-5c  输出category名称，最小宽度是5，category&lt;5，&quot;-&quot;号指定左对齐,会有空格</span><br><span class="line">%.5c  输出category名称，最大宽度是5，category&gt;5，就会将左边多出的字符截掉，&lt;5不会有空格</span><br><span class="line">%20.30c  category名称&lt;20补空格，并且右对齐，&gt;30字符，就从左边交远销出的字符截掉</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-3-快速入门"><a href="#1-3-快速入门" class="headerlink" title="1.3 快速入门"></a>1.3 快速入门</h4><ul>
<li><p>采用默认的配置(不适用log4j的配置文件)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 不使用log4j配置文件采用默认配置</span><br><span class="line"> * 在单元测试中测试</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test01()&#123;</span><br><span class="line">    //实例化Logger对象</span><br><span class="line">    Logger logger = Logger.getLogger(Log4jTest.class);</span><br><span class="line">    //设置默认的log4j配置,不使用log4j的配置文件</span><br><span class="line">    BasicConfigurator.configure();</span><br><span class="line">    /**</span><br><span class="line">     * 设置日志的的输出级别</span><br><span class="line">     * 常见日志的级别 ERROR &gt; WARN &gt; INFO &gt; DEBUG</span><br><span class="line">     * 如果我设置 INFO级别,那么只有INFO和比INFO级别好的日志可以打印,DEBUG不能被输出</span><br><span class="line">     */</span><br><span class="line">    logger.setLevel(Level.INFO);</span><br><span class="line">    //输出日志</span><br><span class="line">    logger.debug(&quot;我是info信息&quot;);</span><br><span class="line">    logger.info(&quot;我是info信息&quot;);</span><br><span class="line">    logger.warn(&quot;我是info信息&quot;);</span><br><span class="line">    logger.error(&quot;我是info信息&quot;);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 0 [main] INFO cn.ukoko.Log4jTest  - 我是info信息</span><br><span class="line">     * 1 [main] WARN cn.ukoko.Log4jTest  - 我是info信息</span><br><span class="line">     * 1 [main] ERROR cn.ukoko.Log4jTest  - 我是info信息</span><br><span class="line">     * 以上为控制台输出数据,DEBUG级别的日志没有被打印出来,因为级别在INFO之下</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用log4j.properties</p>
</li>
<li><ul>
<li><p>log4j.properties配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 控制台输出配置</span><br><span class="line">log4j.appender.Console=org.apache.log4j.ConsoleAppender</span><br><span class="line"># 设置输出日志的格式,设置自定义格式</span><br><span class="line">log4j.appender.Console.layout=org.apache.log4j.PatternLayout</span><br><span class="line"># 设置日志的输出格式</span><br><span class="line">log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 文件输出配置(按照时间分割日志)</span><br><span class="line">log4j.appender.A = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line"># 指定日志的输出路径,最后log不是文件路径是下面DatePattern的前缀</span><br><span class="line">log4j.appender.A.File = D:\\pic\\log</span><br><span class="line"># 设置日志的生成方式(每分钟生成一个)</span><br><span class="line">log4j.appender.A.DatePattern = &#x27;_&#x27;yyyy-MM-dd-HH-mm&#x27;.log&#x27;</span><br><span class="line"># 是否进行日志内容的追加,默认为true,为追加</span><br><span class="line">log4j.appender.A.Append = true</span><br><span class="line"># 设置输出日志的级别,设置成DEBUG那么就会将DEBUG以及以上的级别全部输出</span><br><span class="line">log4j.appender.A.Threshold = DEBUG</span><br><span class="line"># 使用自定义日志格式化器</span><br><span class="line">log4j.appender.A.layout = org.apache.log4j.PatternLayout</span><br><span class="line"># 指定日志的输出格式</span><br><span class="line">log4j.appender.A.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class="line"># 指定日志的文件编码</span><br><span class="line">log4j.appender.A.encoding=UTF-8</span><br><span class="line"></span><br><span class="line"># 文件输出配置(按照文件大小分割日志)</span><br><span class="line">log4j.appender.B = org.apache.log4j.RollingFileAppender</span><br><span class="line"># 指定日志的输出路径,最后log不是文件路径是下面DatePattern的前缀</span><br><span class="line">log4j.appender.B.File = D:\\pic\\file_log.log</span><br><span class="line"># 是否进行日志内容的追加,默认为true,为追加</span><br><span class="line">log4j.appender.B.Append = true</span><br><span class="line"># 设置输出日志的级别,设置成DEBUG那么就会将DEBUG以及以上的级别全部输出</span><br><span class="line">log4j.appender.B.Threshold = DEBUG</span><br><span class="line"># 使用自定义日志格式化器</span><br><span class="line">log4j.appender.B.layout = org.apache.log4j.PatternLayout</span><br><span class="line"># 指定日志的输出格式</span><br><span class="line">log4j.appender.B.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class="line"># 指定日志的文件编码</span><br><span class="line">log4j.appender.B.encoding=UTF-8</span><br><span class="line"># 设置日志的大小</span><br><span class="line">log4j.appender.R.MaxFileSize=20MB</span><br><span class="line"># 约束生成文件的个数(防止硬盘爆掉)</span><br><span class="line">log4j.appender.R.MaxBackupIndex=10</span><br><span class="line"></span><br><span class="line"># 指定日志的输出级别与输出端,第一个参数是日志级别,其余的是设置那个日志appender；Console和A为自定义</span><br><span class="line">log4j.rootLogger=DEBUG,Console,A,B</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>Java测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 会在控制台数据以及在d盘生成一个日志文件</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test02()&#123;</span><br><span class="line">    //实例化Logger对象</span><br><span class="line">    Logger logger = Logger.getLogger(Log4jTest.class);</span><br><span class="line">    //输出日志</span><br><span class="line">    logger.debug(&quot;我是info信息&quot;);</span><br><span class="line">    logger.info(&quot;我是info信息&quot;);</span><br><span class="line">    logger.warn(&quot;我是info信息&quot;);</span><br><span class="line">    logger.error(&quot;我是info信息&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="第2节-slf4j-Log4j"><a href="#第2节-slf4j-Log4j" class="headerlink" title="第2节 slf4j+Log4j"></a>第2节 slf4j+Log4j</h3><ul>
<li><p>添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.7.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件(只需要修改依赖即可,配置文件不变)</p>
</li>
<li><p>Java使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test03()&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(Log4jTest.class);</span><br><span class="line">    //输出日志</span><br><span class="line">    logger.debug(&quot;debug=&#123;&#125;&quot;,&quot;我是info信息&quot;);</span><br><span class="line">    logger.info(&quot;info=&#123;&#125;&quot;,&quot;我是info信息&quot;);</span><br><span class="line">    logger.warn(&quot;warn=&#123;&#125;&quot;,&quot;我是info信息&quot;);</span><br><span class="line">    logger.error(&quot;error=&#123;&#125;&quot;,&quot;我是info信息&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第3节-slf4j-Logback"><a href="#第3节-slf4j-Logback" class="headerlink" title="第3节 slf4j+Logback"></a>第3节 slf4j+Logback</h3><ul>
<li><p>添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件 logback.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    scan（非必须）属性：默认为false,true表示扫描配置文件的变化并自动重新配置,默认每隔1分钟扫描一次</span><br><span class="line">    scanPeriod（非必须）属性：搭配scan属性使用,设置扫描的间隔时间</span><br><span class="line">--&gt;</span><br><span class="line">&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;1 seconds&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">        设置自定义参数,类似于pom.xml里面的properties标签,下面可以使用$&#123;名称&#125;引用此变量</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;property name=&quot;FILE_PATH&quot; value=&quot;D:/&quot;&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">        ConsoleAppender: 控制台输出</span><br><span class="line">        STDOUT: 给appender起一个名字</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;!--</span><br><span class="line">                pattern: 日志输出的格式化样式</span><br><span class="line">            --&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--时间滚动日志生成--&gt;</span><br><span class="line">    &lt;appender name=&quot;TIME_ROLLING_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;0&#125; -%msg%n&lt;/pattern&gt;</span><br><span class="line">        &lt;/encoder&gt;</span><br><span class="line">        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;!--</span><br><span class="line">                设置生成的文件地址和文件名</span><br><span class="line">             --&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;FILE_PATH&#125;/test%d&#123;yyyy-MM-dd_HH-mm&#125;.log&lt;/fileNamePattern&gt;</span><br><span class="line">            &lt;!--最多生成十个,查过十个开始删除--&gt;</span><br><span class="line">            &lt;maxHistory&gt;10&lt;/maxHistory&gt;</span><br><span class="line">        &lt;/rollingPolicy&gt;</span><br><span class="line">        &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt;</span><br><span class="line">            &lt;!-- 文件大小触发重写新文件 --&gt;</span><br><span class="line">            &lt;MaxFileSize&gt;10MB&lt;/MaxFileSize&gt;</span><br><span class="line">        &lt;/triggeringPolicy&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">        debug: 指定日志的输出级别,大于debug的级别都会被输出</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;root level=&quot;debug&quot;&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            appender-ref: 指定哪一个appender使用此日志输出级别</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;TIME_ROLLING_FILE&quot; /&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>Java使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test01()&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(AppTest.class);</span><br><span class="line">    logger.info(&quot;info=&#123;&#125;&quot;,&quot;这是info级别日志&quot;);</span><br><span class="line">    logger.debug(&quot;debug=&#123;&#125;&quot;,&quot;这是debug级别日志&quot;);</span><br><span class="line">    logger.warn(&quot;warn=&#123;&#125;&quot;,&quot;这是warn级别日志&quot;);</span><br><span class="line">    logger.error(&quot;error=&#123;&#125;&quot;,&quot;这是error级别日志&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<blockquote>
<p>其他详细配置请查询官网</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>javaweb</title>
    <url>/2021/07/05/%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5/</url>
    <content><![CDATA[<ol>
<li>1NF：主键，不能为一组值</li>
<li>2NF：1NF，消除部分依赖</li>
<li>3NF：2NF，消除传递依赖；</li>
</ol>
<h4 id="PowerDesigner-建模工具"><a href="#PowerDesigner-建模工具" class="headerlink" title="PowerDesigner;建模工具"></a>PowerDesigner;建模工具</h4><p>E-R</p>
<p>两种</p>
<p>概念，物理</p>
<ol>
<li>一对多  -&gt;relationship</li>
<li>一对一：相同主键，唯一外键</li>
<li>多对多：中间表；（association ）</li>
</ol>
<p>作业 ：</p>
<p>​    商品，user；</p>
<p>​    订单，订单条目</p>
<h3 id="软件框架的分类"><a href="#软件框架的分类" class="headerlink" title="软件框架的分类"></a>软件框架的分类</h3><ol>
<li>B/S:browser/server,瘦客户端</li>
<li>C/S：client/server,胖客户端</li>
</ol>
<h3 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h3><p>协议：通信双方共同遵守的规则；</p>
<p>HyperText transfer protocal: 超文本传输协议；</p>
<p>为什么重要：B/S结构使用的协议；</p>
<p>特点：</p>
<ol>
<li>基于TCP/IP协议的子协议，是应用层的协议；主要用于浏览器-》服务器之间的通讯；</li>
<li>无状态，无连接的协议</li>
<li>HTTP是基于请求-&gt;响应的模式来进行通讯的；</li>
</ol>
<h3 id="Request（请求）的组成部分"><a href="#Request（请求）的组成部分" class="headerlink" title="Request（请求）的组成部分"></a>Request（请求）的组成部分</h3><p>三部分</p>
<ol>
<li>请求行（第一行）</li>
<li>消息头（从第二行到空白行）</li>
<li>请求体（空白行后的所有内容，也可能没有请求体）</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">请求行包括三部分，用空格隔开</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/seedProject/first.html HTTP/1.1</span></span><br><span class="line"><span class="attr">GET</span>:<span class="string">请求方法</span></span><br><span class="line"><span class="meta">/seedProject/first.html</span>:<span class="string">uri统一资源描述符</span></span><br><span class="line"><span class="meta">HTTP/1.1</span>:<span class="string">协议版本号</span></span><br></pre></td></tr></table></figure>

<h3 id="Response-响应-的组成部分"><a href="#Response-响应-的组成部分" class="headerlink" title="Response(响应)的组成部分"></a>Response(响应)的组成部分</h3><p>三部分</p>
<ol>
<li>状态行（第一行）</li>
<li>消息头（第二到空白行）</li>
<li>实体内容(空白行之后的内容)</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">状态行分为三部分，由空格隔开</span></span><br><span class="line"><span class="meta">HTTP/1.1</span>:<span class="string">协议版本</span></span><br><span class="line"><span class="attr">200</span>:<span class="string">状态码</span></span><br><span class="line"><span class="attr">OK</span>:<span class="string">状态的简单说明</span></span><br></pre></td></tr></table></figure>

<h3 id="Get与Post的区别"><a href="#Get与Post的区别" class="headerlink" title="Get与Post的区别"></a>Get与Post的区别</h3><ol>
<li>Get请求时使用请求行来传递数据，Post请求时使用请求体来传递数据；</li>
<li>Get传递数据时，数据长度有限制，并且明文传递（不安全）</li>
<li>POst传递数据时，数据长度无限制，安全，同时可以传递进制的信息；</li>
</ol>
<h3 id="响应码的分类"><a href="#响应码的分类" class="headerlink" title="响应码的分类"></a>响应码的分类</h3><p>2xx:服务端正确处理</p>
<p>4xx:客户端错误</p>
<p>5xx:服务端错误</p>
<h3 id="编程来模拟Http协议的请求"><a href="#编程来模拟Http协议的请求" class="headerlink" title="编程来模拟Http协议的请求"></a>编程来模拟Http协议的请求</h3><p>Mycat</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">开发mycat的思路;</span></span><br><span class="line"><span class="attr">1.创建一个ServerSocket,端口号是8080，accept;</span></span><br><span class="line"><span class="attr">2.获取到Socket,调用Socket的getInputStream来获得流；</span></span><br><span class="line"><span class="attr">3.对字节流进行包装，转成字符流，一行一行读取；</span></span><br></pre></td></tr></table></figure>

<h3 id="javaWeb环境搭建"><a href="#javaWeb环境搭建" class="headerlink" title="javaWeb环境搭建"></a>javaWeb环境搭建</h3><ol>
<li>web容器：tomcat</li>
<li>开发环境：Eclipse</li>
</ol>
<h3 id="Tomcat容器介绍"><a href="#Tomcat容器介绍" class="headerlink" title="Tomcat容器介绍"></a>Tomcat容器介绍</h3><ol>
<li>免费开源的web容器</li>
<li>Tomcat是Apache组织托管的一个绿化软件，直接解压即可</li>
<li>tomcat的目录结构如下<ul>
<li>bin:tomcat的各种命令；</li>
<li>conf:tomcat的配置文件</li>
<li>lib:tomcat依赖的jar包</li>
<li>webapps:存储用户部署的javaweb项目</li>
<li>works:jsp的工作目录</li>
</ul>
</li>
</ol>
<h3 id="配置Eclipse"><a href="#配置Eclipse" class="headerlink" title="配置Eclipse"></a>配置Eclipse</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">window-&gt;preferences-&gt;server-&gt;runtime</span> <span class="string">environments-&gt;add-&gt;tomcat 9-&gt;选择安装目录</span></span><br></pre></td></tr></table></figure>

<h3 id="开发第一个servlet应用"><a href="#开发第一个servlet应用" class="headerlink" title="开发第一个servlet应用"></a>开发第一个servlet应用</h3><ol>
<li><p>创建一个dynamic web project</p>
<p>target选择tomcat9,勾选generate web.xml deployment descriptor;</p>
</li>
<li><p>打开工程，找到src目录，右键，创建一个 servlet</p>
</li>
<li><p>输入包名及类名</p>
<img "" class="lazyload placeholder" data-original="pic\image-20210630144732069.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210630144732069" style="zoom:50%;" /></li>
<li><p>配置映射地址</p>
<img "" class="lazyload placeholder" data-original="pic\image-20210630145014964.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="image-20210630145014964" style="zoom:50%;" /></li>
<li><p>下一步，完成</p>
</li>
<li><p>编写servlet代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;		</span><br><span class="line">	System.out.println(<span class="string">&quot;这是我的第一个网页&quot;</span>);		</span><br><span class="line">	response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	PrintWriter out=response.getWriter();</span><br><span class="line">	</span><br><span class="line">	out.println(<span class="string">&quot;这是我的第一个Servlet,你们访问到吗&quot;</span>);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行</p>
</li>
</ol>
<h2 id="2-servlet介绍"><a href="#2-servlet介绍" class="headerlink" title="2.servlet介绍"></a>2.servlet介绍</h2><h3 id="2-1什么是Servlet"><a href="#2-1什么是Servlet" class="headerlink" title="2.1什么是Servlet"></a>2.1什么是Servlet</h3><p>​    从广义上看：servlet是一组由JCP定义的规范；</p>
<p>​    从狭义上看；servlet是一个运行在服务器里的组件，它主要负责接受客户端的请求，并且对客户端进行响应，通常运行在HTTP协议上；</p>
<h3 id="2-2如何开发一个servlet"><a href="#2-2如何开发一个servlet" class="headerlink" title="2.2如何开发一个servlet;"></a>2.2如何开发一个servlet;</h3><ol>
<li>自定义Servlet类（通常继承HttpServlet）,并重写请求方法；</li>
<li>配置Servlet（映射地址）url-pattern</li>
</ol>
<h3 id="2-3开发一个Servlet的具体步骤"><a href="#2-3开发一个Servlet的具体步骤" class="headerlink" title="2.3开发一个Servlet的具体步骤"></a>2.3开发一个Servlet的具体步骤</h3><ol>
<li><p>定义一个Servlet类，继承HttpServlet类</p>
</li>
<li><p>重定doGet或goPost方法；</p>
</li>
<li><p>配置Servlet的映射路径</p>
<p>两种配置</p>
<ul>
<li>xml servlet ,servlet-mapping</li>
<li>annotation @WebServlet(“/first.do”)</li>
</ul>
</li>
<li><p>启动tomcat</p>
</li>
<li><p>在浏览器中输入<a href="http://localhost:8080/%E5%BA%94%E7%94%A8%E5%90%8D/first.do">http://localhost:8080/应用名/first.do</a></p>
</li>
</ol>
<p>​    </p>
<h3 id="2-4Servlet的web-xml配置方式"><a href="#2-4Servlet的web-xml配置方式" class="headerlink" title="2.4Servlet的web.xml配置方式"></a>2.4Servlet的web.xml配置方式</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#两件事，1.创建Servlet实例，2.映射路径</span></span><br><span class="line"><span class="attr">&lt;servlet&gt;</span></span><br><span class="line">  	<span class="attr">&lt;servlet-name&gt;SecondServlet&lt;/servlet-name&gt;</span></span><br><span class="line">  	<span class="attr">&lt;servlet-class&gt;com.huayu.servlet.SecondServlet&lt;/servlet-class&gt;</span></span><br><span class="line">  <span class="attr">&lt;/servlet&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">增加映射</span></span><br><span class="line">  <span class="attr">&lt;servlet-mapping&gt;</span></span><br><span class="line">  	<span class="attr">&lt;servlet-name&gt;secondServlet&lt;/servlet-name&gt;</span></span><br><span class="line">  	<span class="attr">&lt;url-pattern&gt;/first.do&lt;/url-pattern&gt;</span></span><br><span class="line">  <span class="attr">&lt;/servlet-mapping&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-HttpServletRequest接口"><a href="#2-5-HttpServletRequest接口" class="headerlink" title="2.5 HttpServletRequest接口"></a>2.5 HttpServletRequest接口</h3><p>request代表客户端的请求信息，<strong>由web容器创建</strong>，并将它以参数的形式传给servlet的service方法，（doGet,doPost等）</p>
<p>HttpServletRequest 是ServletRequest的子接口；</p>
<p>HttpServletRequest提供的方法有</p>
<ol>
<li><p>getParameter(name):根据请求参数名获得参数值</p>
<p>参数的形式：</p>
<p>​        表单中的表单项（文本框，密码框，下拉列表，复选）</p>
<p>​        Url后的查询字符串<a href="http://localhost:8080/?userName=xxx&amp;age=45">http://localhost:8080?userName=xxx&amp;age=45</a></p>
</li>
<li><p>setCharacterEncoding():设置请求体的字符编码</p>
</li>
<li><p>getParameterMap():获得所有的请求数据；</p>
</li>
<li><p>getParameterNames():获得所有的请求名</p>
</li>
<li><p>getParameterValues(): 获得多值参数，返回的是一个String[]; checkbox</p>
</li>
<li><p>getRemoteAddr(): 获得运程IP地址；</p>
</li>
<li><p>getServerPort(): 获得本地的端口</p>
</li>
<li><p>getRemotePort(): 获得远程端口</p>
</li>
<li><p>getRequestURI():获得请求的URI</p>
</li>
<li><p>getRequestURL(): 获得请求的完整的URL</p>
</li>
<li><p>getQueryString(): 获得查询字符串</p>
</li>
<li><p>getMethod(): 获得请求方法；</p>
</li>
<li><p>getProtocal(): 获得协议</p>
</li>
<li><p>getHeaderNames(): 获得所有消息头的名称</p>
</li>
<li><p>getHeader(): 获得某个消息头的名称</p>
</li>
</ol>
<h3 id="2-6小练习"><a href="#2-6小练习" class="headerlink" title="2.6小练习"></a>2.6小练习</h3><ol>
<li>测试request15个方法；</li>
<li>定义一个表，学员表，学号，姓名，性别（单选），学历，将表单的数据插入到数据库中；</li>
</ol>
<h3 id="2-7HttpServletResponse"><a href="#2-7HttpServletResponse" class="headerlink" title="2.7HttpServletResponse"></a>2.7HttpServletResponse</h3><p>​    服务端创建一个Response对象，向客户返回响应；Response是由容器来创建的，并且将它通过参数的形式传递给Servlet的service方法；</p>
<p>​    ServletResponse是HttpServletResponse的父接口；</p>
<p>​    常用的方法有：</p>
<ol>
<li><p>setContentType():设置响应主体的内容的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>getWriter():返回一个字符流，用来向客户端写文本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter out=response.getWriter();</span><br></pre></td></tr></table></figure></li>
<li><p>getOutputStream():返回一个字节流，用来向客户端写二进制</p>
</li>
<li><p>addHeader():向客户端写入一个消息头</p>
</li>
<li><p>addCookie():向客户端写入一个cookie</p>
</li>
<li><p>sendRedirect():重定向</p>
</li>
<li><p>sendError():发送一个错误</p>
</li>
</ol>
<h4 id="2-8案例图书表的CRD"><a href="#2-8案例图书表的CRD" class="headerlink" title="2.8案例图书表的CRD"></a>2.8案例图书表的CRD</h4><ol>
<li>创建一个图书；</li>
<li>创建一个VO及一个Dao；</li>
<li>创建三个Servlet，分别是SaveServlet,SelectServlet,DeleteServlet;</li>
<li>定义SelectServlet，映射名是select.do</li>
</ol>
<h2 id="3-Servlet的生命周期"><a href="#3-Servlet的生命周期" class="headerlink" title="3.Servlet的生命周期"></a>3.Servlet的生命周期</h2><p>life cycle:从创建到销亡所经历的各个阶段；</p>
<ol>
<li>创建：由容器来创建；</li>
<li>init：初始化</li>
<li>service：提供服务doGet,doPost</li>
<li>destroy：销毁（将servlet从容器中移除时调用的方法）</li>
<li>垃圾回收</li>
</ol>
<p><strong>默认情况下，Servlet会在用户第一次发送请求时被创建，同时调用init初始化方法；当然，我们也可通过配置来改变加载的时间</strong></p>
<p>可以通过loadOnOtartup来进行配置，值为-1时，代表第一次请求时加载，如果值为正数，代表服务器启动时加载，数值越小，加载的时间越早；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value=&quot;/save1.do&quot;,loadOnStartup = 8)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1关于servive方法"><a href="#3-1关于servive方法" class="headerlink" title="3.1关于servive方法"></a>3.1关于servive方法</h3><p>每个Servlet只被创建一个实例，但Service是多线程的，即并发量很大的情况下，Web容器会为service方法创建多个线程；从而解决多并发的问题；</p>
<p>service方法是多线程的，但Servlet不是线程安全的；</p>
<h3 id="3-2-ServletConfig-了解"><a href="#3-2-ServletConfig-了解" class="headerlink" title="3.2.ServletConfig(了解)"></a>3.2.ServletConfig(了解)</h3><p>这个对象的作用是容器通过它来向Servlet的初始化方法传递一些配置信息；</p>
<p>传递配置信息可以通过Annotation或xml；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(value=&quot;/lifeCycle.do&quot;,loadOnStartup = 1,initParams = &#123;@WebInitParam(name = &quot;userName&quot;,value=&quot;scott&quot;),@WebInitParam(name = &quot;password&quot;,value=&quot;tiger&quot;)&#125;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.init();		</span><br><span class="line">		String name=config.getInitParameter(<span class="string">&quot;userName&quot;</span>);		</span><br><span class="line">		System.out.println(<span class="string">&quot;数据库的用户名：&quot;</span>+name);		</span><br><span class="line">		System.out.println(<span class="string">&quot;Life Cycle被初始化；&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3会话跟踪技术"><a href="#3-3会话跟踪技术" class="headerlink" title="3.3会话跟踪技术"></a>3.3会话跟踪技术</h3><p>会话(session)：有始有终的一系列请求；</p>
<p>会话跟踪技术；</p>
<ol>
<li><p>cookies;（服务端向客户端发送的小文本，通过小文本可以记录一下sessionID）</p>
</li>
<li><p>SSL</p>
</li>
<li><p>URL Rewriting(重写URL)</p>
</li>
</ol>
<h4 id="HttpSession"><a href="#HttpSession" class="headerlink" title="HttpSession"></a>HttpSession</h4><p>HttpSession也是由容器来创建的组件，这个组件代表客户端与服务器的一个会话；开发者可以使用它来存储或读取会话信息；</p>
<p>如何获得HttpSession呢？</p>
<p>request.getSession();</p>
<p>HttpSession常用的方法；</p>
<ol>
<li>setAttribute(key,value);向session中存储数据</li>
<li>getAttribute(key);获取session中的数据（根据key）</li>
<li>getAttributeNames(): 获得所有keys;</li>
<li>getId():获取sessionId;</li>
<li>invalidate():手动销毁session;</li>
<li>setMaxInactiveInterval():设置当前session的超时时间；时间单位是秒；</li>
</ol>
<h4 id="练习：未登录不能访问，已经登录后可以查看登录信息；"><a href="#练习：未登录不能访问，已经登录后可以查看登录信息；" class="headerlink" title="练习：未登录不能访问，已经登录后可以查看登录信息；"></a>练习：未登录不能访问，已经登录后可以查看登录信息；</h4><ol>
<li>创建一个登录页面；</li>
<li>创建一个登录的Servlet，在Servlet中校验用户名及密码，如成功，则将用户信息存在session中；否则提示登录失败</li>
<li>定义一个用户信息查看的Servlet，获得session,查看sssion中是否存在用户，如存在，则从session获取信息，并显示，否则重定向到登录页；</li>
</ol>
<h3 id="修改session的超时时间"><a href="#修改session的超时时间" class="headerlink" title="修改session的超时时间"></a>修改session的超时时间</h3><ol>
<li><p>可以通过session.setMaxInactiveInterval(秒数)；来设计</p>
</li>
<li><p>通过web.xml文件来统一设置（单位是分钟）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>60<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="手动销毁session"><a href="#手动销毁session" class="headerlink" title="手动销毁session"></a>手动销毁session</h3><p>invalidate():手动销毁session;</p>
<h2 id="4-Servlet其他组件"><a href="#4-Servlet其他组件" class="headerlink" title="4.Servlet其他组件"></a>4.Servlet其他组件</h2><h3 id="4-1ServletContext-上下文"><a href="#4-1ServletContext-上下文" class="headerlink" title="4.1ServletContext(上下文);"></a>4.1ServletContext(上下文);</h3><p>servletContext是Servlet的上下文，通过这个对象，程序可以与web容器来进行通信；</p>
<p>每个应用只有一个上下文对象；所有的Servlet 所有的Session会共享同一个Context；</p>
<p>Context主要作用：</p>
<p>​    1.作为域对象可以将工程中共享的数据存在此对象中（例如在线用户数，网站的点击数等）</p>
<p>​        setAttribute（）；</p>
<p>​        getAttribute（）；</p>
<p>​        removeAttribute（）；</p>
<p>​    2.获取绝对路径 ：（根据相对路径获取绝对路径）</p>
<p>​    3.获取上下文名称（getContextPath）</p>
<p>获取网页的登录数量：</p>
<ol>
<li><p>启动 服务器时点击数为0；</p>
<p>​    servletContext.setAttribute(loginCount);</p>
</li>
<li><p>每次登陆后+1；</p>
<p>sservletContext.setAttribute(loginCount+1);</p>
<h2 id="4-2cookie"><a href="#4-2cookie" class="headerlink" title="4.2cookie"></a>4.2cookie</h2><h3 id="1-什么是cookie？-3W1H"><a href="#1-什么是cookie？-3W1H" class="headerlink" title="1.什么是cookie？(3W1H)"></a>1.什么是cookie？(3W1H)</h3><p>封装了由Servlet向浏览器发送的文本数据，浏览器会保存这些数据并自动再发送回服务器；</p>
<p>用于会话管理，令牌</p>
<p>每个cookie都有name，value，maxAge等属性，每个服务器可以向浏览器写20个cookie，每个cookie不能超过4kb</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie c=<span class="keyword">new</span> Cookie(<span class="string">&quot;username&quot;</span>,user.getUserName());</span><br><span class="line">c.setName();</span><br><span class="line">c.setValue();</span><br><span class="line">c.setmaxAge();</span><br></pre></td></tr></table></figure>

<h3 id="2-如何向客户端发送cookie？"><a href="#2-如何向客户端发送cookie？" class="headerlink" title="2.如何向客户端发送cookie？"></a>2.如何向客户端发送cookie？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.addcookie(c)</span><br></pre></td></tr></table></figure>

<h3 id="3-如何获得浏览器返回的cookie？"><a href="#3-如何获得浏览器返回的cookie？" class="headerlink" title="3.如何获得浏览器返回的cookie？"></a>3.如何获得浏览器返回的cookie？</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得所有cookie</span></span><br><span class="line">request.getcookies();</span><br></pre></td></tr></table></figure>

<h3 id="4-JSP"><a href="#4-JSP" class="headerlink" title="4.JSP"></a>4.JSP</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Java</span> <span class="string">Server Page</span></span><br><span class="line"><span class="meta">本质就是Servlet,但sevlet在生成HTML页面过于麻烦，为了解决此问题</span> <span class="string">，出现了JSP;</span></span><br><span class="line"><span class="meta">本质是Servlet</span> <span class="string">代码像HTML；JSP必须运行在WEB容器中</span></span><br></pre></td></tr></table></figure>

<h4 id="如何编写JSP"><a href="#如何编写JSP" class="headerlink" title="如何编写JSP"></a>如何编写JSP</h4><p>1.JSP必须放在WEB容器中</p>
<p>2.JSP在与行前先被JSP引擎翻译成Servlet</p>
<p>3.然后再将Servlet类编译成class文件</p>
<p>4.JSP运行目录位于Tomcat的works下</p>
<h4 id="JSP注释"><a href="#JSP注释" class="headerlink" title="JSP注释"></a>JSP注释</h4><p>1.HTML注释</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!--</span> <span class="string">--&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.JSP隐藏注释</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;%--</span> <span class="string">--%&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="JSP脚本元素"><a href="#JSP脚本元素" class="headerlink" title="JSP脚本元素"></a>JSP脚本元素</h4><p>在JSP中编写Java代码 一共有三种方式，分别是：</p>
<p>1.声明：定义变量或方法</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;%!</span> <span class="string">int i=9; %&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;%!</span> <span class="string">public int add(int a,int b)&#123;</span></span><br><span class="line">	<span class="attr">return</span> <span class="string">a+b;</span></span><br><span class="line"><span class="attr">&#125;%&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.代码段：编写可运行的java代码 </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;%</span> <span class="string">System.out.println(&quot;hello world&quot;) %&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.表达式：输出一个表达式的结果</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;%</span>=   <span class="string">%&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="JSP指令"><a href="#JSP指令" class="headerlink" title="JSP指令"></a>JSP指令</h4><p>通过JSP指令，来告诉JSP容器如何处理 JSP内容</p>
<p>JSP指令的语法格式</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;%@</span> <span class="string">directive-name</span></span><br><span class="line"> <span class="meta">attribute-name</span>=<span class="string">attribute-value</span></span><br><span class="line"> <span class="meta">attribute-name</span>=<span class="string">attribute-value ...</span></span><br><span class="line"> <span class="attr">%&gt;</span></span><br></pre></td></tr></table></figure>

<p>JSP语法指令分类</p>
<p>1.include指令</p>
<p>​    包含，使用指令，可以在一个页面包含其他资源</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">***title.jsp</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">&lt;div</span> <span class="string">&gt;</span></span><br><span class="line">		<span class="meta">&lt;a</span> <span class="string">href=&quot;1.jsp&quot;&gt;体育&lt;/a&gt;</span></span><br><span class="line">		<span class="meta">&lt;a</span> <span class="string">href=&quot;1.html&quot;&gt;新闻体育&lt;/a&gt;</span></span><br><span class="line">		<span class="meta">&lt;a</span> <span class="string">href=&quot;2.html&quot;&gt;战争&lt;/a&gt;</span></span><br><span class="line">	<span class="attr">&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">1.jsp***</span></span><br><span class="line">	<span class="meta">&lt;%@</span> <span class="string">include file=&quot;title.jsp&quot;%&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.page指令</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">contextType</span>:<span class="string">jsp生成的文件内容类型text/html;charset=utf-8</span></span><br><span class="line"><span class="attr">import</span>: <span class="string">com.util.*</span></span><br><span class="line"><span class="attr">ErrorPage</span>:<span class="string">如果页面产生异常，将会跳转到其他页面</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>验证码</title>
    <url>/2021/08/08/%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<h4 id="第1节-验证码作用"><a href="#第1节-验证码作用" class="headerlink" title="第1节 验证码作用"></a>第1节 验证码作用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">防止恶意破解密码、刷票、论坛灌水、刷页</span><br></pre></td></tr></table></figure>



<h4 id="第2节-Kaptcha是什么"><a href="#第2节-Kaptcha是什么" class="headerlink" title="第2节 Kaptcha是什么"></a>第2节 Kaptcha是什么</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kaptcha 是一个可高度配置的实用验证码生成工具</span><br></pre></td></tr></table></figure>

<h4 id="第3节-与Spring-MVC-整合"><a href="#第3节-与Spring-MVC-整合" class="headerlink" title="第3节 与Spring MVC 整合"></a>第3节 与Spring MVC 整合</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.penggle&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;kaptcha&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--kaptcha 验证码配置--&gt;</span><br><span class="line">&lt;bean id=&quot;defaultKaptcha&quot; class=&quot;com.google.code.kaptcha.impl.DefaultKaptcha&quot;&gt;</span><br><span class="line">    &lt;!--图片边框--&gt;</span><br><span class="line">    &lt;property name=&quot;config&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;com.google.code.kaptcha.util.Config&quot;&gt;</span><br><span class="line">            &lt;constructor-arg&gt;</span><br><span class="line">                &lt;props&gt;</span><br><span class="line">                    &lt;!--生成的验证码是否有边框--&gt;</span><br><span class="line">                    &lt;prop key=&quot;kaptcha.border&quot;&gt;yes&lt;/prop&gt;</span><br><span class="line">                    &lt;!--验证码背景色--&gt;</span><br><span class="line">                    &lt;prop key=&quot;kaptcha.border.color&quot;&gt;105,179,90&lt;/prop&gt;</span><br><span class="line">                    &lt;!--验证码文本字符颜色--&gt;</span><br><span class="line">                    &lt;prop key=&quot;kaptcha.textproducer.font.color&quot;&gt;blue&lt;/prop&gt;</span><br><span class="line">                    &lt;!--验证码宽度--&gt;</span><br><span class="line">                    &lt;prop key=&quot;kaptcha.image.width&quot;&gt;164&lt;/prop&gt;</span><br><span class="line">                    &lt;!--验证码高度--&gt;</span><br><span class="line">                    &lt;prop key=&quot;kaptcha.image.height&quot;&gt;47&lt;/prop&gt;</span><br><span class="line">                    &lt;!--验证码文本字符大小--&gt;</span><br><span class="line">                    &lt;prop key=&quot;kaptcha.textproducer.font.size&quot;&gt;45&lt;/prop&gt;</span><br><span class="line">                    &lt;!--字体个数--&gt;</span><br><span class="line">                    &lt;prop key=&quot;kaptcha.textproducer.char.length&quot;&gt;4&lt;/prop&gt;</span><br><span class="line">                    &lt;!--字体--&gt;</span><br><span class="line">                    &lt;prop key=&quot;kaptcha.textproducer.font.names&quot;&gt;宋体,楷体,微软雅黑&lt;/prop&gt;</span><br><span class="line">                &lt;/props&gt;</span><br><span class="line">            &lt;/constructor-arg&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第4节-Kaptcha详细配置"><a href="#第4节-Kaptcha详细配置" class="headerlink" title="第4节 Kaptcha详细配置"></a>第4节 Kaptcha详细配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;comment&gt;Temporary Properties&lt;/comment&gt;</span><br><span class="line">    &lt;!-- 图片边框，合法值yes，no，默认值yes --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.border&quot;&gt;no&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 边框颜色，合法值rgb(and optional alpha)或者 white,black,blue，默认值black --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.border.color&quot;&gt;blue&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 边框厚度，合法值&gt;0,默认值为1 --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.border.thickness&quot;&gt;2&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 图片宽度，默认值200 --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.image.width&quot;&gt;200&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 图片高度，默认值50 --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.image.height&quot;&gt;50&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 图片实现类，默认值priv.kerlomz.kaptcha.impl.DefaultKaptcha --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.producer.impl&quot;&gt;priv.kerlomz.kaptcha.impl.DefaultKaptcha&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 文本实现类,默认值priv.kerlomz.kaptcha.impl.DefaultTextCreator --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.textproducer.impl&quot;&gt;priv.kerlomz.kaptcha.text.impl.DefaultTextCreator&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 文本集合，验证码值从此集合中获取,默认值abcde2345678gfynmnpwx --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.textproducer.char.string&quot;&gt;abcde2345678gfynmnpwx&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 验证码长度,默认值为5 --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.textproducer.char.length&quot;&gt;5&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 字体,默认值Arial, Courier(如果使用中文验证码，则必须使用中文的字体，否则出现乱码) --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.textproducer.font.names&quot;&gt;Arial&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 字体大小，默认值为40px --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.textproducer.font.size&quot;&gt;40&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 字体颜色，合法值： r,g,b 或者 white,black,blue，默认值black --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.textproducer.font.color&quot;&gt;black&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 文字间隔，默认值为2 --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.textproducer.char.space&quot;&gt;2&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 干扰实现类，默认值priv.kerlomz.kaptcha.impl.DefaultNoise --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.noise.impl&quot;&gt;priv.kerlomz.kaptcha.impl.DefaultNoise&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 干扰 颜色，合法值： r,g,b 或者 white,black,blue，默认值black --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.noise.color&quot;&gt;black&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 图片样式： </span><br><span class="line">         水纹 priv.kerlomz.kaptcha.impl.WaterRipple </span><br><span class="line">         鱼眼 priv.kerlomz.kaptcha.impl.FishEyeGimpy</span><br><span class="line">         阴影 priv.kerlomz.kaptcha.impl.ShadowGimpy, 默认值水纹    </span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.obscurificator.impl&quot;&gt;priv.kerlomz.kaptcha.impl.WaterRipple&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 背景实现类，默认值priv.kerlomz.kaptcha.impl.DefaultBackground --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.background.impl&quot;&gt;priv.kerlomz.kaptcha.impl.DefaultBackground&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 背景颜色渐变，开始颜色，默认值lightGray/192,193,193 --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.background.clear.from&quot;&gt;255,255,255&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 背景颜色渐变， 结束颜色，默认值white --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.background.clear.to&quot;&gt;white&lt;/entry&gt;</span><br><span class="line">    &lt;!-- 文字渲染器，默认值priv.kerlomz.kaptcha.text.impl.DefaultWordRenderer --&gt;</span><br><span class="line">    &lt;entry key=&quot;kaptcha.word.impl&quot;&gt;priv.kerlomz.kaptcha.text.impl.DefaultWordRenderer&lt;/entry&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>

<h4 id="第5节-Java代码实现"><a href="#第5节-Java代码实现" class="headerlink" title="第5节 Java代码实现"></a>第5节 Java代码实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*导入Kaptcha defaultKaptcha对应配置文件中bean的ID,用于创建验证码*/</span><br><span class="line">@Autowired</span><br><span class="line">private Producer defaultKaptcha;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. 获取验证码</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取验证码</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(value = &quot;/getVerifyCode&quot;,method = RequestMethod.GET)</span><br><span class="line">public void getVerifyCode(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">    System.out.println(&quot;获取验证码成功...........&quot;);</span><br><span class="line">    System.out.println(defaultKaptcha);</span><br><span class="line">    //获取session</span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line">    /*设置浏览器缓存页面的时限 0:表示不进行缓存 */</span><br><span class="line">    response.setDateHeader(&quot;Expires&quot;, 0);</span><br><span class="line">    /*JSP页面禁用缓存*/</span><br><span class="line">    response.setHeader(&quot;Cache-Control&quot;, &quot;no-store, no-cache, must-revalidate&quot;);</span><br><span class="line">    /*IE5 cache更新说明,已弃用*/</span><br><span class="line">    response.addHeader(&quot;Cache-Control&quot;, &quot;post-check=0, pre-check=0&quot;);</span><br><span class="line">    /*兼容HTTP/1.0 它的行为与 Cache-Control: no-cache 一致*/</span><br><span class="line">    response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);</span><br><span class="line">    /*内容*/</span><br><span class="line">    response.setContentType(&quot;image/jpeg&quot;);</span><br><span class="line">    /*生成验证码*/</span><br><span class="line">    String kaptchaText = defaultKaptcha.createText();</span><br><span class="line">    /*将生成的二维码放到session域中*/</span><br><span class="line">    session.setAttribute(Constants.KAPTCHA_SESSION_KEY,kaptchaText);</span><br><span class="line">    /*将生成的二维码封装进图片中然后打印到前端*/</span><br><span class="line">    BufferedImage image = defaultKaptcha.createImage(kaptchaText);</span><br><span class="line">    ServletOutputStream out = response.getOutputStream();</span><br><span class="line">    ImageIO.write(image,&quot;jpg&quot;,out);</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 验证码校验</span><br><span class="line">/**</span><br><span class="line"> * 验证码校验</span><br><span class="line"> * @param request</span><br><span class="line"> * @param kaptcha</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean checkVerifyCode(HttpServletRequest request,String kaptcha)&#123;</span><br><span class="line">    //获取我们自己生成保存到session域中的验证码</span><br><span class="line">    String kpSession = (String) request.getSession().getAttribute(Constants.KAPTCHA_SESSION_KEY);</span><br><span class="line">    /*如果数据都不为空开始校验*/</span><br><span class="line">    if(kaptcha!=null &amp;&amp; kaptcha!=&quot;&quot; &amp;&amp; kpSession!=null &amp;&amp; kpSession!=&quot;&quot;)&#123;</span><br><span class="line">        return kaptcha.equals(kpSession);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3. 登录实现</span><br><span class="line">@RequestMapping(value = &quot;/login&quot;,method = RequestMethod.POST)</span><br><span class="line">public String login(HttpServletRequest request,String username,String password,String kaptcha)&#123;</span><br><span class="line">    System.out.println(&quot;....................登录开始....................&quot;);</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    System.out.println(password);</span><br><span class="line">    System.out.println(kaptcha);</span><br><span class="line">    boolean code = checkVerifyCode(request, kaptcha);</span><br><span class="line">    System.out.println(code);</span><br><span class="line">    return &quot;01_dashboard&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第6节-前端页面实现"><a href="#第6节-前端页面实现" class="headerlink" title="第6节 前端页面实现"></a>第6节 前端页面实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;col-lg-6&quot;&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;kaptcha&quot; placeholder=&quot;验证码&quot;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;col-lg-6&quot;&gt;</span><br><span class="line">            &lt;%--获取验证码--%&gt;</span><br><span class="line">            &lt;img id=&quot;verifyCodeRefresh&quot; src=&quot;$&#123;pageContext.request.contextPath&#125;/getVerifyCode&quot; alt=&quot;验证码不存在&quot;&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">/*更新图片的src属性*/</span><br><span class="line">$(&quot;#verifyCodeRefresh&quot;).click(function () &#123;</span><br><span class="line">    this.src=&quot;$&#123;pageContext.request.contextPath&#125;/getVerifyCode?&quot;+Math.random();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2021/08/11/Linux/</url>
    <content><![CDATA[<h1 id="一、Linux的概述"><a href="#一、Linux的概述" class="headerlink" title="一、Linux的概述"></a>一、Linux的概述</h1><h2 id="1．学习Linux之前先了解Unix"><a href="#1．学习Linux之前先了解Unix" class="headerlink" title="1．学习Linux之前先了解Unix"></a>1．学习Linux之前先了解Unix</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Unix是一个强大的多用户、多任务操作系统。于<span class="number">1969</span>年在AT&amp;T的贝尔实验室开发。UNIX的商标权由国际开放标准组织（The Open Group）所拥有。UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。</span><br></pre></td></tr></table></figure>
<h2 id="2．-Linux的概述"><a href="#2．-Linux的概述" class="headerlink" title="2． Linux的概述"></a>2． Linux的概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Linux是基于Unix的</span><br><span class="line"></span><br><span class="line">Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机</span><br><span class="line"></span><br><span class="line">![img](file:<span class="comment">///C:\WINDOWS\TEMP\ksohtml8456\wps46.jpg)</span></span><br><span class="line"></span><br><span class="line">诞生于<span class="number">1991</span> 年<span class="number">10</span> 月<span class="number">5</span> 日。是由芬兰赫尔辛基大学学生Linus Torvalds和后来加入的众多爱好者共同开发完成</span><br><span class="line"></span><br><span class="line">![img](file:<span class="comment">///C:\WINDOWS\TEMP\ksohtml8456\wps47.jpg)</span></span><br></pre></td></tr></table></figure>
<h2 id="3．-Linux的历史："><a href="#3．-Linux的历史：" class="headerlink" title="3． Linux的历史："></a>3． Linux的历史：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Linux最初是由芬兰赫尔辛基大学学生Linus Torvalds由于自己不满意教学中使用的MINIX操作系统， 所以在<span class="number">1990</span>年底由于个人爱好设计出了LINUX系统核心。后来发布于芬兰最大的ftp服务器上，用户可以免费下载，所以它的周边的程序越来越多，Linux本身也逐渐发展壮大起来，之后Linux在不到三年的时间里成为了一个功能完善，稳定可靠的操作系统.</span><br></pre></td></tr></table></figure>
<h2 id="4．-Linux系统的应用："><a href="#4．-Linux系统的应用：" class="headerlink" title="4． Linux系统的应用："></a>4． Linux系统的应用：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； </span><br><span class="line"></span><br><span class="line">嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等，</span><br><span class="line"></span><br><span class="line">高性能运算、计算密集型应用Linux有强大的运算能力。</span><br><span class="line"></span><br><span class="line">桌面应用系统</span><br><span class="line"></span><br><span class="line">移动手持系统</span><br></pre></td></tr></table></figure>
<h2 id="5．Linux的版本"><a href="#5．Linux的版本" class="headerlink" title="5．Linux的版本"></a>5．Linux的版本</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Linux的版本分为两种：内核版本和发行版本；内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号 ；</span><br></pre></td></tr></table></figure>
<h2 id="6．Linux的主流版本"><a href="#6．Linux的主流版本" class="headerlink" title="6．Linux的主流版本"></a>6．Linux的主流版本</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![img](file:<span class="comment">///C:\WINDOWS\TEMP\ksohtml8456\wps48.jpg)</span></span><br></pre></td></tr></table></figure>
<h1 id="二、-Linux的安装："><a href="#二、-Linux的安装：" class="headerlink" title="二、 Linux的安装："></a>二、 Linux的安装：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## <span class="number">1</span>． 虚拟机安装：</span><br><span class="line"></span><br><span class="line">### <span class="number">1.1</span>． 什么是虚拟机</span><br><span class="line"></span><br><span class="line">虚拟机：一台虚拟的电脑.</span><br><span class="line"></span><br><span class="line">虚拟机软件:</span><br><span class="line"></span><br><span class="line"> VmWare		:收费的.</span><br><span class="line"></span><br><span class="line"> VirtualBox	:免费的.</span><br><span class="line"></span><br><span class="line">### <span class="number">1.2</span>． 安装VmWare</span><br><span class="line"></span><br><span class="line">参考《虚拟软件vmware安装.doc》</span><br><span class="line"></span><br><span class="line">## <span class="number">2</span>． CentOS的安装</span><br><span class="line"></span><br><span class="line">参考《安装 CentOS和网络配置.doc》</span><br><span class="line"></span><br><span class="line">## <span class="number">3</span>． Linux的远程访问</span><br><span class="line"></span><br><span class="line">### <span class="number">3.1</span>． 安装一个远程访问的软件:Xshell</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">### <span class="number">3.2</span>． 连接Linux:</span><br><span class="line"></span><br><span class="line">![img](file:<span class="comment">///C:\WINDOWS\TEMP\ksohtml8456\wps49.jpg)</span></span><br><span class="line"></span><br><span class="line">需要录入linux的ip地址及用户名密码</span><br><span class="line"></span><br><span class="line">查看ip地址ifconfig</span><br></pre></td></tr></table></figure>
<h1 id="三、-Linux的目录结构："><a href="#三、-Linux的目录结构：" class="headerlink" title="三、 Linux的目录结构："></a>三、 Linux的目录结构：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![img](file:<span class="comment">///C:\WINDOWS\TEMP\ksohtml8456\wps50.jpg)</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">root管理员的home目录root</span><br><span class="line"></span><br><span class="line">其他用户的home目录home目录中</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="四、-Linux的常用命令"><a href="#四、-Linux的常用命令" class="headerlink" title="四、 Linux的常用命令"></a>四、 Linux的常用命令</h1><h2 id="1．-切换目录命令cd："><a href="#1．-切换目录命令cd：" class="headerlink" title="1． 切换目录命令cd："></a>1． 切换目录命令cd：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line"></span><br><span class="line">cd app	切换到app目录</span><br><span class="line"></span><br><span class="line">cd ..	切换到上一层目录</span><br><span class="line"></span><br><span class="line">cd /		切换到系统根目录</span><br><span class="line"></span><br><span class="line">cd ~		切换到用户主目录</span><br><span class="line"></span><br><span class="line">cd -		切换到上一个所在目录</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">使用tab键来补全文件路径</span><br></pre></td></tr></table></figure>
<h2 id="2．-列出文件列表：ls-ll"><a href="#2．-列出文件列表：ls-ll" class="headerlink" title="2． 列出文件列表：ls ll"></a>2． 列出文件列表：ls ll</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。  </span><br><span class="line"></span><br><span class="line"> 格式：ls[参数] [路径或文件名]</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">常用：</span><br><span class="line"></span><br><span class="line">在linux中以 . 开头的文件都是隐藏的文件</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> ls</span><br><span class="line"></span><br><span class="line"> ls -a  显示所有文件或目录（包含隐藏的文件）</span><br><span class="line"></span><br><span class="line"> ls -l  缩写成ll</span><br></pre></td></tr></table></figure>
<h2 id="3．-创建目录和移除目录：mkdir-rmdir"><a href="#3．-创建目录和移除目录：mkdir-rmdir" class="headerlink" title="3． 创建目录和移除目录：mkdir rmdir"></a>3． 创建目录和移除目录：mkdir rmdir</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mkdir(make directory)命令可用来创建子目录。</span><br><span class="line"></span><br><span class="line">mkdir app  è 在当前目录下创建app目录</span><br><span class="line"></span><br><span class="line">mkdir –p app2/test  è 级联创建aap2以及test目</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">rmdir(remove directory)命令可用来删除“空”的子目录：</span><br><span class="line"></span><br><span class="line">rmdir app  è 删除app目录</span><br></pre></td></tr></table></figure>
<h2 id="4．-浏览文件-cat-more-less"><a href="#4．-浏览文件-cat-more-less" class="headerlink" title="4． 浏览文件 cat more less"></a>4． 浏览文件 cat more less</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【cat、more、less】</span><br><span class="line"></span><br><span class="line">cat用于显示文件的内容。格式：cat[参数]&lt;文件名&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   cat yum.conf</span><br><span class="line"></span><br><span class="line">more一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。</span><br><span class="line"></span><br><span class="line">回车显示下一行内容。</span><br><span class="line"></span><br><span class="line">按 q 键退出查看。</span><br><span class="line"></span><br><span class="line"> more yum.conf</span><br><span class="line"></span><br><span class="line"> 空格显示下一页数据 回车显示下一行的数据</span><br><span class="line"></span><br><span class="line">less用法和more类似，不同的是less可以通过PgUp、PgDn键来控制。输入q 退出</span><br><span class="line"></span><br><span class="line">   less yum.conf</span><br><span class="line"></span><br><span class="line">   PgUp 和 PgDn 进行上下翻页.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">【tail】</span><br><span class="line"></span><br><span class="line">tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。</span><br><span class="line"></span><br><span class="line">用法:</span><br><span class="line"></span><br><span class="line">tail -<span class="number">10</span> /etc/passwd  è 查看后<span class="number">10</span>行数据</span><br><span class="line"></span><br><span class="line">tail -f catalina.log  è 动态查看日志()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">ctrl+c 结束查看</span><br></pre></td></tr></table></figure>
<h2 id="5．-文件操作：rm-cp-mv-tar"><a href="#5．-文件操作：rm-cp-mv-tar" class="headerlink" title="5． 文件操作：rm cp mv tar"></a>5． 文件操作：rm cp mv tar</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【rm】</span><br><span class="line"></span><br><span class="line">rm  删除文件</span><br><span class="line"></span><br><span class="line">用法：rm [选项]... 文件...</span><br><span class="line"></span><br><span class="line">rm a.txt  è 删除a.txt文件</span><br><span class="line"></span><br><span class="line">删除需要用户确认，y/n </span><br><span class="line"></span><br><span class="line">rm 删除不询问</span><br><span class="line"></span><br><span class="line">rm -f a.txt  è 不询问，直接删除rm 删除目录</span><br><span class="line"></span><br><span class="line">rm -r a  è 递归删除不询问递归删除（慎用）</span><br><span class="line"></span><br><span class="line">rm -rf  a  è 不询问递归删除</span><br><span class="line"></span><br><span class="line">rm -rf   è  删除所有文件</span><br><span class="line"></span><br><span class="line">rm -rf /  è  自杀</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">http:<span class="comment">//imgsrc.baidu.com/forum/w%3D580/sign=00fefe23dd09b3deebbfe460fcbe6cd3/940f918fa0ec08fa078d4aec55ee3d6d54fbdafc.jpg</span></span><br><span class="line"></span><br><span class="line">【cp、mv】</span><br><span class="line"></span><br><span class="line">cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。</span><br><span class="line"></span><br><span class="line">cp a.txt b.txt  è 将a.txt复制为b.txt文件</span><br><span class="line"></span><br><span class="line">cp a.txt ../  è 将a.txt文件复制到上一层目录中</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">mv 移动或者重命名</span><br><span class="line"></span><br><span class="line">mv a.txt ../  è 将a.txt文件移动到上一层目录中</span><br><span class="line"></span><br><span class="line">mv a.txt b.txt  è 将a.txt文件重命名为b.txt</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">【tar】命令:( 打包或解压)</span><br><span class="line"></span><br><span class="line">tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。常用参数：</span><br><span class="line"></span><br><span class="line">-c：创建一个新tar文件</span><br><span class="line"></span><br><span class="line">-v：显示运行过程的信息</span><br><span class="line"></span><br><span class="line">-f：指定文件名</span><br><span class="line"></span><br><span class="line">-z：调用gzip压缩命令进行压缩</span><br><span class="line"></span><br><span class="line">-t：查看压缩文件的内容</span><br><span class="line"></span><br><span class="line">-x：解开tar文件</span><br><span class="line"></span><br><span class="line">注意: 无论压缩 还是解压都要带z</span><br><span class="line"></span><br><span class="line">打包：</span><br><span class="line"></span><br><span class="line">tar –zcvf xxx.tar ./</span><br><span class="line"></span><br><span class="line">打包并且压缩：</span><br><span class="line"></span><br><span class="line">tar –zcvf xxx.tar.gz ./ </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">解压 </span><br><span class="line"></span><br><span class="line">   tar –zxvf xxx.tar</span><br><span class="line"></span><br><span class="line">tar -zxvf xxx.tar.gz -C /usr/aaa -C是大写的</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">【find】命令</span><br><span class="line"></span><br><span class="line">find指令用于查找符合条件的文件</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">find / -name “ins” 查找文件名称是以ins开头的文件</span><br><span class="line"></span><br><span class="line">find / -name “ins” –ls </span><br><span class="line"></span><br><span class="line">find / –user root –ls 查找用户root 的文件</span><br><span class="line"></span><br><span class="line">find / –user root –type d –ls 查找用户root 的目录</span><br><span class="line"></span><br><span class="line">find / -perm -<span class="number">777</span> –type d -ls 查找权限是<span class="number">777</span>的文件</span><br><span class="line"></span><br><span class="line">find  /home -name  hello.txt  按文件名</span><br><span class="line"></span><br><span class="line">find  /opt   -user   root  按用户所有者</span><br><span class="line"></span><br><span class="line">find  /  -size  +20M     M|m k b 单位</span><br><span class="line"></span><br><span class="line">find / -name .txt       模糊</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">【grep】命令</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">![img](file:<span class="comment">///C:\WINDOWS\TEMP\ksohtml8456\wps51.jpg)</span></span><br><span class="line"></span><br><span class="line">cat a.txt | grep hello      a.txt中查询 hello</span><br><span class="line"></span><br><span class="line">cat a.txt | grep -n  hello    a.txt中查询hello并显示行号</span><br><span class="line"></span><br><span class="line">cat a.txt | grep -ni  hello   a.txt中查询hello并显示行号 忽略大小写</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">cat 也可以换成 more  less</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="6．-top命令"><a href="#6．-top命令" class="headerlink" title="6． top命令"></a>6． top命令</h2><p>在企业级开发中，开发人员（运维人员也会经常使用）常常为了查看服务器上运行的程序占用的CPU情况以及占用内存情况，目的就是检测我们的程序是否在正常范围内运行</p>
<p>显示进程信息: top</p>
<p>执行效果如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![img](file:<span class="comment">///C:\WINDOWS\TEMP\ksohtml8456\wps52.jpg)</span></span><br><span class="line"></span><br><span class="line">各进程（任务）的状态监控属性解释说明： </span><br><span class="line"></span><br><span class="line">PID — 进程id USER — 进程所有者</span><br><span class="line"></span><br><span class="line"> PR — 进程优先级 </span><br><span class="line"></span><br><span class="line">NI — nice值。负值表示高优先级，正值表示低优先级 </span><br><span class="line"></span><br><span class="line">VIRT — 进程使用的虚拟内存总量，单位kb。</span><br><span class="line"></span><br><span class="line">VIRT=SWAP+RES RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA SHR — 共享内存大小，单位kb</span><br><span class="line"></span><br><span class="line"> S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 </span><br><span class="line"></span><br><span class="line">%CPU — 上次更新到现在的CPU时间占用百分比 </span><br><span class="line"></span><br><span class="line">%MEM — 进程使用的物理内存百分比 </span><br><span class="line"></span><br><span class="line">TIME+ — 进程使用的CPU时间总计，单位<span class="number">1</span>/<span class="number">100</span>秒 </span><br><span class="line"></span><br><span class="line">COMMAND — 进程名称（命令名/命令行）</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">显示指定的进程信息，以下显示进程号为<span class="number">6972</span>的进程信息，CPU、内存占用率等</span><br><span class="line"></span><br><span class="line"> top -p <span class="number">6972</span></span><br><span class="line"></span><br><span class="line">![img](file:<span class="comment">///C:\WINDOWS\TEMP\ksohtml8456\wps53.jpg)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7．-ps命令"><a href="#7．-ps命令" class="headerlink" title="7． ps命令"></a>7． ps命令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ps命令类似于我们在Windows中通过任务管理器查看进程信息</span><br><span class="line"></span><br><span class="line">Linux ps命令用于显示当前进程 (process) 的状态信息</span><br><span class="line"></span><br><span class="line">语法如下：</span><br><span class="line"></span><br><span class="line">ps </span><br><span class="line"></span><br><span class="line">显示进程信息</span><br><span class="line"></span><br><span class="line">ps -A </span><br><span class="line"></span><br><span class="line">显示指定用户信息</span><br><span class="line"></span><br><span class="line"> ps -u root</span><br><span class="line"></span><br><span class="line">显示所有进程信息 </span><br><span class="line"></span><br><span class="line">ps -ef </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="8．-kill命令"><a href="#8．-kill命令" class="headerlink" title="8． kill命令"></a>8． kill命令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">引子：</span><br><span class="line"></span><br><span class="line">前面，我们刚刚学习完了Windows上开发，比如，我们经常遇到的要给问题就是，我们需要经常的启动或者重启tomcat，有的时候会报端口冲突，这个时候，我们可能就去Windows的任务管理器中去结束这个进程</span><br><span class="line"></span><br><span class="line">那么在Linux中我们可以通过kill命令来实现Windwos上手工结束进程的操作</span><br><span class="line"></span><br><span class="line">Linux kill命令用于删除执行中的程序或工作(可强制中断)</span><br><span class="line"></span><br><span class="line">使用者权限：所有用户</span><br><span class="line"></span><br><span class="line">语法如下：</span><br><span class="line"></span><br><span class="line">kill [-s &lt;信息名称或编号&gt;][程序]　或　kill [-l &lt;信息编号&gt;]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line"></span><br><span class="line">-l &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称。</span><br><span class="line"></span><br><span class="line">-s &lt;信息名称或编号&gt; 　指定要送出的信息。</span><br><span class="line"></span><br><span class="line">[程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。</span><br><span class="line"></span><br><span class="line">杀死一个进程</span><br><span class="line"></span><br><span class="line"> kill <span class="number">15642</span></span><br><span class="line"></span><br><span class="line">强制杀死进程</span><br><span class="line"></span><br><span class="line">kill -KILL <span class="number">15642</span></span><br><span class="line"></span><br><span class="line">彻底杀死进程</span><br><span class="line"></span><br><span class="line">kill -<span class="number">9</span> <span class="number">15642</span></span><br><span class="line"></span><br><span class="line">杀死指定用户所有进程</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>方法一 过滤出itcast用户进程 </span><br><span class="line"></span><br><span class="line">kill -<span class="number">9</span> $(ps -ef | grep root) </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>方法二，直接杀死</span><br><span class="line"></span><br><span class="line">kill -u root</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line"></span><br><span class="line">上面列举了很多kill进程的命令</span><br><span class="line"></span><br><span class="line">但是我们我们常用的就是kill -<span class="number">9</span>命令，我们常常找到进程的pid</span><br><span class="line"></span><br><span class="line">然后通过kill -<span class="number">9</span>进行杀死进程</span><br></pre></td></tr></table></figure>
<h2 id="9．-关机命令"><a href="#9．-关机命令" class="headerlink" title="9． 关机命令"></a>9． 关机命令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">shutdown -h now</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">shudown</span><br></pre></td></tr></table></figure>
<h2 id="10．-修改密码"><a href="#10．-修改密码" class="headerlink" title="10． 修改密码"></a>10． 修改密码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">passwd命令</span><br></pre></td></tr></table></figure>
<h2 id="11．-其他常用命令"><a href="#11．-其他常用命令" class="headerlink" title="11． 其他常用命令"></a>11． 其他常用命令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">【pwd】</span><br><span class="line"></span><br><span class="line">显示当前所在目录</span><br><span class="line"></span><br><span class="line">【touch】</span><br><span class="line"></span><br><span class="line">创建一个空文件</span><br><span class="line"></span><br><span class="line"> touch a.txt</span><br><span class="line"></span><br><span class="line">【clear/ crtl + L】</span><br><span class="line"></span><br><span class="line">清屏</span><br></pre></td></tr></table></figure>
<h1 id="五、-Vi和Vim编辑器"><a href="#五、-Vi和Vim编辑器" class="headerlink" title="五、 Vi和Vim编辑器"></a>五、 Vi和Vim编辑器</h1><h2 id="1．-Vim编辑器："><a href="#1．-Vim编辑器：" class="headerlink" title="1． Vim编辑器："></a>1． Vim编辑器：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在Linux下一般使用vi编辑器来编辑文件。vi既可以查看文件也可以编辑文件。三种模式：命令行、插入、底行模式。</span><br><span class="line"></span><br><span class="line">切换到命令行模式：按Esc键；</span><br><span class="line"></span><br><span class="line">切换到插入模式：按 i 、o、a键；</span><br><span class="line"></span><br><span class="line">  i 在当前位置前插入</span><br><span class="line"></span><br><span class="line">  I 在当前行首插入</span><br><span class="line"></span><br><span class="line">  a 在当前位置后插入</span><br><span class="line"></span><br><span class="line">  A 在当前行尾插入</span><br><span class="line"></span><br><span class="line">  o 在当前行之后插入一行</span><br><span class="line"></span><br><span class="line">  O 在当前行之前插入一行</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">切换到底行模式：按 :（冒号）；更多详细用法，查询文档《Vim命令合集.docx》和《vi使用方法详细介绍.docx》</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">打开文件：vim file</span><br><span class="line"></span><br><span class="line">退出：esc à :q</span><br><span class="line"></span><br><span class="line">修改文件：输入i进入插入模式</span><br><span class="line"></span><br><span class="line">保存并退出：escà:wq</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">不保存退出：escà:q!</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">三种进入插入模式：</span><br><span class="line"></span><br><span class="line">i:在当前的光标所在处插入</span><br><span class="line"></span><br><span class="line">o:在当前光标所在的行的下一行插入</span><br><span class="line"></span><br><span class="line">a:在光标所在的下一个字符插入</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">快捷键：</span><br><span class="line"></span><br><span class="line">dd – 快速删除一行</span><br><span class="line"></span><br><span class="line">yy - 复制当前行</span><br><span class="line"></span><br><span class="line">nyy - 从当前行向后复制几行</span><br><span class="line"></span><br><span class="line">p - 粘贴</span><br><span class="line"></span><br><span class="line">R – 替换</span><br><span class="line">输入 gg 回到首行</span><br><span class="line">输入 G  回到尾行</span><br><span class="line">其他：</span><br><span class="line">   加入行号： ：set nu </span><br><span class="line">   定位到某一行 :<span class="number">1</span>(跳转到第一行)</span><br><span class="line">   模糊查询：  /a(搜索文本中的所有a)</span><br></pre></td></tr></table></figure>
<h2 id="2．-重定向输出-gt-和-gt-gt"><a href="#2．-重定向输出-gt-和-gt-gt" class="headerlink" title="2． 重定向输出&gt;和&gt;&gt;"></a>2． 重定向输出&gt;和&gt;&gt;</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;  重定向输出，覆盖原有内容；&gt;&gt; 重定向输出，又追加功能；示例：</span><br><span class="line"></span><br><span class="line">cat /etc/passwd &gt; a.txt  将输出定向到a.txt中</span><br><span class="line"></span><br><span class="line">cat /etc/passwd &gt;&gt; a.txt  输出并且追加</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">ifconfig &gt; ifconfig.txt</span><br></pre></td></tr></table></figure>
<h2 id="3．-系统管理命令"><a href="#3．-系统管理命令" class="headerlink" title="3． 系统管理命令"></a>3． 系统管理命令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ps 正在运行的某个进程的状态</span><br><span class="line"></span><br><span class="line">ps –ef  查看所有进程</span><br><span class="line"></span><br><span class="line">ps –ef | grep ssh 查找某一进程</span><br><span class="line"></span><br><span class="line">ps -ef | grep gedit 远程登录</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">kill <span class="number">2868</span>  杀掉<span class="number">2868</span>编号的进程</span><br><span class="line"></span><br><span class="line">kill -<span class="number">9</span> <span class="number">2868</span>  强制杀死进程</span><br></pre></td></tr></table></figure>
<h2 id="4．-管道"><a href="#4．-管道" class="headerlink" title="4． 管道 |"></a>4． 管道 |</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。示例</span><br><span class="line"></span><br><span class="line">ls --help | more  分页查询帮助信息</span><br><span class="line"></span><br><span class="line">ps –ef | grep java  查询名称中包含java的进程</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">ifconfig | more</span><br><span class="line"></span><br><span class="line">cat index.html | more</span><br><span class="line"></span><br><span class="line">ps –ef | grep aio</span><br></pre></td></tr></table></figure>
<h1 id="六、-Linux的权限命令"><a href="#六、-Linux的权限命令" class="headerlink" title="六、 Linux的权限命令"></a>六、 Linux的权限命令</h1><h2 id="1．-文件权限"><a href="#1．-文件权限" class="headerlink" title="1． 文件权限"></a>1． 文件权限</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![img](file:<span class="comment">///C:\WINDOWS\TEMP\ksohtml8456\wps54.jpg)</span></span><br><span class="line"></span><br><span class="line">| 属主（user） | 属组（group） | 其他用户 |      |      |      |      |      |      |</span><br><span class="line">| ------------------------------------------ | ------------------------------------------- | ------------------ | ---- | ---- | ---- | ---- | ---- | ---- |</span><br><span class="line">| r                                          | w                                           | x                  | r    | w    | x    | r    | w    | x    |</span><br><span class="line">| <span class="number">4</span>                                          | <span class="number">2</span>                                           | <span class="number">1</span>                  | <span class="number">4</span>    | <span class="number">2</span>    | <span class="number">1</span>    | <span class="number">4</span>    | <span class="number">2</span>    | <span class="number">1</span>    |</span><br><span class="line"></span><br><span class="line">r:对文件是指可读取内容 对目录是可以ls</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">w:对文件是指可修改文件内容，对目录 是指可以在其中创建或删除子节点(目录或文件)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">x:对文件是指是否可以运行这个文件，对目录是指是否可以cd进入这个目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2．-Linux三种文件类型："><a href="#2．-Linux三种文件类型：" class="headerlink" title="2． Linux三种文件类型："></a>2． Linux三种文件类型：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 </span><br><span class="line"></span><br><span class="line">目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 </span><br><span class="line"></span><br><span class="line">设备文件： Linux系统把每一个设备都看成是一个文件</span><br></pre></td></tr></table></figure>
<h2 id="3．-文件类型标识"><a href="#3．-文件类型标识" class="headerlink" title="3． 文件类型标识"></a>3． 文件类型标识</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">普通文件（-）目录（d）符号链接（l）</span><br><span class="line"></span><br><span class="line"> 进入etc可以查看，相当于快捷方式字符设备文件（c）块设备文件（s）套接字（s）命名管道（p）</span><br><span class="line"></span><br><span class="line">![img](file:<span class="comment">///C:WINDOWSTEMPksohtml8456wps11.jpg) </span></span><br><span class="line"></span><br><span class="line">权限的基本介绍</span><br><span class="line"></span><br><span class="line">ls -l 中显示的内容如下：</span><br><span class="line"></span><br><span class="line">-rw-r--r--.  <span class="number">1</span> tom  group2  <span class="number">450</span> <span class="number">9</span>月  <span class="number">9</span> <span class="number">15</span>:<span class="number">59</span> a.txt</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>-<span class="number">9</span>位说明</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>)第<span class="number">0</span>位确定文件类型(d, -, l , c , b)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>)第<span class="number">1</span>-<span class="number">3</span>位确定所有者（该文件的所有者）拥有该文件的权限。---User</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>)第<span class="number">4</span>-<span class="number">6</span>位确定所属组（同用户组的）拥有该文件的权限，---Group</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>)第<span class="number">7</span>-<span class="number">9</span>位确定其他用户拥有该文件的权限---Other</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4．-文件权限管理："><a href="#4．-文件权限管理：" class="headerlink" title="4． 文件权限管理："></a>4． 文件权限管理：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">​	chmod 变更文件或目录的权限。</span><br><span class="line"></span><br><span class="line">chmod <span class="number">755</span> a.txt </span><br><span class="line"></span><br><span class="line">chmod u=rwx,g=rx,o=rx a.txt</span><br></pre></td></tr></table></figure>

<h1 id="七、-Linux上常用网络操作"><a href="#七、-Linux上常用网络操作" class="headerlink" title="七、 Linux上常用网络操作"></a>七、 Linux上常用网络操作</h1><h2 id="1．-主机名配置"><a href="#1．-主机名配置" class="headerlink" title="1． 主机名配置"></a>1． 主机名配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hostname 查看主机名</span><br><span class="line"></span><br><span class="line">hostname xxx 修改主机名 重启后无效</span><br><span class="line"></span><br><span class="line">如果想要永久生效，可以修改/etc/sysconfig/network文件</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">[root<span class="meta">@centos6</span> ~]$ hostname   # 查看当前的hostnmae</span><br><span class="line"></span><br><span class="line">centos6.magedu.com</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@centos6</span> ~]$ vim /etc/sysconfig/network   # 编辑network文件修改hostname行（重启生效）</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@centos6</span> ~]$ cat /etc/sysconfig/network  # 检查修改</span><br><span class="line"></span><br><span class="line">NETWORKING=yes</span><br><span class="line"></span><br><span class="line">HOSTNAME=centos66.magedu.com</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@centos6</span> ~]$ hostname centos66.magedu.com  # 设置当前的hostname(立即生效）</span><br><span class="line"></span><br><span class="line">Centos7修改主机名</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@centos7</span> ~]$ hostnamectl set-hostname centos77.magedu.com       # 使用这个命令会立即生效且重启也生效</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@centos7</span> ~]$ hostname                         # 查看下</span><br><span class="line"></span><br><span class="line">centos77.magedu.com</span><br></pre></td></tr></table></figure>
<h2 id="2．-IP地址配置"><a href="#2．-IP地址配置" class="headerlink" title="2． IP地址配置"></a>2． IP地址配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ifconfig 查看(修改)ip地址(重启后无效)</span><br><span class="line"></span><br><span class="line">ifconfig eth0 <span class="number">192.168</span><span class="number">.12</span><span class="number">.22</span> 修改ip地址</span><br><span class="line"></span><br><span class="line">如果想要永久生效</span><br><span class="line"></span><br><span class="line">修改 /etc/sysconfig/network-scripts/ifcfg-eth0文件</span><br><span class="line"></span><br><span class="line">DEVICE=eth0 #网卡名称</span><br><span class="line">BOOTPROTO=<span class="keyword">static</span> #获取ip的方式(<span class="keyword">static</span>/dhcp/bootp/none)</span><br><span class="line"></span><br><span class="line">HWADDR=<span class="number">00</span>:0C:<span class="number">29</span>:B5:B2:<span class="number">69</span> #MAC地址</span><br><span class="line">IPADDR=<span class="number">12.168</span><span class="number">.177</span><span class="number">.129</span> #IP地址</span><br><span class="line">NETMASK=<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> #子网掩码</span><br><span class="line">NETWORK=<span class="number">192.168</span><span class="number">.177</span><span class="number">.0</span> #网络地址</span><br><span class="line">BROADCAST=<span class="number">192.168</span><span class="number">.0</span><span class="number">.255</span> #广播地址</span><br><span class="line">NBOOT=yes # 系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Centos7 ip配置参考文档&lt;&lt;centos7网络配置.doc&gt;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3．-域名映射"><a href="#3．-域名映射" class="headerlink" title="3． 域名映射"></a>3． 域名映射</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用,相当于windows系统的C:WindowsSystem32driversetchosts文件的功能</span><br><span class="line"></span><br><span class="line">![img](file:<span class="comment">///C:WINDOWSTEMPksohtml8456wps12.jpg) </span></span><br></pre></td></tr></table></figure>
<h2 id="4．-网络服务管理"><a href="#4．-网络服务管理" class="headerlink" title="4． 网络服务管理"></a>4． 网络服务管理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service network status 查看指定服务的状态</span><br><span class="line"></span><br><span class="line">service network stop 停止指定服务</span><br><span class="line"></span><br><span class="line">service network start 启动指定服务</span><br><span class="line"></span><br><span class="line">service network restart 重启指定服务</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">service --status–all 查看系统中所有后台服务</span><br><span class="line"></span><br><span class="line">netstat –nltp 查看系统中网络进程的端口监听情况</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">防火墙设置</span><br><span class="line"></span><br><span class="line">防火墙根据配置文件/etc/sysconfig/iptables来控制本机的”出”、”入”网络访问行为。</span><br><span class="line"></span><br><span class="line">service iptables status 查看防火墙状态</span><br><span class="line"></span><br><span class="line">service iptables stop 关闭防火墙</span><br><span class="line"></span><br><span class="line">service iptables start 启动防火墙</span><br><span class="line"></span><br><span class="line">chkconfig  iptables off 禁止防火墙自启</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5．-Centos7网络服务管理"><a href="#5．-Centos7网络服务管理" class="headerlink" title="5． Centos7网络服务管理"></a>5． Centos7网络服务管理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">network.service是系统提供的服务之一管理命令格式</span><br><span class="line"></span><br><span class="line">systemctl start|stop|restart|status network</span><br><span class="line"></span><br><span class="line">查询状态</span><br><span class="line"></span><br><span class="line">systemctl status network </span><br><span class="line"></span><br><span class="line"> 或</span><br><span class="line"></span><br><span class="line">systemctl status network.service</span><br><span class="line"></span><br><span class="line">重启网络服务</span><br><span class="line"></span><br><span class="line">systemctl restart network </span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">systemctl restart network.serice </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">设置开机启动</span><br><span class="line"></span><br><span class="line">systemctl enable network</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">防火墙设置</span><br><span class="line"></span><br><span class="line">centos7和Centos6 防火墙的区别：</span><br><span class="line"></span><br><span class="line">Centos6 使用的是iptables, Centos7 使用的是filewalld</span><br><span class="line"></span><br><span class="line">关闭firewall：</span><br><span class="line"></span><br><span class="line">systemctl status firewalld.service  #查看防火墙状态</span><br><span class="line"></span><br><span class="line">systemctl restart firewalld.service  #重新启动防火墙</span><br><span class="line"></span><br><span class="line">systemctl stop firewalld.service    #停止firewall</span><br><span class="line"></span><br><span class="line">systemctl disable firewalld.service  #禁止firewall开机启动</span><br><span class="line"></span><br><span class="line">systemctl enable firewalld.service  #firewall开机启动</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">查询、开放、关闭端口</span><br><span class="line"></span><br><span class="line"># 查询端口是否开放</span><br><span class="line"></span><br><span class="line">firewall-cmd  --query-port=<span class="number">8080</span>/tcp</span><br><span class="line"></span><br><span class="line"># 开放<span class="number">80</span>端口</span><br><span class="line"></span><br><span class="line">firewall-cmd  --permanent  --add-port=<span class="number">80</span>/tcp</span><br><span class="line"></span><br><span class="line">firewall-cmd  --permanent  --add-port=<span class="number">8080</span>-<span class="number">8085</span>/tcp</span><br><span class="line"></span><br><span class="line"># 移除端口</span><br><span class="line"></span><br><span class="line">firewall-cmd  --permanent  --remove-port=<span class="number">8080</span>/tcp</span><br><span class="line"></span><br><span class="line">查看防火墙的开放的端口</span><br><span class="line"></span><br><span class="line">firewall-cmd  --permanent --list-ports</span><br><span class="line"></span><br><span class="line">#重启防火墙(修改配置后要重启防火墙)</span><br><span class="line"></span><br><span class="line">firewall-cmd  --reload</span><br></pre></td></tr></table></figure>
<h1 id="八、-Linux上软件安装"><a href="#八、-Linux上软件安装" class="headerlink" title="八、 Linux上软件安装"></a>八、 Linux上软件安装</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">l Linux上的软件安装有以下几种常见方式介绍</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 二进制发布包</span><br><span class="line"></span><br><span class="line">软件已经针对具体平台编译打包发布，只要解压，修改配置即可</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> RPM包</span><br><span class="line"></span><br><span class="line">软件已经按照redhat的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用RPM命令进行安装</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Yum在线安装</span><br><span class="line"></span><br><span class="line">软件已经以RPM规范打包，但发布在了网络上的一些服务器上，可用yum在线安装服务器上的rpm软件，并且会自动解决软件安装过程中的库依赖问题</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 源码编译安装</span><br><span class="line"></span><br><span class="line">软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署。</span><br></pre></td></tr></table></figure>
<h2 id="1．-在Linux上安装JDK"><a href="#1．-在Linux上安装JDK" class="headerlink" title="1． 在Linux上安装JDK:"></a>1． 在Linux上安装JDK:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">【步骤一】：上传JDK到Linux的服务器.</span><br><span class="line"></span><br><span class="line"> 上传JDK</span><br><span class="line"></span><br><span class="line"> 卸载open-JDK</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">java –version</span><br><span class="line"></span><br><span class="line">rpm -qa | grep java</span><br><span class="line"></span><br><span class="line">强力卸载:</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps java-<span class="number">1.6</span><span class="number">.0</span>-openjdk-<span class="number">1.6</span><span class="number">.0</span><span class="number">.35</span>-<span class="number">1.13</span><span class="number">.7</span><span class="number">.1</span>.el6_6.i686</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps java-<span class="number">1.7</span><span class="number">.0</span>-openjdk-<span class="number">1.7</span><span class="number">.0</span><span class="number">.79</span>-<span class="number">2.5</span><span class="number">.5</span><span class="number">.4</span>.el6.i686</span><br><span class="line"></span><br><span class="line">【步骤二】：在Linux服务器上安装JDK.</span><br><span class="line"></span><br><span class="line"> 通常将软件安装到/opt/software  #software是自己新建的目录  </span><br><span class="line"></span><br><span class="line"> 直接解压就可以</span><br><span class="line"></span><br><span class="line">  tar –zxvf  jdk.tar.gz  -C 目标路径 </span><br><span class="line"></span><br><span class="line">![img](file:<span class="comment">///C:WINDOWSTEMPksohtml8456wps13.jpg) </span></span><br><span class="line"></span><br><span class="line">【步骤三】：配置JDK的环境变量.</span><br><span class="line"></span><br><span class="line">配置环境变量：</span><br><span class="line"></span><br><span class="line">① vim /etc/profile</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">② 在末尾行添加</span><br><span class="line"></span><br><span class="line">​	#set java environment</span><br><span class="line"></span><br><span class="line">​	JAVA_HOME=/usr/local/jdk/jdk1<span class="number">.7</span><span class="number">.0_71</span></span><br><span class="line"></span><br><span class="line">​	CLASSPATH=.:$JAVA_HOME/lib.tools.jar</span><br><span class="line"></span><br><span class="line">​	PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">​	export JAVA_HOME CLASSPATH PATH</span><br><span class="line"></span><br><span class="line">保存退出</span><br><span class="line"></span><br><span class="line">③source /etc/profile  使更改的配置立即生效</span><br></pre></td></tr></table></figure>
<h2 id="2．-在Linux上安装Mysql"><a href="#2．-在Linux上安装Mysql" class="headerlink" title="2． 在Linux上安装Mysql:"></a>2． 在Linux上安装Mysql:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">【步骤一】：将mysql的安装文件上传到Linux的服务器.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">将mysql的tar解压</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@main</span> software]# mkdir mysql</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@main</span> software]# tar -xvf MySQL-<span class="number">5.5</span><span class="number">.60</span>-<span class="number">1.</span>el7.x86_64.rpm-bundle.tar -C ./mysql/</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">将系统自带的mysql卸载</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@main</span> software]# rpm -qa | grep mysql</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@main</span> software]# rpm -qa | grep maria</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">如果有先卸载自带的mysql 和 maria :  </span><br><span class="line"></span><br><span class="line">[root<span class="meta">@main</span> mysql]# rpm -qa | grep mysql</span><br><span class="line"></span><br><span class="line">qt-mysql-<span class="number">4.8</span><span class="number">.7</span>-<span class="number">8.</span>el7.x86_64</span><br><span class="line"></span><br><span class="line">akonadi-mysql-<span class="number">1.9</span><span class="number">.2</span>-<span class="number">4.</span>el7.x86_64</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@main</span> mysql]# rpm -qa | grep maria</span><br><span class="line"></span><br><span class="line">mariadb-server-<span class="number">5.5</span><span class="number">.68</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line"></span><br><span class="line">mariadb-<span class="number">5.5</span><span class="number">.68</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line"></span><br><span class="line">mariadb-libs-<span class="number">5.5</span><span class="number">.68</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line"></span><br><span class="line">卸载:</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps qt-mysql-<span class="number">4.8</span><span class="number">.7</span>-<span class="number">8.</span>el7.x86_64</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps akonadi-mysql-<span class="number">1.9</span><span class="number">.2</span>-<span class="number">4.</span>el7.x86_64</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps mariadb-server-<span class="number">5.5</span><span class="number">.68</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps mariadb-<span class="number">5.5</span><span class="number">.68</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps mariadb-libs-<span class="number">5.5</span><span class="number">.68</span>-<span class="number">1.</span>el7.x86_64</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">【步骤二】：先安装MYSQL服务端 </span><br><span class="line"></span><br><span class="line">[root<span class="meta">@main</span> mysql]# rpm  -ivh MySQL-server-<span class="number">5.5</span><span class="number">.60</span>-<span class="number">1.</span>el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">![img](file:<span class="comment">///C:WINDOWSTEMPksohtml8456wps14.jpg) </span></span><br><span class="line"></span><br><span class="line">第一次安装会出现以下警告:</span><br><span class="line"></span><br><span class="line">警告：MySQL-server-<span class="number">5.5</span><span class="number">.60</span>-<span class="number">1.</span>el7.x86_64.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">【步骤三】：安装MYSQL客户端</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@main</span> mysql]# rpm  -ivh MySQL-client-<span class="number">5.5</span><span class="number">.60</span>-<span class="number">1.</span>el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">![img](file:<span class="comment">///C:WINDOWSTEMPksohtml8456wps15.jpg) </span></span><br><span class="line"></span><br><span class="line">登录mysql</span><br><span class="line"></span><br><span class="line">需要开启mysql服务</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@main</span> mysql]# service mysql start</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">登录mysql:</span><br><span class="line"></span><br><span class="line">![img](file:<span class="comment">///C:WINDOWSTEMPksohtml8456wps16.jpg) </span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">退出mysql:</span><br><span class="line"></span><br><span class="line">mysql&gt; exit</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">登录并设置root密码:</span><br><span class="line"></span><br><span class="line">mysql -uroot</span><br><span class="line"></span><br><span class="line">set password=password(<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line"></span><br><span class="line">关闭防火墙:</span><br><span class="line"></span><br><span class="line">systemctl stop firewalld.service #关闭防火墙</span><br><span class="line"></span><br><span class="line">systemctl disable firewalld.service  #禁止firewall开机启动</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">开启远程登录:</span><br><span class="line"></span><br><span class="line">#权限放大到任何一台机器都可以远程登录</span><br><span class="line"></span><br><span class="line">grant all privileges on . to <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&#x27;root&#x27;</span>;  </span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">l Mysql服务加入到系统服务并自动启动操作：</span><br><span class="line"></span><br><span class="line">chkconfig --add  mysql</span><br><span class="line"></span><br><span class="line">自动启动：</span><br><span class="line"></span><br><span class="line">chkconfig  mysql  on</span><br><span class="line"></span><br><span class="line">查询列表：</span><br><span class="line"></span><br><span class="line">Chkconfig</span><br><span class="line"></span><br><span class="line">l Mysql中文乱码：</span><br><span class="line"></span><br><span class="line">mysql 配置文件存放的位置:</span><br><span class="line"></span><br><span class="line">/usr/share/mysql</span><br><span class="line"></span><br><span class="line">将/usr/share/mysql/my-small.cnf 复制到 /etc/my.cnf下</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@main</span> mysql]# cp  /usr/share/mysql/my-small.cnf /etc/my.cnf</span><br><span class="line"></span><br><span class="line">修改/etc/my.cnf文件  character_set_server=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">character_set_server = utf8</span><br><span class="line"></span><br><span class="line">port       = <span class="number">3306</span></span><br><span class="line"></span><br><span class="line">socket      = /<span class="keyword">var</span>/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line">skip-external-locking</span><br><span class="line"></span><br><span class="line">key_buffer_size = 16K</span><br><span class="line"></span><br><span class="line">max_allowed_packet = 1M</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">重新启动服务  配置生效</span><br><span class="line"></span><br><span class="line">[root<span class="meta">@main</span> mysql]# service mysql restart</span><br></pre></td></tr></table></figure>
<h2 id="3．-在Linux上安装tomcat"><a href="#3．-在Linux上安装tomcat" class="headerlink" title="3． 在Linux上安装tomcat:"></a>3． 在Linux上安装tomcat:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>Tomcat上传到linux上</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>将上传的tomcat解压 [root<span class="meta">@main</span> bin]# tar -zxvf apache-tomcat-<span class="number">9.0</span><span class="number">.50</span>.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>在tomcat/bin目录下执行 startup.sh（注意防火墙）</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>查看目标 tomcat/logs/catalina.out</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2021/08/08/Nginx%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><blockquote>
<p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的。其特点是占有内存少，并发能力强。中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等</p>
</blockquote>
<ul>
<li>官网地址</li>
</ul>
<blockquote>
<p><a href="http://nginx.org/">http://nginx.org/</a></p>
</blockquote>
<ul>
<li>版本介绍</li>
</ul>
<blockquote>
<p>Mainline version : 主线版本</p>
<p>Stable version : 稳定版本</p>
<p>Legacy versions : 历史版本</p>
</blockquote>
<hr>
<h3 id="二、Nginx安装"><a href="#二、Nginx安装" class="headerlink" title="二、Nginx安装"></a>二、Nginx安装</h3><ul>
<li>nginx windows目录简介</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB9dc661b15ac46905518f79034d29483e?method=download&shareKey=a8c242e0ec3a5d9ccf00abf30e1f5046"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB9dc661b15ac46905518f79034d29483e?method=download&shareKey=a8c242e0ec3a5d9ccf00abf30e1f5046" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><p>windows安装</p>
</li>
<li><ul>
<li>安装步骤</li>
</ul>
<blockquote>
<p>1、解压下载的nginx压缩包(所有的配置默认)</p>
<p>2、启动命令行切换到当前nginx解压目录(nginx.exe目录下)</p>
<p>3、使用命令行启动 start nginx.exe</p>
<p>4、有一个一闪而过的效果</p>
<p>windows环境下nginx常见命令:</p>
<p>1、启动 start nginx / nginx.exe</p>
<p>2、停止 nginx.exe -s stop / nginx.exe -s quit (stop快速停止/quit有序停止)</p>
<p>3、重载 nginx.exe -s reload （主要用于配置修改后的重新载入）</p>
<p>4、查看nginx版本 nginx -v</p>
</blockquote>
<ul>
<li>注意事项</li>
</ul>
<blockquote>
<p>不要直接双击nginx.exe，这样会导致修改配置后重启、停止nginx无效，需要手动关闭任务管理器内的所有nginx进程</p>
</blockquote>
<ul>
<li>成功展示</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/B5F24D3E19C04C6C99148F3D49FA5F6B?method=download&shareKey=6599957b13da3e33269a7b859280bec7"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/B5F24D3E19C04C6C99148F3D49FA5F6B?method=download&shareKey=6599957b13da3e33269a7b859280bec7" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
</li>
<li><p>Linux安装</p>
</li>
</ul>
<blockquote>
<p>1、下载<br>wget <a href="https://nginx.org/download/nginx-1.11.6.tar.gz">https://nginx.org/download/nginx-1.11.6.tar.gz</a></p>
<p>2、相关依赖库安装(Linux下nginx安装必备的安装库)</p>
<ul>
<li>2.1 gcc环境 yum install gcc-c++</li>
<li>2.2 PCRE依赖库 yum install -y pcre pcre-devel</li>
<li>2.3 zlib 依赖库 yum install -y zlib zlib-devel</li>
<li>2.4 OpenSSL安全套接字层密码库 yum install -y openssl openssl-devel</li>
</ul>
<p>3、解压nginx压缩包</p>
<p> tar -zxvf nginx-1.11.6.tar.gz</p>
<p>4、进入nginx解压目录执行<br>./configure</p>
<p>5、安装<br>make install</p>
<p>6、查找安装路径<br>whereis nginx<br>这个命令可以在Linux环境下查找到当前nginx安装到了哪里.</p>
<p>7、启动/停止nginx</p>
<ul>
<li><p>nginx的命令默认在不指定安装路径的情况下会安装到 /usr/local/nginx/sbin</p>
</li>
<li><p>Linux下nginx常用命令</p>
<p>./nginx 开启<br>./nginx -s stop 停止<br>./nginx -s quit<br>./nginx -s reload</p>
</li>
</ul>
<p>8、配置文件所在目录</p>
<p> /usr/local/nginx/conf</p>
</blockquote>
<ul>
<li>在docker平台安装nginx</li>
</ul>
<blockquote>
<p>1、在docker搜索当前的nginx镜像 docker search nginx</p>
<p>2、拉取当前最新版本 docker pull nginx:latest</p>
<p>3、查看本地镜像 docker images</p>
<p>4、运行nginx容器 docker run –name nginx-app -p 8081:80 -d nginx<br>–name nginx-app : 给容器起名字<br>-p 8081:80 : 端口映射,将本地 8081 端口映射到容器内部的 80 端口<br>-d nginx : 设置容器在在后台一直运行</p>
<p>5、访问测试,看是否安装成功</p>
</blockquote>
<hr>
<h3 id="三、Nginx配置"><a href="#三、Nginx配置" class="headerlink" title="三、Nginx配置"></a>三、Nginx配置</h3><h4 id="3-1-配置文件的构成"><a href="#3-1-配置文件的构成" class="headerlink" title="3.1 配置文件的构成"></a>3.1 配置文件的构成</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 全局块</span><br><span class="line">...              </span><br><span class="line"># events块</span><br><span class="line">events &#123;         </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"># http块</span><br><span class="line">http      </span><br><span class="line">&#123;</span><br><span class="line">    # http全局块</span><br><span class="line">    ...   </span><br><span class="line">    # 虚拟主机server块</span><br><span class="line">    server        </span><br><span class="line">    &#123; </span><br><span class="line">        # server全局块</span><br><span class="line">        ...       </span><br><span class="line">        # location块</span><br><span class="line">        location [PATTERN]   </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    # http全局块</span><br><span class="line">    ...     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-配置文件详解"><a href="#3-2-配置文件详解" class="headerlink" title="3.2 配置文件详解"></a>3.2 配置文件详解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">########### 每个指令必须有分号结束。#################</span><br><span class="line">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span><br><span class="line">#worker_processes 2;  #允许生成的进程数，默认为1</span><br><span class="line">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span><br><span class="line">error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span><br><span class="line">events &#123;</span><br><span class="line">    accept_mutex on;   #设置网路连接序列化，防止惊群现象①发生，默认为on</span><br><span class="line">    multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off</span><br><span class="line">    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll(处理请求效率更高)|resig|/dev/poll|eventport</span><br><span class="line">    worker_connections  1024;    #最大连接数，默认为512</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;   #文件扩展名与文件类型映射表</span><br><span class="line">    default_type  application/octet-stream; #默认文件类型，默认为text/plain</span><br><span class="line">    #access_log off; #取消服务日志    </span><br><span class="line">    log_format myFormat &#x27;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&#x27;; #自定义格式</span><br><span class="line">    access_log log/access.log myFormat;  #combined为日志格式的默认值</span><br><span class="line">    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span><br><span class="line">    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br><span class="line">    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。</span><br><span class="line"></span><br><span class="line">    # 定义常量</span><br><span class="line">    upstream mysvr &#123;   </span><br><span class="line">      server 127.0.0.1:7878;</span><br><span class="line">      server 192.168.10.121:3333 backup;  #热备</span><br><span class="line">    &#125;</span><br><span class="line">    error_page 404 https://www.baidu.com; #错误页 </span><br><span class="line"></span><br><span class="line">    #定义某个负载均衡服务器   </span><br><span class="line">    server &#123;</span><br><span class="line">        keepalive_requests 120; #单连接请求上限次数。</span><br><span class="line">        listen       4545;   #监听端口</span><br><span class="line">        server_name  127.0.0.1;   #监听地址       </span><br><span class="line">        location  ~*^.+$ &#123;       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span><br><span class="line">           #root path;  #根目录</span><br><span class="line">           #index vv.txt;  #设置默认页</span><br><span class="line">           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表</span><br><span class="line">           deny 127.0.0.1;  #拒绝的ip</span><br><span class="line">           allow 172.18.5.54; #允许的ip           </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>① 惊群效应</p>
<blockquote>
<p>惊群效应（thundering herd）是指多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群效应</p>
</blockquote>
<hr>
<h3 id="四、Nginx反向代理"><a href="#四、Nginx反向代理" class="headerlink" title="四、Nginx反向代理"></a>四、Nginx反向代理</h3><h4 id="4-1-什么是反向代理"><a href="#4-1-什么是反向代理" class="headerlink" title="4.1 什么是反向代理"></a>4.1 什么是反向代理</h4><blockquote>
<p>在说反向代理之前首先我们要先说一下什么是正向代理</p>
</blockquote>
<ul>
<li>正向代理概念</li>
</ul>
<blockquote>
<p>正向代理指的是，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端</p>
</blockquote>
<p><a href="https://note.youdao.com/yws/api/personal/file/DE41E2E36B79423386D3A844608A36B5?method=download&shareKey=71871444dfe5c7bc9ab62358d2d5245b"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/DE41E2E36B79423386D3A844608A36B5?method=download&shareKey=71871444dfe5c7bc9ab62358d2d5245b" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li>反向代理概念</li>
</ul>
<blockquote>
<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器</p>
</blockquote>
<p><a href="https://note.youdao.com/yws/api/personal/file/15CF5B742EA54457BC9680C71A91AE40?method=download&shareKey=732ca220deb994e6294ef5b7bdbdf8c6"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/15CF5B742EA54457BC9680C71A91AE40?method=download&shareKey=732ca220deb994e6294ef5b7bdbdf8c6" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<blockquote>
<p>怎么区分正向代理和反向代理:</p>
<ol>
<li>首先代理是一种设计模式</li>
<li>服务器采用这样的设计结构实现了这种设计模式</li>
<li>正向代理，代理的是客户端,正向代理将代理服务器看成了一个客户端，让这个代理服务器做客户端的功能(为客户端收发请求)</li>
<li>反向代理，代理的是服务器(就像是服务器一样,为服务器收发请求)</li>
<li>正向代理是代理服务器和用户在一个LAN(Local Area Network)内</li>
<li>反向代理是代理服务器和目标服务器在一个LAN内</li>
</ol>
</blockquote>
<h4 id="4-2-为什么要用反向代理"><a href="#4-2-为什么要用反向代理" class="headerlink" title="4.2 为什么要用反向代理"></a>4.2 为什么要用反向代理</h4><blockquote>
<p>1、可以起到保护网站安全的作用，因为任何来自Internet的请求都必须先经过代理服务器</p>
<p>2、通过缓存静态资源，加速Web请求</p>
<p>3、实现负载均衡</p>
</blockquote>
<h4 id="4-3-反向代理的实现"><a href="#4-3-反向代理的实现" class="headerlink" title="4.3 反向代理的实现"></a>4.3 反向代理的实现</h4><blockquote>
<p>配置反向代理非常简单，只需要在location块中设置代理服务器地址即可</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /ceshi &#123;</span><br><span class="line">    # 代理服务器地址</span><br><span class="line">    proxy_pass   http://localhost:8080/PictureSharing/index; # 网站的首页地址（也可以是某一个请求的地址）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="五、Nginx负载均衡"><a href="#五、Nginx负载均衡" class="headerlink" title="五、Nginx负载均衡"></a>五、Nginx负载均衡</h3><ul>
<li>负载均衡的基本配置</li>
</ul>
<blockquote>
<p>负载均衡实现:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#设置负载均衡upstream块</span><br><span class="line">upstream mysvr1 &#123;   </span><br><span class="line">	server 127.0.0.1:8080;</span><br><span class="line">	server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果负载均衡不生效，切换浏览器,使用其它浏览器(谷歌浏览器负载均衡可能会失效)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置路由规则</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置路由规则(当设置负载均衡时,不能在location后设置规则和拦截路径)</span><br><span class="line">location / &#123;</span><br><span class="line">    proxy_pass  http://mysvr1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>负载均衡设置以上两个块即可,但是要注意upstream块在http块内部和server块同级.<br>upstream : 设置upstream块<br>mysvr1 ：给upstream起一个名字，在location块里面设置负载均衡服务器群组的upstream块的名字,然后重载nginx配置</p>
</blockquote>
<ul>
<li>负载均衡的策略</li>
</ul>
<blockquote>
<p>热备: 如果有2台服务器，当一台服务器发生事故时，才启用第二台服务器给提供服务。服务器处理请求的顺序：AAAAAA突然A挂啦，BBBBBBB</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream mysvr1 &#123;   </span><br><span class="line">	server 127.0.0.1:8080;</span><br><span class="line">	server 127.0.0.1:8081 backup;  #热备 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>轮询 : nginx默认就是轮询其权重都默认为1，服务器处理请求的顺序：ABABABABAB</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream mysvr1 &#123;   </span><br><span class="line">	server 127.0.0.1:8080;</span><br><span class="line">	server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>加权轮询: 根据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置，则默认为1。下面服务器的请求顺序为：ABBABBABBABBABB</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream mysvr1 &#123;   </span><br><span class="line">	server 127.0.0.1:8080 weight=1;</span><br><span class="line">	server 127.0.0.1:8081 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ip_hash: nginx会让相同的客户端ip请求相同的服务器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream mysvr1 &#123;   </span><br><span class="line">	server 127.0.0.1:8080;</span><br><span class="line">	server 127.0.0.1:8081;</span><br><span class="line">	ip_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于负载均衡的几个常见其他参数(了解)</p>
<ul>
<li>down : 表示当前的server暂时不参与负载均衡</li>
<li>max_fails : 允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误</li>
<li>fail_timeout : 在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream mysvr &#123; </span><br><span class="line">    server 127.0.0.1:8080 weight=2 max_fails=2 fail_timeout=2;</span><br><span class="line">    server 127.0.0.1:8081 weight=1 max_fails=2 fail_timeout=1;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="六、Nginx静态资源访问"><a href="#六、Nginx静态资源访问" class="headerlink" title="六、Nginx静态资源访问"></a>六、Nginx静态资源访问</h3><blockquote>
<p>使用Nginx搭建图片服务器</p>
</blockquote>
<h4 id="6-1-配置图片服务器的步骤"><a href="#6-1-配置图片服务器的步骤" class="headerlink" title="6.1 配置图片服务器的步骤"></a>6.1 配置图片服务器的步骤</h4><blockquote>
<p>配置图片服务器只需要修改nginx.cnf配置文件中的location块即可</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#图片服务器的地址设置</span><br><span class="line">location /file/ &#123;</span><br><span class="line">	alias  D:/360Downloads/wpcache/srvsetwp/; # 指定根目录</span><br><span class="line">	autoindex on;                             # 文件可以以列表的形式展示出来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>访问: <a href="http://localhost/file">http://localhost/file</a> 就会展示出来图片列表</p>
</blockquote>
<h4 id="6-2-root-和-alias-区别"><a href="#6-2-root-和-alias-区别" class="headerlink" title="6.2 root 和 alias 区别"></a>6.2 root 和 <strong>alias</strong> 区别</h4><blockquote>
<p>nginx指定文件路径有两种方式root和alias，这两者的用法区别在于对url的处理方法不同</p>
</blockquote>
<ul>
<li>方式一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /file/ &#123;</span><br><span class="line">	alias  D:/360Downloads/wpcache/srvsetwp/; # 指定根目录</span><br><span class="line">	autoindex on;                             # 文件可以以列表的形式展示出来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>访问地址 <a href="http://127.0.0.1/file/">http://127.0.0.1/file/</a> 时，ningx会自动去D:/360Downloads/wpcache/srvsetwp/目录找文件</p>
</blockquote>
<ul>
<li>方式二</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /file/ &#123;</span><br><span class="line">	root  D:/360Downloads/wpcache/srvsetwp/; # 指定根目录</span><br><span class="line">	autoindex on;                             # 文件可以以列表的形式展示出来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>访问地址 <a href="http://127.0.0.1/file/">http://127.0.0.1/file/</a> 时，ningx会自动去D:/360Downloads/wpcache/srvsetwp/file 目录找文件</p>
</blockquote>
<blockquote>
<p>注意事项:</p>
<ol>
<li>alias是一个目录别名的定义，root则是最上层目录的定义，file拼接到整个root指定的目录结尾</li>
<li>alias后面必须要用”/“结束，否则会找不到文件的,而root则可有可无</li>
</ol>
</blockquote>
<hr>
<h3 id="七、Nginx动静分离"><a href="#七、Nginx动静分离" class="headerlink" title="七、Nginx动静分离"></a>七、Nginx动静分离</h3><h4 id="7-1-动静分离介绍"><a href="#7-1-动静分离介绍" class="headerlink" title="7.1 动静分离介绍"></a>7.1 动静分离介绍</h4><blockquote>
<p>为了提高网站的响应速度，减轻程序服务器（tomcat，jetty等）的负载，对于静态资源比如html、css、js、图片等文件，我们可以在反向代理服务器中进行缓存，这样浏览器在请求一个静态资源时，代理服务器就可以直接处理，而不用将请求转发给后端服务器</p>
</blockquote>
<p><a href="https://note.youdao.com/yws/api/personal/file/390C38FD102045438B398739A790587B?method=download&shareKey=c96fc3f161d972cb336ecc6cf6c5df62"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/390C38FD102045438B398739A790587B?method=download&shareKey=c96fc3f161d972cb336ecc6cf6c5df62" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<h4 id="7-2-动静分离实现"><a href="#7-2-动静分离实现" class="headerlink" title="7.2 动静分离实现"></a>7.2 动静分离实现</h4><ul>
<li>将前端页面都放在nginx中并配置</li>
</ul>
<blockquote>
<p>实现方式:</p>
<p>1、配置静态资源文件 自定义一个index.html文件做测试</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">        &lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;Nginx前后端分离测试&lt;/h1&gt;</span><br><span class="line">        &lt;button id=&quot;btn&quot;&gt;向后台发送请求&lt;/button&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            $(&quot;#btn&quot;).click(function()&#123;</span><br><span class="line">                //请求地址访问web服务器的地址</span><br><span class="line">                $.getJSON(&quot;http://localhost:8080/getList&quot;, function(json)&#123;</span><br><span class="line">                    console.log(json)</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2、将index.html页面放在硬盘任意位置，比如我放在了 D:\app\hs_admin，配置nginx，将index.html 设置为nginx的首页</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /abc &#123;</span><br><span class="line">	alias D:/app/hs_admin/;</span><br><span class="line">	index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3、启动nginx服务器,在浏览器中输入 <a href="http://localhost/abc/">http://localhost/abc/</a> 测试nginx服务器首页是否设置成功</p>
</blockquote>
<ul>
<li>使用SpringBoot构建一个web项目用于前后端分离项目测试</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//后台代码</span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    @GetMapping(value = &quot;/getList&quot;)</span><br><span class="line">    public Object getList()&#123;</span><br><span class="line">        List&lt;Map&lt;String,String&gt;&gt; listMap = new ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String,String&gt; map1 = new HashMap&lt;&gt;();</span><br><span class="line">        map1.put(&quot;userName&quot;,&quot;李雷&quot;);</span><br><span class="line">        map1.put(&quot;age&quot;,&quot;18&quot;);</span><br><span class="line">        Map&lt;String,String&gt; map2 = new HashMap&lt;&gt;();</span><br><span class="line">        map2.put(&quot;userName&quot;,&quot;韩梅梅&quot;);</span><br><span class="line">        map2.put(&quot;age&quot;,&quot;17&quot;);</span><br><span class="line">        listMap.add(map1);</span><br><span class="line">        listMap.add(map2);</span><br><span class="line">        return listMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<blockquote>
<p>当项目设计成前后端分离之后,那么我们前后端的数据交互需采用JavaScript进行AJAX请求,我这里采用的是jQuery进行测试</p>
<p>在nginx服务器中的index.html页面请求后台的web服务器中的资源会出现跨域调用的问题(No ‘Access-Control-Allow-Origin’ header is present on the requested resource)</p>
</blockquote>
<h4 id="7-3-跨域问题解决"><a href="#7-3-跨域问题解决" class="headerlink" title="7.3 跨域问题解决"></a>7.3 跨域问题解决</h4><ul>
<li>什么是跨域</li>
</ul>
<blockquote>
<p>浏览器的同源策略会导致跨域，跨域是指从一个域名的网页去请求另一个域名的资源。比如从<a href="http://www.baidu.com/">www.baidu.com</a> 页面去请求 <a href="http://www.google.com/">www.google.com</a> 的资源。跨域的严格一点的定义是：只要 协议(http/https)，域名，端口号有任何一个的不同，就被当作是跨域，浏览器因为同源策略不允许AJAX从当前域请求到另一域获取数据</p>
</blockquote>
<ul>
<li>解决方式(Spring框架,专注后台解决方案)</li>
</ul>
<blockquote>
<p>只要在请求的Java类(控制器类)上加@CrossOrigin注解即可</p>
<ul>
<li><p>@CrossOrigin注解是Spring在4.2版本新增的一个注解</p>
</li>
<li><p>@CrossOrigin注解可以修饰类也可以修饰方法</p>
</li>
<li><p>@CrossOrigin默认是可以接受其他域的所有请求</p>
</li>
<li><p>还可以针对某一个域进行设置,此注解里面有一个属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- origins : 可以设置指定的域名或方法  例如: origins = &quot;http://localhost&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>五大基本算法</title>
    <url>/2021/05/14/%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%20%20/</url>
    <content><![CDATA[<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>   在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p>
<pre><code>任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。
</code></pre>
<h2 id="二、基本思想及策略"><a href="#二、基本思想及策略" class="headerlink" title="二、基本思想及策略"></a>二、基本思想及策略</h2><p>   分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>   分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>   如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p>
<h2 id="三、分治法适用的情况"><a href="#三、分治法适用的情况" class="headerlink" title="三、分治法适用的情况"></a>三、分治法适用的情况</h2><pre><code>分治法所能解决的问题一般具有以下几个特征：

1) 该问题的规模缩小到一定的程度就可以容易地解决

2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。

3) 利用该问题分解出的子问题的解可以合并为该问题的解；

4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。
</code></pre>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p>
<p>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p>
<p>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p>
<h2 id="四、分治法的基本步骤"><a href="#四、分治法的基本步骤" class="headerlink" title="四、分治法的基本步骤"></a>四、分治法的基本步骤</h2><p>分治法在每一层递归上都有三个步骤：</p>
<pre><code>step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；

step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题

step3 合并：将各个子问题的解合并为原问题的解。
</code></pre>
<p>它的一般的算法设计模式如下：</p>
<pre><code>Divide-and-Conquer(P)

1. if |P|≤n0

2. then return(ADHOC(P))

3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk

4. for i←1 to k

5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi

6. T ← MERGE(y1,y2,...,yk) △ 合并子问题

7. return(T)

其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,...,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,...,Pk的相应的解y1,y2,...,yk合并为P的解。
</code></pre>
<h2 id="五、分治法的复杂性分析"><a href="#五、分治法的复杂性分析" class="headerlink" title="五、分治法的复杂性分析"></a>五、分治法的复杂性分析</h2><pre><code>一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：
</code></pre>
<p> T（n）= k T(n/m)+f(n)</p>
<pre><code>通过迭代法求得方程的解：

递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当                  mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。 
</code></pre>
<h2 id="六、可使用分治法求解的一些经典问题"><a href="#六、可使用分治法求解的一些经典问题" class="headerlink" title="六、可使用分治法求解的一些经典问题"></a>六、可使用分治法求解的一些经典问题</h2><p> （1）二分搜索<br>（2）大整数乘法<br> （3）Strassen矩阵乘法<br>（4）棋盘覆盖<br>（5）合并排序<br>（6）快速排序<br>（7）线性时间选择</p>
<p> （8）最接近点对问题<br>（9）循环赛日程表<br>（10）汉诺塔</p>
<h2 id="七、依据分治法设计程序时的思维过程"><a href="#七、依据分治法设计程序时的思维过程" class="headerlink" title="七、依据分治法设计程序时的思维过程"></a>七、依据分治法设计程序时的思维过程</h2><pre><code>实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。
</code></pre>
<p>1、一定是先找到最小问题规模时的求解方法<br>2、然后考虑随着问题规模增大时的求解方法<br>3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</p>
<h1 id="动态算法"><a href="#动态算法" class="headerlink" title="动态算法"></a>动态算法</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><pre><code>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。
</code></pre>
<h2 id="二、基本思想与策略"><a href="#二、基本思想与策略" class="headerlink" title="二、基本思想与策略"></a>二、基本思想与策略</h2><pre><code>基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。

与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。
</code></pre>
<h2 id="三、适用的情况"><a href="#三、适用的情况" class="headerlink" title="三、适用的情况"></a>三、适用的情况</h2><p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<pre><code>(1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。

(2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
</code></pre>
<p>   （3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
<h2 id="四、求解的基本步骤"><a href="#四、求解的基本步骤" class="headerlink" title="四、求解的基本步骤"></a>四、求解的基本步骤</h2><pre><code> 动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。

初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态

                  图1 动态规划决策过程示意图

(1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。

(2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。

(3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。

(4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。
</code></pre>
<p>实际应用中可以按以下几个简化的步骤进行设计：</p>
<pre><code>（1）分析最优解的性质，并刻画其结构特征。

（2）递归的定义最优解。

（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值

（4）根据计算最优值时得到的信息，构造问题的最优解
</code></pre>
<h2 id="五、算法实现的说明"><a href="#五、算法实现的说明" class="headerlink" title="五、算法实现的说明"></a>五、算法实现的说明</h2><pre><code>动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。

 使用动态规划求解问题，最重要的就是确定动态规划三要素：

（1）问题的阶段 （2）每个阶段的状态

（3）从前一个阶段转化到后一个阶段之间的递推关系。

 递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。

确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。

      f(n,m)=max&#123;f(n-1,m), f(n-1,m-w[n])+P(n,m)&#125;
</code></pre>
<h2 id="六、动态规划算法基本框架"><a href="#六、动态规划算法基本框架" class="headerlink" title="六、动态规划算法基本框架"></a>六、动态规划算法基本框架</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=m; j=j+<span class="number">1</span>) <span class="comment">// 第一个阶段</span></span><br><span class="line">xn[j] = 初始值;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i=n-<span class="number">1</span>; i&gt;=<span class="number">1</span>; i=i-<span class="number">1</span>)<span class="comment">// 其他n-1个阶段</span></span><br><span class="line">  <span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)<span class="comment">//f(i)与i有关的表达式</span></span><br><span class="line">xi[j]=j=max（或min）&#123;g(xi-<span class="number">1</span>[j1:j2]), ......, g(xi[jk:jk+<span class="number">1</span>])&#125;;</span><br><span class="line">t = g(x1[j1:j2]); <span class="comment">// 由子问题的最优解求解整个问题的最优解的方案</span></span><br><span class="line">print(x1[j1]);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=n-<span class="number">1</span>; i=i+<span class="number">1</span>）</span><br><span class="line">&#123;  </span><br><span class="line">    t = t-xi-<span class="number">1</span>[ji];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&gt;=f(i); j=j+<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span>(t=xi[ji])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">经典例题</span> <span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="attr">一.基本思想</span></span><br><span class="line"><span class="attr">与分治法类似，其基本思想也是将待求解问题分解成若干子问题，先求解子问题，然后从这些子问题的解中得到原问题的解。</span></span><br><span class="line"><span class="attr">与分治法不同的是，分治法会使得有些子问题被重复计算多次。而动态规划的做法是将已解决子问题的答案保存下来，在需要子问题答案的时候便可直接获得，而不需要重复计算，节约效率。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">二.经典题目</span></span><br><span class="line"><span class="meta">1.</span> <span class="string">递推求解问题</span></span><br><span class="line"><span class="meta">1.1斐波那契数列问题</span> <span class="string">（n阶楼梯上楼问题）</span></span><br><span class="line"><span class="meta">状态转移方程：dp[n]</span> = <span class="string">dp[n-1] + dp[n-2]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2.</span> <span class="string">最大连续子序列和</span></span><br><span class="line"><span class="meta">2.1（一维)</span> <span class="string">最大序列和问题</span></span><br><span class="line"><span class="meta">设置一个数组dp[</span> <span class="string">]，令dp[i]表示以A[i]作为末尾的连续序列的最大和。</span></span><br><span class="line"><span class="meta">状态转移方程：dp[i]</span> = <span class="string">max&#123; A[i], dp[i-1] + A[i] &#125;</span></span><br><span class="line"><span class="attr">解释：由于dp[i]是以A[i]作为结尾的连续序列最大和，因此只有两种情况：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">最大和的连续序列只有一个元素，即A[i]本身。也就是dp[i]</span> = <span class="string">A[i]。</span></span><br><span class="line"><span class="meta">该最长子序列有多个元素，那么此时的dp[i]</span> = <span class="string">dp[i-1] + A[i]。</span></span><br><span class="line"><span class="attr">所以取最大值即可。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">2.2（二维)</span> <span class="string">最大子矩阵问题</span></span><br><span class="line"><span class="meta">对于二维情况，假设原二维矩阵的最大子矩阵所在的行为</span> <span class="string">i 到 j 。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">当</span> <span class="string">i = j 时，则最大子矩阵为第 i 行的最大连续子序列和。（转化为一维）</span></span><br><span class="line"><span class="meta">当</span> <span class="string">i != j 时，现在我们已经知道最大子矩阵的行，把从第 i 行到第 j 行的所有元素相加，得到一个只有一行的一维数组，则该一维数组的连续最大和就是最大子矩阵。（同样转化为一维）</span></span><br><span class="line"><span class="attr">3.最长递增子序列</span></span><br><span class="line"><span class="meta">3.1</span> <span class="string">拦截导弹</span></span><br><span class="line"><span class="meta">同样设置一个数组dp[</span> <span class="string">] ，表以A[i]作为末尾的最长递增子序列的长度。</span></span><br><span class="line"><span class="meta">状态转移方程：dp[i]</span> = <span class="string">max&#123; 1, dp[j] + 1 &#125;。(当 j &lt; i &amp;&amp; A[j] &lt; A[i] 时)</span></span><br><span class="line"><span class="attr">解释：由于dp[i]是以A[i]作为末尾的最长递增子序列的长度，因此只有两种情况：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">A[i]之前的元素都比A[i]大，即dp[i]</span> = <span class="string">1。</span></span><br><span class="line"><span class="meta">存在一些A[</span> <span class="string">j ]比A[ i ]小，只需找出最大的dp[j] + 1存入dp[i]。</span></span><br><span class="line"><span class="attr">则最长递增子序列的长度即为dp中的最大值。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.2</span> <span class="string">最大上升子序列和问题</span></span><br><span class="line"><span class="attr">该题目中，用dp表示的便不是长度了，而是以A[i]作为末尾的最大上升子序列和。其原理与求最长递增子序列的原理完全一致。</span></span><br><span class="line"><span class="meta">状态转移方程：dp[i]</span> = <span class="string">max&#123; A[i], dp[j] + A[i] &#125;。（当 j &lt; i &amp;&amp; A[j] &lt; A[i&#125;时）。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">3.3</span> <span class="string">合唱队形</span></span><br><span class="line"><span class="attr">这道题有点难，有时间再琢磨。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">4.最长公共子序列</span></span><br><span class="line"><span class="meta">4.1</span> <span class="string">Coincidence（找两个字符串的最长公共子串）</span></span><br><span class="line"><span class="meta">这里要设置一个二维的数组</span> <span class="string">dp[][]。dp[i][j]表示以S1[i]作为末尾和以S2[j]作为末尾的最长公共子序列的长度。因此通过设置这样一个数组，最长公共子序列的长度便是数组dp[n][m]的值。</span></span><br><span class="line"><span class="attr">仔细说来，S1[i]和S2[j]的关系可分为两种情况：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">S1[i]</span> =<span class="string">= S2[j]，即两个字符相同。此时必定存在一个最长公共子串以这个字符结尾。其他部分等价于S1中前 i - 1 个字符和S2中前 j - 1 个字符的最长公共子串。则这个子串的长度比dp[i-1][j-1]多1。即dp[i][j] = dp[i-1][j-1] + 1。</span></span><br><span class="line"><span class="meta">S1[i]</span> <span class="string">!= S2[j]，那此时最长公共子串为S1中的前 i - 1 个字符和S2中的前 j - 1 个字符中最长公共子串长度的较大者。即dp[i][j] = max&#123; dp[i-1][j], dp[i][j-1] &#125;。</span></span><br><span class="line"><span class="attr">即</span></span><br><span class="line"></span><br><span class="line"><span class="meta">状态转移方程</span>	<span class="string">条件</span></span><br><span class="line"><span class="meta">dp[</span> <span class="string">i ] [ j ] = dp[ i - 1 ] [ j - 1 ] + 1	S1[ i ] == S2[ j ]</span></span><br><span class="line"><span class="meta">dp[</span> <span class="string">i ] [ j ] = max&#123; dp[ i - 1 ] [ j ], dp[ i ] [ j - 1 ] &#125;	S1[ i ] != S2[ j ]</span></span><br><span class="line"><span class="meta">但还要注意一下边界情况，当有一个字符串为空时，公共串长度必为0。即dp[i][0]</span> =<span class="string">= dp[0][j] == 0。</span></span><br><span class="line"><span class="attr">相对于暴力枚举的O(2m+n)复杂度降至了O(mn)。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">5.背包问题</span></span><br><span class="line"><span class="meta">5.1</span> <span class="string">0-1背包 （点菜问题）</span></span><br><span class="line"><span class="attr">该问题描述的是，有n件物品，每件物品的重量为w[i]，其价值为v[i]，现在有个容量为m的背包，如何选择物品使得装入背包物品的价值最大。</span></span><br><span class="line"><span class="attr">如果暴力枚举所有排列组合，再从中找到最大一组，则时间复杂度为O(2n)，下面以O(mn)的时间复杂度解决此问题。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">首先设置一个二维数组dp[][]，令dp[i][j]表示前</span> <span class="string">i 个物品装进容量为 j 的背包能获得的最大价值。通过设置这么一个二维数组，数组dp[n][m]值就是0-1背包问题的解。</span></span><br><span class="line"><span class="attr">只考虑第i件物品时，可将情况分为是否放入第i件物品两种：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">对于容量为j的背包，如果不放入第</span> <span class="string">i 件物品，那么这个问题就转化为将前 i - 1 个物品放入容量为j的背包的问题，即dp[i][j] = dp[i-1][j]。</span></span><br><span class="line"><span class="meta">对于容量为j的背包，如果放入第</span> <span class="string">i 件物品，那么当前背包的容量就变成了 j - w[i] ，并得到了这个物品的价值 v[i]。那么这个问题就转化成了将当前 i - 1 个物品放入容量为 j - w[i] 的背包的问题，即dp[i][j] = dp[i-1][ j-w[i] ] + v[i]。</span></span><br><span class="line"><span class="meta">综上，可得状态转移方程：dp[i][j]</span> = <span class="string">max&#123; dp[i-1][j], dp[i-1][ j-w[i] ] + v[i] &#125;。</span></span><br><span class="line"><span class="attr">转移时要注意j-w[i]的值是否为非负值，若为负则代表当前容量无法放入第i件物品，不能进行转移。</span></span><br><span class="line"><span class="attr">再考虑一下边界情况：</span></span><br><span class="line"></span><br><span class="line"><span class="attr">如果装0件物品，不论背包容量多大，能够获得的价值都必为0。</span></span><br><span class="line"><span class="attr">如果背包的容量为0，那么无法装入任何物品，能够获得的价值也必定为0。</span></span><br><span class="line"><span class="meta">所以，dp[i][0]</span> = <span class="string">dp[0][j] = 0。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">6.其他问题</span></span><br><span class="line"><span class="meta">6.1</span> <span class="string">放苹果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">设dp(m,n)</span> <span class="string">为m个苹果，n个盘子的放法数目，则先对n作讨论，</span></span><br><span class="line"><span class="meta">当n&gt;m：必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即if(n&gt;m)</span> <span class="string">dp(m,n) = dp(m,m)</span></span><br><span class="line"><span class="meta">当n</span> <span class="string">&lt;= m：不同的放法可以分成两类：</span></span><br><span class="line"><span class="meta">有至少一个盘子空着，即相当于dp(m,n)</span> = <span class="string">dp(m,n-1)。</span></span><br><span class="line"><span class="meta">所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即dp(m,n)</span> = <span class="string">dp(m-n,n)。</span></span><br><span class="line"><span class="meta">而总的放苹果的放法数目等于两者的和，即</span> <span class="string">dp(m,n) = dp(m,n-1) + dp(m-n,n)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">int</span> <span class="string">dp(int m, int n)</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">if(n</span>=<span class="string">=1) return 1;</span></span><br><span class="line">    <span class="attr">else</span> <span class="string">if(m==0) return 1;</span></span><br><span class="line">    <span class="attr">else</span> <span class="string">if(n&gt;m) return dp(m, m);</span></span><br><span class="line">    <span class="attr">else</span> <span class="string">return dp(m, n-1)+dp(m-n, n);</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">int</span> <span class="string">main()</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="attr">int</span> <span class="string">m, n;</span></span><br><span class="line">    <span class="meta">while(scanf(&quot;%d</span> <span class="string">%d&quot;, &amp;m, &amp;n)!=EOF)</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">        <span class="meta">printf(&quot;%d\n&quot;,</span> <span class="string">dp(m, n));</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">return</span> <span class="string">0;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>







<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a>一、基本概念：</h2><pre><code>  所谓贪心算法是指，在对问题求解时，总是做出在 当前看来是最好的选择 。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的 局部最优解 。
 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。
所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。
</code></pre>
<h2 id="二、贪心算法的基本思路："><a href="#二、贪心算法的基本思路：" class="headerlink" title="二、贪心算法的基本思路："></a>二、贪心算法的基本思路：</h2><p>​    1.建立数学模型来描述问题。<br>​    2.把求解的问题分成若干个子问题。<br>​    3.对每一子问题求解，得到子问题的局部最优解。<br>​    4.把子问题的解局部最优解合成原来解问题的一个解。</p>
<h2 id="三、贪心算法适用的问题"><a href="#三、贪心算法适用的问题" class="headerlink" title="三、贪心算法适用的问题"></a>三、贪心算法适用的问题</h2><p>​      贪心策略适用的前提是：局部最优策略能导致产生全局最优解。<br>​    实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p>
<h2 id="四、贪心算法的实现框架"><a href="#四、贪心算法的实现框架" class="headerlink" title="四、贪心算法的实现框架"></a>四、贪心算法的实现框架</h2><p>​    从问题的某一初始解出发；<br>​    while （能朝给定总目标前进一步）<br>​    {<br>​          利用可行的决策，求出可行解的一个解元素；<br>​    }<br>​    由所有解元素组合成问题的一个可行解；</p>
<h2 id="五、贪心策略的选择"><a href="#五、贪心策略的选择" class="headerlink" title="五、贪心策略的选择"></a>五、贪心策略的选择</h2><p>​     因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p>
<h2 id="六、例题分析"><a href="#六、例题分析" class="headerlink" title="六、例题分析"></a>六、例题分析</h2><p>​    下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。<br>​    [背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。<br>​    要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。<br>​    物品 A B C D E F G<br>​    重量 35 30 60 50 40 10 25<br>​    价值 10 40 30 50 35 40 30<br>​    分析：<br>​    目标函数： ∑pi最大<br>​    约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)<br>​    （1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？<br>​    （2）每次挑选所占重量最小的物品装入是否能得到最优解？<br>​    （3）每次选取单位重量价值最大的物品，成为解本题的策略。<br>​    值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。<br>​    贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。<br>​    可惜的是，它需要证明后才能真正运用到题目的算法中。<br>​    一般来说， 贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。<br>​    对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：<br>​    （1）贪心策略：选取价值最大者。反例：<br>​    W=30<br>​    物品：A B C<br>​    重量：28 12 12<br>​    价值：30 20 20<br>​    根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。<br>​    （2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。<br>​    （3）贪心策略：选取单位重量价值最大的物品。反例：<br>​    W=30<br>​    物品：A B C<br>​    重量：28 20 10<br>​    价值：28 20 10<br>​    根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。</p>
<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><h1 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h1><p>​      回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>   回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<pre><code> 许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。
</code></pre>
<h1 id="2、基本思想"><a href="#2、基本思想" class="headerlink" title="2、基本思想"></a>2、基本思想</h1><p>   在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>
<pre><code>   若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。

   而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。
</code></pre>
<h1 id="3、用回溯法解题的一般步骤："><a href="#3、用回溯法解题的一般步骤：" class="headerlink" title="3、用回溯法解题的一般步骤："></a>3、用回溯法解题的一般步骤：</h1><p>​    （1）针对所给问题，确定问题的解空间：</p>
<pre><code>        首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。

（2）确定结点的扩展搜索规则

（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。
</code></pre>
<h1 id="4、算法框架"><a href="#4、算法框架" class="headerlink" title="4、算法框架"></a>4、算法框架</h1><p>​     （1）问题框架</p>
<pre><code>  设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。

 （2）非递归回溯框架
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[n],i;</span><br><span class="line">初始化数组a[];</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i&gt;<span class="number">0</span>(有路可走)   and  (未达到目标))  <span class="comment">// 还未回溯到头</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; n)                                              <span class="comment">// 搜索到叶结点</span></span><br><span class="line">    &#123;   </span><br><span class="line">          搜索到一个解，输出；</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">else</span>                                                   <span class="comment">// 处理第i个元素</span></span><br><span class="line">   &#123; </span><br><span class="line">         a[i]第一个可能的值；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）递归的算法框架     回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line">    <span class="keyword">try</span>(<span class="keyword">int</span> i)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;n)</span><br><span class="line">           输出结果;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">for</span>(j = 下界; j &lt;= 上界; j=j+<span class="number">1</span>)  <span class="comment">// 枚举i所有可能的路径</span></span><br><span class="line">           &#123;</span><br><span class="line">              <span class="keyword">if</span>(fun(j))                 <span class="comment">// 满足限界函数和约束条件</span></span><br><span class="line">                &#123;</span><br><span class="line">                   a[i] = j;</span><br><span class="line">                 ...                         <span class="comment">// 其他操作</span></span><br><span class="line">                   <span class="keyword">try</span>(i+<span class="number">1</span>);</span><br><span class="line">                回溯前的清理工作（如a[i]置空值等）;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h1><h2 id="一、基本描述"><a href="#一、基本描述" class="headerlink" title="一、基本描述"></a>一、基本描述</h2><p>​    类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</p>
<p>   （1）分支搜索算法</p>
<p>​    所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。</p>
<pre><code> 选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。
</code></pre>
<p>   1）FIFO搜索</p>
<p>   2）LIFO搜索</p>
<p>   3）优先队列式搜索</p>
<p>（2）分支限界搜索算法 </p>
<h2 id="二、分支限界法的一般过程"><a href="#二、分支限界法的一般过程" class="headerlink" title="二、分支限界法的一般过程"></a>二、分支限界法的一般过程</h2><p>​    由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。</p>
<pre><code>分支限界法的搜索策略是：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。

分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。
</code></pre>
<h2 id="三、回溯法和分支限界法的一些区别"><a href="#三、回溯法和分支限界法的一些区别" class="headerlink" title="三、回溯法和分支限界法的一些区别"></a>三、回溯法和分支限界法的一些区别</h2><p>​    有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？</p>
<p>回溯法和分支限界法的一些区别：</p>
<p>   方法对解空间树的搜索方式       存储结点的常用数据结构      结点存储特性常用应用</p>
<p>  回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解</p>
<p>  分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解</p>
]]></content>
  </entry>
  <entry>
    <title>SQL详解</title>
    <url>/2021/08/07/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5/</url>
    <content><![CDATA[<p>sql安装</p>
<p>类   —  表</p>
<p>属性  —  列</p>
<p>对象  —  行</p>
<p><a href="https://blog.csdn.net/hebbely/article/details/52370179">https://blog.csdn.net/hebbely/article/details/52370179</a> 参考 安装步骤</p>
<p>安装图形化的界面  nav.zip</p>
<p>右键 管理员身份运行 上面选中的exe程序  一顿下一步</p>
<p><a href="https://blog.csdn.net/liaosiqian/article/details/78307293">https://blog.csdn.net/liaosiqian/article/details/78307293</a> </p>
<p>navicat 破解过程</p>
<p>第5部</p>
<p>第6部 断网 </p>
<p>第七步</p>
<p>简介</p>
<p>  数据库  database   装数据的  </p>
<p>关系型数据库   记录的都是 数据和数据之间的关系  </p>
<p>员工 </p>
<p>编号  姓名  性别  工龄   部门 </p>
<p> 1    张三疯  男  3    1</p>
<p>部门 </p>
<p>编号  名称   地址   状态   负责人 </p>
<p> 1    研发部  北京  正常   李四</p>
<pre><code>   redis          mysql
</code></pre>
<p>  应用    缓存 数据     关系型数据库 做持久层     </p>
<p> DBA </p>
<p>常用数据库</p>
<p>mysql  select * from student   limit 0,2  免费开源  适用于中小企业 集群 mycat  </p>
<p>oracle  select * from student   rownum  收费贼啦贵  贼拉稳定 适合大型企业 贼脆弱                    政府  教学机构  </p>
<p>sqlserver  select * from  student  top    收费  微软原生态 中小型的企业  .net  </p>
<p> 遵循  sql 语言  sql 语句   </p>
<p>java  开源  生态环境   git  gitee 码云 </p>
<pre><code>    盖楼 

 一层楼 框架    
</code></pre>
<p> 挖掘机    水泥   电线</p>
<p>小结 </p>
<p>啥是关系型数据库 sql  硬盘  mysql   oracle   sqlserver  </p>
<p> 员工表  部门表</p>
<p>非关系型数据库 not only sql  内存型  key  value  map </p>
<p>创建数据库</p>
<pre><code>-- create database java2102;

-- use java2102; -- 切换数据库



-- 创建表 员工表 编号  姓名   年龄

/*  

create table yuangong(

 yid  int  ,

 yname varchar(20),

 age  int

)

*/
</code></pre>
<p>增删改查</p>
<pre><code>-- 增加数据 

-- insert  into  表(列,列) values(值,值);

insert into yuangong(yid,yname,age ) values(1,&#39;张三疯&#39;,25);

insert into yuangong  values(2,&#39;李四&#39;,25); 插入所有列时 可以省略 前面的列名

-- 查询

-- select  列名,列名 from  表  where  条件 

select yid,yname from  yuangong 

select yid,Yname,age fRom  Yuangong where age&gt;23

select * fRom  Yuangong where age&gt;23;

-- 删除

-- delete from 表 where  条件

delete from yuangong where age&gt;23

-- 修改 

-- update  表  set 列=值,列=值 where 条件 

update yuangong set age=age+1 where age&gt;23
-- 修改表的 结构
alter table 表 add column 列 列类型
alter table  yuangong add column sex varchar(20);


************************  !=     &lt;&gt;   都是不等于
</code></pre>
<p>例：</p>
<pre><code>-- 查询年龄不是23岁的员工

select * from  yuangong  where age!=23;

select * from yuangong where age &lt;&gt;23;

-- 修改表的 结构

 alter table  yuangong add column sex varchar(20);

 update yuangong set sex=&#39;男&#39;  

-- 查询 年龄大于23并且是男的

 select * from  yuangong where age&gt;23  and sex=&#39;男&#39;

-- 查询 年龄大于23或者是男的

 select * from  yuangong where age&gt;23  or sex=&#39;男&#39; 
</code></pre>
<p>2-23</p>
<p>SQL分类：</p>
<p>DDL—数据定义语言(CREATE，ALTER，DROP，DECLARE)  表结构定义的 建库 建表  改表<br>DML—数据操纵语言(SELECT，DELETE，UPDATE，INSERT)  数据操作 增删改查<br>DCL—数据控制语言(GRANT，REVOKE，COMMIT，ROLLBACK)  事务控制 事务操作</p>
<p>DDL 结构型的操作 </p>
<pre><code> create database 库名;

 use  database;  切换库

 show databases;展示 所有库 

 show tables;展示所有的表 

 drop database 库名;  删库 

 drop table  表名;  删除表结构

 desc  表名;查看表结构

alter table 表  add column  列名  列类型; 
</code></pre>
<p>DML  数据操作</p>
<pre><code> 增  insert  into  表 (列,列) values( 值,值  )

 -- default  使用上面的 auto_increment 增长的值进行填充 

 删  delete  from  表 where  条件

 

 改  update  表 set 列=值,列=值where 条件

 

 查  select 列 from 表 where 条件

 

条件: \&gt; ,&lt; ,&gt;=, &lt;=, != , &lt;&gt;

 and 并且    or  或者 满足一个条件即可  
 排序  通常加在 sql 语句的最后面  order by  列  asc  desc

 asc 升序 默认的   desc  降序

 select * from  yuangong  order by  age asc



 -- 查询 年龄  在 20 ~30岁的 员工信息 

select * from  yuangong where age&gt;=20 and age&lt;=30;

select * from  yuangong where age between  20  and  30;

-- 查询 年龄 22 23 28 42  这几个年龄的人 

select * from yuangong  where age=22 or age=23 or age=28

select * from yuangong where age in (22,23,28,42)

-- 查询 性别是男的 

select * from yuangong where sex in (&#39;男&#39;);

select * from yuangong where sex=&#39;男&#39;;

insert into yuangong(yname) values(&#39;小强&#39;);

 -- 查询 没有性别信息的员工

select * from  yuangong where sex =&#39;&#39;;

select * from  yuangong where sex is null;

select * from  yuangong where sex is not null and sex!=&#39;&#39;;

-- 模糊查询  like 

-- 查询 员工姓名中带小字 的 % 任意个任意字符  _ 1个 任意字符

select * from  yuangong where yname like &#39;小%&#39;

select * from  yuangong where yname like &#39;_张&#39;

-- 查询 员工姓名中不包含小字的员工信息 

select * from  yuangong where yname not like &#39;%小%&#39;

-- distinct 去掉行级的重复

select DISTINCT yname from yuangong ;

select distinct  * from yuangong ;

select distinct  yname,age from yuangong ;

 
</code></pre>
<p>多条件的排序</p>
<pre><code>子查询  subquery

-- 和小黑同龄的员工信息 

 select * from  yuangong where age=22

 select age from yuangong where yname=&#39;小黑&#39;

  --》

select * from  yuangong where age=(

select age from yuangong where yname=&#39;小黑&#39;)

 

分组查询  group  by  列  having 

 select sex from yuangong group by sex

 

select sex from  yuangong  where  sex is not NULL and sex !=&#39;&#39;

 group by sex  

 select sex from  yuangong  

 group by sex  having  sex is not NULL and sex !=&#39;&#39;

 

分组需要注意的点  select 后面 能出现的 列 只能是在 group by 后面的列

或者是加了聚合函数的列

 

聚合函数( 多行函数 ) 特点 会将 多行的内容合并为一行

方法 sum() count() max() min() avg() 

select * from  yuangong where sex=&#39;男&#39;;

select sum(age) from yuangong where sex=&#39;男&#39; ;

select  sex,sum(age) from  yuangong group by sex;

select   count(1)  from  yuangong; 

select  count(*)  from  yuangong where sex=&#39;男&#39; ;

select  max(age),min(age),avg(age) from yuangong ; 

-- 查询 男生中的最高年龄和最低年龄 及平均年龄

select  max(age),min(age),avg(age) from 

yuangong where sex=&#39;男&#39;

-- 查询 女生的人数 

select count(*) from yuangong  where sex=&#39;女&#39;
</code></pre>
<p>总结 </p>
<p>  聚合函数会将  多行的内容进行汇总 变成一行数据 </p>
<p>  通常可以和group by  having搭配使用</p>
<p>  聚合函数不能直接出现在 where 的后面 </p>
<pre><code>-- 查询 年龄最大的员工信息 

  select * from yuangong where age=(select max(age) from  yuangong)
</code></pre>
<p>单行函数 </p>
<pre><code>1.concat(列,列) 拼接多个列

select  CONCAT(&#39;abcd&#39;,&#39;bbb&#39;,22)

as 起别名 可以省略 

2.substr

       -- 123456

select  SUBSTR(&#39;abcdef&#39;,3)-- cdef

          -- 起始 长度

select  SUBSTR(&#39;abcdef&#39;,3,3) -- cde 

      -- 12345678

select INSTR(&#39;abcdecfc&#39;,&#39;c&#39;)-- 3 从左往右找 出现的位置 如果没有返回0

        

\3. trim 去掉两端指定的字符

select TRIM( &#39;  a a a a  &#39;)-- a a a a

select TRIM(BOTH &#39; &#39; FROM &#39;  a a a a  &#39;)-- a a a a

select TRIM(TRAILING &#39; &#39; FROM &#39;  a a a a  &#39;);-- &#39;  a a a a&#39;

select TRIM(LEADING &#39; &#39; FROM &#39;  a a a a  &#39;);-- &#39;a a a a  &#39;

select TRIM(LEADING &#39;a&#39; FROM &#39;aaaa b b aaaa&#39;)--  b b aaaa
</code></pre>
<p>例题</p>
<pre><code>　其次，大家来看一些不错的sql语句
　　1、说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)
　　法一：select * into b from a where 1&lt;&gt;1
　　法二：select top 0 * into b from a
　　2、说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)
insert into b(a, b, c) select d,e,f from b;
　　3、说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)
insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件
　　例子：…from b in ’&quot;&amp;Server.MapPath(&quot;.&quot;)&amp;&quot;\data.mdb&quot; &amp;&quot;’ where…
　　4、说明：子查询(表名1：a 表名2：b)
select a,b,c from a where a IN (select d from b ) 或者: select a,b,c from a where a IN (1,2,3)
　　5、说明：显示文章、提交人和最后回复时间
select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b
6、说明：外连接查询(表名1：a 表名2：b)
select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c
　　7、说明：在线视图查询(表名1：a )
select * from (SELECT a,b,c FROM a) T where t.a &gt; 1;
　　8、说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括
select * from table1 where time between time1 and time2
select a,b,c, from table1 where a not between 数值1 and 数值2
　　9、说明：in 的使用方法
select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)
　　10、说明：两张关联表，删除主表中已经在副表中没有的信息
delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )
　　11、说明：四表联查问题：
select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where …
　　12、说明：日程安排提前五分钟提醒
SQL: select * from 日程安排 where datediff(’minute’,f开始时间,getdate())&gt;5
　　13、说明：一条sql 语句搞定数据库分页
select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段
　　14、说明：前10条记录
select top 10 * form table1 where 范围
　　15、说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)
select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b)
　　16、说明：包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表
(select a from tableA ) except (select a from tableB) except (select a from tableC)
　　17、说明：随机取出10条数据
select top 10 * from tablename order by newid()
　　18、说明：随机选择记录
select newid()
　　19、说明：删除重复记录
Delete from tablename where id not in (select max(id) from tablename group by col1,col2,…)
　　20、说明：列出数据库里所有的表名
select name from sysobjects where type=’U’
21、说明：列出表里的所有的
select name from syscolumns where id=object_id(’TableName’)
</code></pre>
<p>2-24</p>
<p>关键词</p>
<pre><code>数值：
select  ROUND(2.64,1);  -- 2.6 四舍五入  保留1位小数

select TRUNCATE(2.64,0); -- 2 截断 不四舍五入  保留0位小数


日期

select  now(); 获取当前的系统时间

select YEAR(now()); 年

select MONTH(now()); 月

select day(now()); 日

select hour(now()); 时

select minute(now()); 分

select  second(now()); 秒

select  concat(year(now()),&#39;-&#39;,month(now())) 把 年月连接

select  TO_DAYS(NOW())  转成 天数

select  ADDDATE(now(),INTERVAL 1 HOUR); 给 当前的日期  增加 1小时

select  ADDDATE(now(),INTERVAL 1 year); 给 当前的日期  增加 1年            

select  ADDDATE(now(),INTERVAL -1 year); 给 当前的日期  减少 1年

select  STR_TO_DATE(&#39;2025-5-4&#39;,&#39;%Y-%m-%d&#39;) 字符串 转成日期类型

例：
insert into yuangong values(default,&#39;小红&#39;,22,&#39;女&#39;,now() )

insert into yuangong values(default,&#39;小红花&#39;,22,&#39;女&#39;,&#39;2019-5-4 15:06:01&#39; )
update  yuangong set hiredate=now() where yid=6
</code></pre>
<p>多表关联 </p>
<p>等值连接 </p>
<pre><code>-- 查询 研发部门的 员工信息  

 select * from  yuangong y, dept d

where y.bmid=d.deptno and d.dname=&#39;研发部&#39; 
</code></pre>
<p>左联   </p>
<pre><code>  以左面的表 为主要展示的表  展示出所有的数据

select * from  yuangong y left join dept d 

 on  y.bmid=d.deptno   
</code></pre>
<p>右联 </p>
<pre><code>以右面的表 为主要展示的表  展示出所有的数据

 select * from yuangong y  right join dept d

 on  y.bmid=d.deptno 
</code></pre>
<p>全连接 </p>
<pre><code>  兼顾左右

select * from  yuangong y left join dept d 

 on  y.bmid=d.deptno 

  UNION 

 select * from yuangong y  right join dept d

 on  y.bmid=d.deptno
</code></pre>
<p>2-25 </p>
<p>约束   constraint </p>
<p>  非空约束  not  null   限定列的值不能是null 的 </p>
<p>  唯一约束  unique    限定 列的值是唯一的可以是null  </p>
<p> 主键约束  primary  key  限定这个列的值不能是null 且不重复 </p>
<pre><code>          一张表中最多只能有一个主键  可以有联合主键  

          三范式 建议 
</code></pre>
<p>  外键约束  foreign key   主键  外键   </p>
<pre><code>          主表   从表  限定从表外键列的值只能是null 或者 

                 是主表 主键列的 值
</code></pre>
<p>  默认约束  default    限定 列的值如果不给就是 当前这个默认的值 </p>
<p>主键约束</p>
<pre><code>主键约束：
create table  xx(

 xid  primary key  auto_increment ,

 login  varchar(20)  not null,

 pwd  varchar(30)  default  &#39;zzzz&#39;

)
</code></pre>
<p>外键约束</p>
<pre><code> create table bumen1(

  bid int primary key  auto_increment,

  bmname varchar(20) 

) 

 create  table  yg(

  yid int primary key  auto_increment,

  yname varchar(20) not null ,

  bmid  int ,

  FOREIGN KEY (bmid)  REFERENCES bumen1 (bid) )

  
  ALTER TABLE `yg` ADD CONSTRAINT 

 `fk_xxxxxxxx` FOREIGN KEY (`bmid`) 
 
  REFERENCES `bumen1` (`bid`);
</code></pre>
<p>2-26 </p>
<p>事务  transaction  </p>
<p>数据操作 最小单元  要么全成功  要么全失败 </p>
<p> start   transaction; 开启事务  </p>
<p>  多条增删改的语句 </p>
<p> commit; 生效</p>
<p> rollback; 取消</p>
<pre><code>转账  

start   transaction;

 A  减钱   update  account  set money=money-100 where aid=1

 

 B  加钱   update  account  set money=money+100 where aid=2 

rollback; 取消

commit;生效
</code></pre>
<p>事务 四个特性  ACID</p>
<p> 原子性(A)  不可分割的 最小单元</p>
<p> 一致性(C)  要么全成功 要么全失败</p>
<p> 隔离性(I)  不同事务不干扰</p>
<p> 持久性(D)  如果提交则永久的生效了 </p>
<p>隔离机制 </p>
<p>脏读   </p>
<p>B事务读取到了A 事务未提交的数据  与真实数据不一致 </p>
<pre><code>  q=3
</code></pre>
<p>  A  start  transaction      </p>
<pre><code>              B  strat  transaction

  q=6            

                select  q --&gt; 6
</code></pre>
<p>  A   rollback;</p>
<pre><code>  q-&gt;3            q-&gt; 6
</code></pre>
<p>不可重复读 </p>
<p> 在一个事务中多次的读取  两次读取到的内容不一致 </p>
<pre><code> q=3
</code></pre>
<p>  A  start transaction      </p>
<pre><code> select  q--&gt; 3                    

              B  start  transaction 

                 update  q --&gt; 6

              B  commit

 select  q--&gt;6            

                
</code></pre>
<p>  A   commit;</p>
<pre><code>             q-&gt; 6
</code></pre>
<p>解决方案 增加行锁</p>
<p>幻读 </p>
<p>  在一个事务中两次查询的 记录条数不一样  </p>
<pre><code> count(q)=3
</code></pre>
<p>  A  start transaction      </p>
<pre><code> select  count(q)--&gt; 3                    

              B  start  transaction 

                 insert  q --&gt; 1

              B  commit

 select  count(q)--&gt;4            

                
</code></pre>
<p>  A   commit;</p>
<pre><code>             count(q)-&gt; 4
</code></pre>
<p>加表锁 锁住整个表 </p>
<p>mysql 的数据引擎  </p>
<p>innoDB  常见常用  支持事务   比较占用 内存和 磁盘空间  </p>
<p>memory 内存   不支持事务 </p>
<p>myisam  不支持事务  插入性能比较快  占用的内存和磁盘空间极少  数据缓存 </p>
<p>优化 快速的查询 </p>
<p>1.创建索引 index   相当于目录   唯一索引  全文索引  btree 树 默认  hash 哈希表</p>
<p>ALTER TABLE account ADD INDEX qw (aid) ;</p>
<p>2.使用 between  and  替换 大于 小于</p>
<p>3.where 后面条件  从后往前 去加载的  </p>
<p>  where  a.aid=b.aid  and x.tno=c.tno  and  x.name=’xxx’ and  a.aid=1</p>
<pre><code>         x  c
</code></pre>
<p>分页 查询  </p>
<p>limit  关键字 </p>
<p>limit  起始位置  ,条数 </p>
<p>limit  0,2 取前两条</p>
<p>每页10条   当前页是1 </p>
<p> pagesize    cp  </p>
<p>11条记录 </p>
<p>第一页的10条记录 </p>
<pre><code>(当前页-1)*每页条数 , 每页的条数 
</code></pre>
<p> limit  0    ,10 </p>
<p>第二页的10条记录</p>
<p> limit  10,10</p>
<p>powerdesigner  </p>
<p>数据库的设计软件 </p>
<p>获取 数据库的结构 </p>
<p>支持 er模型图 转换成 数据表  </p>
<p>描述 表之间的依赖关系 </p>
]]></content>
  </entry>
  <entry>
    <title>复习资料</title>
    <url>/2021/08/07/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4/</url>
    <content><![CDATA[<h2 id="1、作用域-public-private-protected-以及不写时的区别"><a href="#1、作用域-public-private-protected-以及不写时的区别" class="headerlink" title="1、作用域 public,private,protected,以及不写时的区别"></a>1、作用域 public,private,protected,以及不写时的区别</h2><p>答：区别如下：<br>作用域 当前类 同一 package 子孙类 其他 package<br>public √ √ √ √<br>protected √ √ √ ×<br>friendly √ √ × ×<br>private √ × × ×<br>不写时默认为 friendly</p>
<h2 id="2、Anonymous-Inner-Class-匿名内部类-是否可以-extends-继承-其它类，是否可以-implements-实现-interface-接口"><a href="#2、Anonymous-Inner-Class-匿名内部类-是否可以-extends-继承-其它类，是否可以-implements-实现-interface-接口" class="headerlink" title="2、Anonymous Inner Class (匿名内部类) 是否可以 extends(继承)其它类，是否可以 implements(实现)interface(接口)"></a>2、Anonymous Inner Class (匿名内部类) 是否可以 extends(继承)其它类，是否可以 implements(实现)interface(接口)</h2><p>答：匿名的内部类是没有名字的内部类。不能 extends(继承) 其它类，但一个内部类可以作为一个接口，由另一个内部类实现</p>
<h2 id="3、Static-Nested-Class-和-Inner-Class-的不同"><a href="#3、Static-Nested-Class-和-Inner-Class-的不同" class="headerlink" title="3、Static Nested Class 和 Inner Class 的不同"></a>3、Static Nested Class 和 Inner Class 的不同</h2><p>答：Nested Class （一般是 C++的说法），Inner Class (一般是 JAVA 的说法)。Java 内部类与C++嵌套类最大的不同就在于是否有指向外部的引用上。注： 静态内部类（Inner Class）意味着 1 创建一个 static 内部类的对象，不需要一个外部类对象，2 不能从一个 static 内部类的一个对象访问一个外部类对象！</p>
<h2 id="4、-amp-和-amp-amp-的区别"><a href="#4、-amp-和-amp-amp-的区别" class="headerlink" title="4、&amp;和&amp;&amp;的区别"></a>4、&amp;和&amp;&amp;的区别</h2><p>答：&amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与（and）</p>
<h2 id="5、Collection-和-Collections-的区别"><a href="#5、Collection-和-Collections-的区别" class="headerlink" title="5、Collection 和 Collections 的区别"></a>5、Collection 和 Collections 的区别</h2><p>答：Collection 是集合类的上级接口，继承与他的接口主要有 Set 和 List.Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作</p>
<h2 id="6、什么时候用-assert"><a href="#6、什么时候用-assert" class="headerlink" title="6、什么时候用 assert"></a>6、什么时候用 assert</h2><p>答：assertion(断言)在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。<br>在实现中，assertion 就是在程序中的一条语句，它对一个 boolean 表达式进行检查，一个正确程序必须保证这个 boolean 表达式的值为 true；如果该值为 false，说明程序已经处于不正确的状态下，系统将给出警告或退出。一般来说，assertion 用于保证程序最基本、关键的正确性。assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion 检查通常是关闭的</p>
<h2 id="7、String-s-new-String-“xyz”-创建了几个-String-Object"><a href="#7、String-s-new-String-“xyz”-创建了几个-String-Object" class="headerlink" title="7、String s = new String(“xyz”);创建了几个 String Object"></a>7、String s = new String(“xyz”);创建了几个 String Object</h2><p>答：两个，一个字符对象，一个字符对象引用对象</p>
<h2 id="8、Math-round-11-5-等於多少-Math-round-11-5-等於多少"><a href="#8、Math-round-11-5-等於多少-Math-round-11-5-等於多少" class="headerlink" title="8、Math.round(11.5)等於多少? Math.round(-11.5)等於多少"></a>8、Math.round(11.5)等於多少? Math.round(-11.5)等於多少</h2><p>**答: **Math.round(11.5)==12;Math.round(-11.5)==-11;round 方法返回与参数最接近的长整数，参数加 1/2 后求其 floor</p>
<h2 id="9、short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#9、short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="9、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错"></a>9、short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错</h2><p>答：short s1 = 1; s1 = s1 + 1; （s1+1 运算结果是 int 型，需要强制转换类型）short s1 = 1; s1 += 1;（可以正确编译）</p>
<h2 id="10、Java-有没有-goto"><a href="#10、Java-有没有-goto" class="headerlink" title="10、Java 有没有 goto"></a>10、Java 有没有 goto</h2><p>答：java 中的保留字，现在没有在 java 中使用</p>
<h2 id="11、数组有没有-length-这个方法-String-有没有-length-这个方法"><a href="#11、数组有没有-length-这个方法-String-有没有-length-这个方法" class="headerlink" title="11、数组有没有 length()这个方法? String 有没有 length()这个方法"></a>11、数组有没有 length()这个方法? String 有没有 length()这个方法</h2><p>答：数组没有 length()这个方法，有 length 的属性。String 有有 length()这个方法</p>
<h2 id="12、Overload-和-Override-的区别。Overloaded-的方法是否可以改变返回值的类型"><a href="#12、Overload-和-Override-的区别。Overloaded-的方法是否可以改变返回值的类型" class="headerlink" title="12、Overload 和 Override 的区别。Overloaded 的方法是否可以改变返回值的类型"></a>12、Overload 和 Override 的区别。Overloaded 的方法是否可以改变返回值的类型</h2><p>答：方法的重写 Overriding 和重载 Overloading 是 Java 多态性的不同表现。重写 Overriding是父类与子类之间多态性的一种表现，重载 Overloading 是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded 的方法是可以改变返回值的类型</p>
<h2 id="13、Set-里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是-equals-它们有何区别"><a href="#13、Set-里的元素是不能重复的，那么用什么方法来区分重复与否呢-是用-还是-equals-它们有何区别" class="headerlink" title="13、Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是 equals()? 它们有何区别"></a>13、Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是 equals()? 它们有何区别</h2><p>答：Set 里的元素是不能重复的，那么用 iterator()方法来区分重复与否。equals()是判读两个Set 是否相等equals()和==方法决定引用值是否指向同一对象 equals()在类中被覆盖，为的是当两个分离的对象的内容和类型相配的话，返回真值</p>
<h2 id="14、给我一个你最常见到的-runtime-exception"><a href="#14、给我一个你最常见到的-runtime-exception" class="headerlink" title="14、给我一个你最常见到的 runtime exception"></a>14、给我一个你最常见到的 runtime exception</h2><p>答：常见的运行时异常有如下这些</p>
<p> ArithmeticException, ArrayStoreException, BufferOverflowException, BufferUnderflowException, </p>
<p>CannotRedoException, CannotUndoException, ClassCastException, CMMException,<br>ConcurrentModificationException, DOMException, EmptyStackException,</p>
<p> IllegalArgumentException, IllegalMonitorStateException, IllegalPathStateException</p>
<p>, IllegalStateException, ImagingOpException, IndexOutOfBoundsException, </p>
<p>MissingResourceException, NegativeArraySizeException, NoSuchElementException,</p>
<p> NullPointerException, ProfileDataException, ProviderException, </p>
<p>RasterFormatException, SecurityException, SystemException,</p>
<p> UndeclaredThrowableException, UnmodifiableSetException, UnsupportedOperationException</p>
<h2 id="15、error-和-exception-有什么区别"><a href="#15、error-和-exception-有什么区别" class="headerlink" title="15、error 和 exception 有什么区别"></a>15、error 和 exception 有什么区别</h2><p>答：error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况</p>
<h2 id="16、List-Set-Map-是否继承自-Collection-接口"><a href="#16、List-Set-Map-是否继承自-Collection-接口" class="headerlink" title="16、List, Set, Map 是否继承自 Collection 接口"></a>16、List, Set, Map 是否继承自 Collection 接口</h2><p>**答： **List，Set 是，Map 不是</p>
<h2 id="17、abstract-class-和-interface-有什么区别"><a href="#17、abstract-class-和-interface-有什么区别" class="headerlink" title="17、abstract class 和 interface 有什么区别"></a>17、abstract class 和 interface 有什么区别</h2><p>答：声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建 abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。</p>
<p>不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义 static final 成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p>
<h2 id="18、abstract-的-method-是否可同时是-static-是否可同时是-native，是否可同时是-synchronized"><a href="#18、abstract-的-method-是否可同时是-static-是否可同时是-native，是否可同时是-synchronized" class="headerlink" title="18、abstract 的 method 是否可同时是 static,是否可同时是 native，是否可同时是 synchronized"></a>18、abstract 的 method 是否可同时是 static,是否可同时是 native，是否可同时是 synchronized</h2><p>答：都不能</p>
<h2 id="19、接口是否可继承接口-抽象类是否可实现-implements-接口-抽象类是否可继承实体类-concrete-class"><a href="#19、接口是否可继承接口-抽象类是否可实现-implements-接口-抽象类是否可继承实体类-concrete-class" class="headerlink" title="19、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)"></a>19、接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete class)</h2><p>答：接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数</p>
<h2 id="20、构造器-Constructor-是否可被-override"><a href="#20、构造器-Constructor-是否可被-override" class="headerlink" title="20、构造器 Constructor 是否可被 override"></a>20、构造器 Constructor 是否可被 override</h2><p>答：构造器 Constructor 不能被继承，因此不能重写 Overriding，但可以被重载 Overloading</p>
<h2 id="21、是否可以继承-String-类"><a href="#21、是否可以继承-String-类" class="headerlink" title="21、是否可以继承 String 类"></a>21、是否可以继承 String 类</h2><p>答：String 类是 final 类故不可以继承</p>
<h2 id="22、try-里有一个-return-语句，那么紧跟在这个-try-后的-finally-里的-code-会不会被执行，什么时候被执行，在-return-前还是后"><a href="#22、try-里有一个-return-语句，那么紧跟在这个-try-后的-finally-里的-code-会不会被执行，什么时候被执行，在-return-前还是后" class="headerlink" title="22、try {}里有一个 return 语句，那么紧跟在这个 try 后的 finally {}里的 code 会不会被执行，什么时候被执行，在 return 前还是后"></a>22、try {}里有一个 return 语句，那么紧跟在这个 try 后的 finally {}里的 code 会不会被执行，什么时候被执行，在 return 前还是后</h2><p>答：会执行，在 return 前执行</p>
<h2 id="23、用最有效率的方法算出-2-乘以-8-等於几"><a href="#23、用最有效率的方法算出-2-乘以-8-等於几" class="headerlink" title="23、用最有效率的方法算出 2 乘以 8 等於几"></a>23、用最有效率的方法算出 2 乘以 8 等於几</h2><p>答：2 &lt;&lt; 3</p>
<h2 id="24、两个对象值相同-x-equals-y-true-，但却可有不同的-hash-code，这句话对不对"><a href="#24、两个对象值相同-x-equals-y-true-，但却可有不同的-hash-code，这句话对不对" class="headerlink" title="24、两个对象值相同(x.equals(y) == true)，但却可有不同的 hash code，这句话对不对"></a>24、两个对象值相同(x.equals(y) == true)，但却可有不同的 hash code，这句话对不对</h2><p>答：不对，有相同的 hash code</p>
<h2 id="25、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#25、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="25、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"></a>25、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h2><p>答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的</p>
<h2 id="26、swtich-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#26、swtich-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="26、swtich 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上"></a>26、swtich 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h2><p>答：witch（expr1）中，expr1 是一个整数表达式。因此传递给 switch 和 case 语句的参数应该是 int、 short、 char 或者 byte。long,string 都不能作用于 swtich</p>
<h2 id="27、ArrayList-和-Vector-的区别-HashMap-和-Hashtable-的区别"><a href="#27、ArrayList-和-Vector-的区别-HashMap-和-Hashtable-的区别" class="headerlink" title="27、ArrayList 和 Vector 的区别,HashMap 和 Hashtable 的区别"></a>27、ArrayList 和 Vector 的区别,HashMap 和 Hashtable 的区别</h2><p>答：就 ArrayList 与 Vector 主要从二方面来说.一.同步性:Vector 是线程安全的，也就是说是同步的，而 ArrayList 是线程序不安全的，不是同步的<br>二.数据增长:当需要增长时,Vector 默认增长为原来一培，而 ArrayList 却是原来的一半就 HashMap 与 HashTable 主要从三方面来说。<br>一.历史原因:Hashtable 是基于陈旧的 Dictionary 类的，HashMap 是 Java 1.2 引进的 Map接口的一个实现<br>二.同步性:Hashtable 是线程安全的，也就是说是同步的，而 HashMap 是线程序不安全的，不是同步的<br>三.值：只有 HashMap 可以让你将空值作为一个表的条目的 key 或 value</p>
<h2 id="28、char-型变量中能不能存贮一个中文汉字-为什么"><a href="#28、char-型变量中能不能存贮一个中文汉字-为什么" class="headerlink" title="28、char 型变量中能不能存贮一个中文汉字?为什么?"></a>28、char 型变量中能不能存贮一个中文汉字?为什么?</h2><p>答：是能够定义成为一个中文的，因为 java 中以 unicode 编码，一个 char 占 16 个字节，所以放一个中文是没问题的</p>
<h2 id="29、GC-是什么-为什么要有-GC"><a href="#29、GC-是什么-为什么要有-GC" class="headerlink" title="29、GC 是什么? 为什么要有 GC"></a>29、GC 是什么? 为什么要有 GC</h2><p>答：GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p>
<h2 id="30、float-型-float-f-3-4-是否正确"><a href="#30、float-型-float-f-3-4-是否正确" class="headerlink" title="30、float 型 float f=3.4 是否正确?"></a>30、float 型 float f=3.4 是否正确?</h2><p>答:不正确。精度不准确,应该用强制类型转换，如下所示：float f=(float)3.4</p>
<h2 id="31、介绍-JAVA-中的-Collection-FrameWork-包括如何写自己的数据结构"><a href="#31、介绍-JAVA-中的-Collection-FrameWork-包括如何写自己的数据结构" class="headerlink" title="31、介绍 JAVA 中的 Collection FrameWork(包括如何写自己的数据结构)?"></a>31、介绍 JAVA 中的 Collection FrameWork(包括如何写自己的数据结构)?</h2><p>答：Collection FrameWork 如下：<br>Collection ├List │├LinkedList │├ArrayList │└Vector │ └Stack └Set Map ├Hashtable ├HashMap └WeakHashMap<br>Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素（Elements）<br>Map 提供 key 到 value 的映射</p>
<h2 id="32、抽象类与接口？"><a href="#32、抽象类与接口？" class="headerlink" title="32、抽象类与接口？"></a>32、抽象类与接口？</h2><p>答：抽象类与接口都用于抽象，但是抽象类(JAVA 中)可以有自己的部分实现，而接口则完全是一个标识(同时有多重继承的功能)。<br>JAVA 类实现序例化的方法是实现 java.io.Serializable 接口<br>Collection 框架中实现比较要实现 Comparable 接口和 Comparator 接口</p>
<h2 id="33、STRING-与-STRINGBUFFER-的区别。"><a href="#33、STRING-与-STRINGBUFFER-的区别。" class="headerlink" title="33、STRING 与 STRINGBUFFER 的区别。"></a>33、STRING 与 STRINGBUFFER 的区别。</h2><p>答：STRING 的长度是不可变的，STRINGBUFFER 的长度是可变的。如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用 StringBuffer，如果最后需要 String，那么使用 StringBuffer 的 toString()方法</p>
<h2 id="34、谈谈-final-finally-finalize-的区别"><a href="#34、谈谈-final-finally-finalize-的区别" class="headerlink" title="34、谈谈 final, finally, finalize 的区别"></a>34、谈谈 final, finally, finalize 的区别</h2><p>答：final—修饰符（关键字）如果一个类被声明为 final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract 的，又被声明为 final 的。将变量或方法声明为 final，可以保证它们在使用中不被改变。被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为 final 的方法也同样只能使用，不能重载finally—再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）finalize—方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的</p>
<h2 id="35、面向对象的特征有哪些方面"><a href="#35、面向对象的特征有哪些方面" class="headerlink" title="35、面向对象的特征有哪些方面"></a>35、面向对象的特征有哪些方面</h2><p>答：主要有以下四方面：<br>1.抽象：<br>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。<br>2.继承：<br>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。<br>对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。<br>3.封装：<br>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。<br>4. 多态性：<br>多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p>
<h2 id="36、String-是最基本的数据类型吗"><a href="#36、String-是最基本的数据类型吗" class="headerlink" title="36、String 是最基本的数据类型吗"></a>36、String 是最基本的数据类型吗</h2><p>答：基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。<br>java.lang.String 类是 final 类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用 StringBuffer 类</p>
<h2 id="37、int-和-Integer-有什么区别"><a href="#37、int-和-Integer-有什么区别" class="headerlink" title="37、int 和 Integer 有什么区别"></a>37、int 和 Integer 有什么区别</h2><p>答：Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int 是 java 的原始数据类型，Integer 是 java 为 int 提供的封装类。Java 为每个原始类型提供了封装类。<br>原始类型封装类,booleanBoolean,charCharacter,byteByte,shortShort,intInteger,longLong,floatFloat,doubleDouble引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关</p>
<h2 id="38、运行时异常与一般异常有何异同"><a href="#38、运行时异常与一般异常有何异同" class="headerlink" title="38、运行时异常与一般异常有何异同"></a>38、运行时异常与一般异常有何异同</h2><p>答：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java 编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p>
<h2 id="39、说出-ArrayList-Vector-LinkedList-的存储性能和特性"><a href="#39、说出-ArrayList-Vector-LinkedList-的存储性能和特性" class="headerlink" title="39、说出 ArrayList,Vector, LinkedList 的存储性能和特性"></a>39、说出 ArrayList,Vector, LinkedList 的存储性能和特性</h2><p>答：ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全），通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</p>
<h2 id="40、HashMap-和-Hashtable-的区别"><a href="#40、HashMap-和-Hashtable-的区别" class="headerlink" title="40、HashMap 和 Hashtable 的区别"></a>40、HashMap 和 Hashtable 的区别</h2><p>答：HashMap 是 Hashtable 的轻量级实现（非线程安全的实现），他们都完成了 Map 接口，主要区别在于 HashMap 允许空（null）键值（key）,由于非线程安全，效率上可能高于 Hashtable。<br>HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。<br>HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsvalue 和 containsKey。因为 contains 方法容易让人引起误解。<br>Hashtable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。<br>最大的不同是，Hashtable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要自己为它的方法实现同步，而 HashMap 就必须为之提供外同步。<br>Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。</p>
<h2 id="41、heap-和-stack-有什么区别"><a href="#41、heap-和-stack-有什么区别" class="headerlink" title="41、heap 和 stack 有什么区别"></a>41、heap 和 stack 有什么区别</h2><p>答：栈是一种线形集合，其添加和删除元素的操作应在同一段完成。栈按照后进先出的方式进行处理。堆是栈的一个组成元素</p>
<h2 id="42、Java-的接口和-C-的虚类的相同和不同处"><a href="#42、Java-的接口和-C-的虚类的相同和不同处" class="headerlink" title="42、Java 的接口和 C++的虚类的相同和不同处"></a>42、Java 的接口和 C++的虚类的相同和不同处</h2><p>答：由于 Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是 public static,所有方法默认情况下是 public.一个类可以实现多个接口。</p>
<h2 id="43、Java-中的异常处理机制的简单原理和应用"><a href="#43、Java-中的异常处理机制的简单原理和应用" class="headerlink" title="43、Java 中的异常处理机制的简单原理和应用"></a>43、Java 中的异常处理机制的简单原理和应用</h2><p>答：当 JAVA 程序违反了 JAVA 的语义规则时，JAVA 虚拟机就会将发生的错误表示为一个异常。<br>违反语义规则包括 2 种情况。一种是 JAVA 类库内置的语义检查。例如数组下标越界,会引发 IndexOutOfBoundsException;访问 null 的对象时会引发 NullPointerException。另一种情况就是 JAVA 允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用 throw 关键字引发异常。所有的异常都是 java.lang.Thowable 的子类。</p>
<h2 id="43、垃圾回收的优点和原理。并考虑-2-种回收机制"><a href="#43、垃圾回收的优点和原理。并考虑-2-种回收机制" class="headerlink" title="43、垃圾回收的优点和原理。并考虑 2 种回收机制"></a>43、垃圾回收的优点和原理。并考虑 2 种回收机制</h2><p>答：Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++程序员最头疼的内存管理的问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java 中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</p>
<h2 id="44、你所知道的集合类都有哪些？主要方法？"><a href="#44、你所知道的集合类都有哪些？主要方法？" class="headerlink" title="44、你所知道的集合类都有哪些？主要方法？"></a>44、你所知道的集合类都有哪些？主要方法？</h2><p>答：最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。<br>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其中每个键映射到一个值。</p>
<h2 id="45、描述一下-JVM-加载-class-文件的原理机制"><a href="#45、描述一下-JVM-加载-class-文件的原理机制" class="headerlink" title="45、描述一下 JVM 加载 class 文件的原理机制?"></a>45、描述一下 JVM 加载 class 文件的原理机制?</h2><p>答：JVM 中类的装载是由 ClassLoader 和它的子类来实现的,Java ClassLoader 是一个重要的Java 运行时系统组件。它负责在运行时查找和装入类文件的类。</p>
<h2 id="46、排序都有哪几种方法？请列举"><a href="#46、排序都有哪几种方法？请列举" class="headerlink" title="46、排序都有哪几种方法？请列举"></a>46、排序都有哪几种方法？请列举</h2><p>**答： **排序的方法有：插入排序（直接插入排序、希尔排序），交换排序（冒泡排序、快速排序），选择排序（直接选择排序、堆排序），归并排序，分配排序（箱排序、基数排序）快速排序的伪代码。<br>/ /使用快速排序方法对 a[ 0 :n- 1 ]排序<br>从 a[ 0 :n- 1 ]中选择一个元素作为 m i d d l e，该元素为支点<br>把余下的元素分割为两段 left 和 r i g h t，使得 l e f t 中的元素都小于等于支点，而 right 中的元素都大于等于支点<br>递归地使用快速排序方法对 left 进行排序递归地使用快速排序方法对 right 进行排序所得结果为 l e f t + m i d d l e + r i g h t</p>
<h2 id="47、JAVA-语言如何进行异常处理，关键字：throws-throw-try-catch-finally-分别代表什么意义？在-try-块中可以抛出异常吗？"><a href="#47、JAVA-语言如何进行异常处理，关键字：throws-throw-try-catch-finally-分别代表什么意义？在-try-块中可以抛出异常吗？" class="headerlink" title="47、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally 分别代表什么意义？在 try 块中可以抛出异常吗？"></a>47、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally 分别代表什么意义？在 try 块中可以抛出异常吗？</h2><p>答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。<br>用 try 来指定一块预防所有”异常”的程序。紧跟在 try 程序后面，应包含一个 catch 子句来指定你想要捕捉的”异常”的类型。<br>throw 语句用来明确地抛出一个”异常”。<br>throws 用来标明一个成员函数可能抛出的各种”异常”。<br>Finally 为确保一段代码不管发生什么”异常”都被执行一段代码。<br>可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try 语句保护其他代码。每当遇到一个 try 语句，”异常”的框架就放到堆栈上面，直到所有的 try 语句都完成。<br>如果下一级的 try 语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的 try 语句。</p>
<h2 id="48、一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"><a href="#48、一个”-java”源文件中是否可以包括多个类（不是内部类）？有什么限制？" class="headerlink" title="48、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？"></a>48、一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？</h2><p>答：可以。必须只有一个类名与文件名相同。</p>
<h2 id="49、java-中有几种类型的流？JDK-为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"><a href="#49、java-中有几种类型的流？JDK-为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？" class="headerlink" title="49、java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"></a>49、java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？</h2><p>答：字节流，字符流。字节流继承于 InputStream OutputStream，字符流继承于 InputStreamReader OutputStreamWriter。在 <a href="http://java.io/">http://java.io</a> 包中还有许多其他的流，主要是为了提高性能和使用方便。</p>
<h2 id="50、java-中会存在内存泄漏吗，请简单描述。"><a href="#50、java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="50、java 中会存在内存泄漏吗，请简单描述。"></a>50、java 中会存在内存泄漏吗，请简单描述。</h2><p>答：会。自己实现堆载的数据结构时有可能会出现内存泄露，可参看 effective java。</p>
<h2 id="51、java-中实现多态的机制是什么？"><a href="#51、java-中实现多态的机制是什么？" class="headerlink" title="51、java 中实现多态的机制是什么？"></a>51、java 中实现多态的机制是什么？</h2><p>答：方法的重写 Overriding 和重载 Overloading 是 Java 多态性的不同表现。重写 Overriding是父类与子类之间多态性的一种表现，重载 Overloading 是一个类中多态性的一种表现。</p>
<h2 id="52、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收"><a href="#52、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收" class="headerlink" title="52、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收"></a>52、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收</h2><p>答：对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。<br>通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当 GC 确定一些对象为”不可达”时，GC 就有责任回收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证GC 一定会执行。</p>
<h2 id="53、静态变量和实例变量的区别？"><a href="#53、静态变量和实例变量的区别？" class="headerlink" title="53、静态变量和实例变量的区别？"></a>53、静态变量和实例变量的区别？</h2><p>答：static i = 10; //常量 class A a; a.i =10;//可变</p>
<h2 id="54、什么是-java-序列化，如何实现-java-序列化？"><a href="#54、什么是-java-序列化，如何实现-java-序列化？" class="headerlink" title="54、什么是 java 序列化，如何实现 java 序列化？"></a>54、什么是 java 序列化，如何实现 java 序列化？</h2><p>答：序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。<br>序列化的实现：将需要被序列化的类实现 Serializable 接口，该接口没有需要实现的方法，implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象，接着，使用 ObjectOutputStream 对象的 writeObject(Object obj)方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则用输入流。</p>
<h2 id="55、是否可以从一个-static-方法内部发出对非-static-方法的调用？"><a href="#55、是否可以从一个-static-方法内部发出对非-static-方法的调用？" class="headerlink" title="55、是否可以从一个 static 方法内部发出对非 static 方法的调用？"></a>55、是否可以从一个 static 方法内部发出对非 static 方法的调用？</h2><p>答：不可以,如果其中包含对象的 method()；不能保证对象初始化。</p>
<h2 id="56、写-clone-方法时，通常都有一行代码，是什么？"><a href="#56、写-clone-方法时，通常都有一行代码，是什么？" class="headerlink" title="56、写 clone()方法时，通常都有一行代码，是什么？"></a>56、写 clone()方法时，通常都有一行代码，是什么？</h2><p>答：Clone 有缺省行为，super.clone();他负责产生正确大小的空间，并逐位复制。</p>
<h2 id="57、在-JAVA-中，如何跳出当前的多重嵌套循环？"><a href="#57、在-JAVA-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="57、在 JAVA 中，如何跳出当前的多重嵌套循环？"></a>57、在 JAVA 中，如何跳出当前的多重嵌套循环？</h2><p>答：用 break; return 方法。</p>
<h2 id="58、List、Map、Set-三个接口，存取元素时，各有什么特点？"><a href="#58、List、Map、Set-三个接口，存取元素时，各有什么特点？" class="headerlink" title="58、List、Map、Set 三个接口，存取元素时，各有什么特点？"></a>58、List、Map、Set 三个接口，存取元素时，各有什么特点？</h2><p>答：List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保<br>存 key-value 值，value 可多值。</p>
<h2 id="59、说出一些常用的类，包，接口，请各举-5-个"><a href="#59、说出一些常用的类，包，接口，请各举-5-个" class="headerlink" title="59、说出一些常用的类，包，接口，请各举 5 个"></a>59、说出一些常用的类，包，接口，请各举 5 个</h2><p>答：常用的类：BufferedReader BufferedWriter FileReader FileWirter String Integer<br>常用的包：java.lang java.awt <a href="http://java.io/">http://java.io</a> java.util java.sql<br>常用的接口：Remote List Map Document NodeList</p>
]]></content>
  </entry>
  <entry>
    <title>EasyExcel</title>
    <url>/2021/08/08/EasyExcel%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="第一章-EasyExcel简介"><a href="#第一章-EasyExcel简介" class="headerlink" title="第一章 EasyExcel简介"></a>第一章 EasyExcel简介</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EasyExcel是一个基于Java的简单、省内存的读写Excel的开源项目。在尽可能节约内存的情况下支持读写百M的Excel</span><br><span class="line"></span><br><span class="line">github地址:https://github.com/alibaba/easyexcel</span><br></pre></td></tr></table></figure>

<ul>
<li>当前案例采用easyexcel版本 2.2.3</li>
</ul>
<hr>
<h2 id="第二章-EasyExcel使用"><a href="#第二章-EasyExcel使用" class="headerlink" title="第二章 EasyExcel使用"></a>第二章 EasyExcel使用</h2><h3 id="第1节-EasyExcel相关依赖"><a href="#第1节-EasyExcel相关依赖" class="headerlink" title="第1节 EasyExcel相关依赖"></a>第1节 EasyExcel相关依赖</h3><h4 id="1-1-如果添加maven依赖"><a href="#1-1-如果添加maven依赖" class="headerlink" title="1.1 如果添加maven依赖"></a>1.1 如果添加maven依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;easyexcel&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-如果添加jar包"><a href="#1-2-如果添加jar包" class="headerlink" title="1.2 如果添加jar包"></a>1.2 如果添加jar包</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm-4.2.jar</span><br><span class="line">cglib-3.1.jar</span><br><span class="line">commons-codec-1.10.jar</span><br><span class="line">commons-collections4-4.1.jar</span><br><span class="line">curvesapi-1.04.jar</span><br><span class="line">easyexcel-2.2.3.jar</span><br><span class="line">ehcache-3.4.0.jar</span><br><span class="line">poi-3.17.jar</span><br><span class="line">poi-ooxml-3.17.jar</span><br><span class="line">poi-ooxml-schemas-3.17.jar</span><br><span class="line">slf4j-api-1.7.26.jar</span><br><span class="line">stax-api-1.0.1.jar</span><br><span class="line">xmlbeans-2.6.0.jar</span><br></pre></td></tr></table></figure>

<h3 id="第2节-写Excel"><a href="#第2节-写Excel" class="headerlink" title="第2节 写Excel"></a>第2节 写Excel</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建User类,用于构建向Excel表格中写数据的类型;</span><br><span class="line"> * @ExcelProperty:这个注解是EasyExcel提供,用于生成Excel表格头</span><br><span class="line"> * @Author 夜泊 </span><br><span class="line"> * @BLOG   https://hd1611756908.github.io/</span><br><span class="line"> */</span><br><span class="line">public class User &#123;</span><br><span class="line">	@ExcelProperty(&quot;用户编号&quot;)</span><br><span class="line">	private Integer userId;</span><br><span class="line">	@ExcelProperty(&quot;姓名&quot;)</span><br><span class="line">	private String userName;</span><br><span class="line">	@ExcelProperty(&quot;性别&quot;)</span><br><span class="line">	private String gender;</span><br><span class="line">	@ExcelProperty(&quot;工资&quot;)</span><br><span class="line">	private Double salary;</span><br><span class="line">	@ExcelProperty(&quot;入职时间&quot;)</span><br><span class="line">	private Date hireDate;</span><br><span class="line">	</span><br><span class="line">	//setter/getter方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-最简单的写-方式一"><a href="#2-1-最简单的写-方式一" class="headerlink" title="2.1 最简单的写(方式一)"></a>2.1 最简单的写(方式一)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 向Excel文档中写数据(方式一)</span><br><span class="line"> * 最简单的写</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void writeExcel1() &#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//创建文件保存的位置,以及文件名</span><br><span class="line">	String fileName=&quot;user1.xlsx&quot;;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 构建要写入的数据</span><br><span class="line">	 * User类是一个自定义的特殊类,专门用来构建向Excel中写数据的类型类</span><br><span class="line">	 * @ExcelProperty是easyexcel提供的注解,用来定义表格的头部</span><br><span class="line">	 */</span><br><span class="line">	List&lt;User&gt; data = new ArrayList&lt;&gt;();</span><br><span class="line">	User user = new User(2001,&quot;李雷&quot;,&quot;男&quot;,1000.123,new Date());</span><br><span class="line">	data.add(user);</span><br><span class="line">	//将数据写到Excel的第一个sheet标签中,并且给sheet标签起名字</span><br><span class="line">	EasyExcel.write(fileName,User.class).sheet(&quot;用户信息&quot;).doWrite(data);</span><br><span class="line">	//文件流会自动关闭</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-最简单的写-方式二"><a href="#2-2-最简单的写-方式二" class="headerlink" title="2.2 最简单的写(方式二)"></a>2.2 最简单的写(方式二)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 向Excel文档中写数据(方式二)</span><br><span class="line"> * 最简单的写</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void writeExcel2() &#123;</span><br><span class="line">	//创建文件保存的位置,以及文件名</span><br><span class="line">	String fileName=&quot;user2.xlsx&quot;;</span><br><span class="line">	/**</span><br><span class="line">	 * 构建要写入的数据</span><br><span class="line">	 * User类是一个自定义的特殊类,专门用来构建向Excel中写数据的类型类</span><br><span class="line">	 * @ExcelProperty是easyexcel提供的注解,用来定义表格的头部</span><br><span class="line">	 */</span><br><span class="line">	List&lt;User&gt; data = new ArrayList&lt;&gt;();</span><br><span class="line">	User user = new User(2001,&quot;李雷&quot;,&quot;男&quot;,1000.123,new Date());</span><br><span class="line">	data.add(user);</span><br><span class="line">	//创建Excel写对象</span><br><span class="line">	ExcelWriter excelWriter = EasyExcel.write(fileName, User.class).build();</span><br><span class="line">	//创建sheet对象</span><br><span class="line">	WriteSheet writeSheet = EasyExcel.writerSheet(&quot;用户信息&quot;).build();</span><br><span class="line">	//将数据写到sheet标签中</span><br><span class="line">	excelWriter.write(data, writeSheet);</span><br><span class="line">	//关闭流,文件流手动关闭</span><br><span class="line">	excelWriter.finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-将类中某几个字段排除掉-不写入Excel中"><a href="#2-3-将类中某几个字段排除掉-不写入Excel中" class="headerlink" title="2.3 将类中某几个字段排除掉,不写入Excel中"></a>2.3 将类中某几个字段排除掉,不写入Excel中</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 向Excel文档中写数据</span><br><span class="line"> * 将User类中的某几个属性字段排除</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void writeExcel3() &#123;</span><br><span class="line">	//创建文件保存的位置,以及文件名</span><br><span class="line">	String fileName=&quot;user3.xlsx&quot;;</span><br><span class="line">	/**</span><br><span class="line">	 * 构建要写入的数据</span><br><span class="line">	 * User类是一个自定义的特殊类,专门用来构建向Excel中写数据的类型类</span><br><span class="line">	 * @ExcelProperty是easyexcel提供的注解,用来定义表格的头部</span><br><span class="line">	 */</span><br><span class="line">	List&lt;User&gt; data = new ArrayList&lt;&gt;();</span><br><span class="line">	User user = new User(2001,&quot;李雷&quot;,&quot;男&quot;,1000.123,new Date());</span><br><span class="line">	data.add(user);</span><br><span class="line">	//构建要排除掉的列</span><br><span class="line">	Set&lt;String&gt; excludeColumnFiledNames = new HashSet&lt;&gt;();</span><br><span class="line">	//排除掉hireDate和userName字段</span><br><span class="line">	excludeColumnFiledNames.add(&quot;hireDate&quot;);</span><br><span class="line">	excludeColumnFiledNames.add(&quot;userName&quot;);</span><br><span class="line">	EasyExcel.write(fileName, User.class).excludeColumnFiledNames(excludeColumnFiledNames).sheet(&quot;abc&quot;).doWrite(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-只向表格中导出指定某几个字段"><a href="#2-4-只向表格中导出指定某几个字段" class="headerlink" title="2.4 只向表格中导出指定某几个字段"></a>2.4 只向表格中导出指定某几个字段</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 向Excel文档中写数据</span><br><span class="line"> * 指定将User类中的某几个字段导出</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void writeExcel4() &#123;</span><br><span class="line">	//创建文件保存的位置,以及文件名</span><br><span class="line">	String fileName=&quot;user4.xlsx&quot;;</span><br><span class="line">	/**</span><br><span class="line">	 * 构建要写入的数据</span><br><span class="line">	 * User类是一个自定义的特殊类,专门用来构建向Excel中写数据的类型类</span><br><span class="line">	 * @ExcelProperty是easyexcel提供的注解,用来定义表格的头部</span><br><span class="line">	 */</span><br><span class="line">	List&lt;User&gt; data = new ArrayList&lt;&gt;();</span><br><span class="line">	User user = new User(2001,&quot;李雷&quot;,&quot;男&quot;,1000.123,new Date());</span><br><span class="line">	data.add(user);</span><br><span class="line">	//构建要导出的列</span><br><span class="line">	Set&lt;String&gt; includeColumnFiledNames = new HashSet&lt;&gt;();</span><br><span class="line">	//要导出hireDate和userName字段</span><br><span class="line">	includeColumnFiledNames.add(&quot;hireDate&quot;);</span><br><span class="line">	includeColumnFiledNames.add(&quot;userName&quot;);</span><br><span class="line">	EasyExcel.write(fileName, User.class).includeColumnFiledNames(includeColumnFiledNames).sheet(&quot;abc&quot;).doWrite(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-插入指定的列"><a href="#2-5-插入指定的列" class="headerlink" title="2.5 插入指定的列"></a>2.5 插入指定的列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将Java对象中指定的属性,插入到Excel表格中的指定的列(在Excel中进行列排序)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>写Excel的Java对象类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IndexUser &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * value: 设置Excel中列头的名字 index: 设置Excel中将数据插入指定的列(列排序) eg: value=&quot;姓名&quot; index=2 :</span><br><span class="line">	 * 将姓名的列头设置在Excel表格的第三列</span><br><span class="line">	 */</span><br><span class="line">	@ExcelProperty(value = &quot;用户编号&quot;, index = 0)</span><br><span class="line">	private Integer userId;</span><br><span class="line">	@ExcelProperty(value = &quot;姓名&quot;, index = 2)</span><br><span class="line">	private String userName;</span><br><span class="line">	@ExcelProperty(value = &quot;入职时间&quot;, index = 1)</span><br><span class="line">	private Date hireDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向Excel中写数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 插入指定列</span><br><span class="line"> * Java类中有三个属性</span><br><span class="line"> * 我现在要将这三个属性的数据保存到Excel表格中</span><br><span class="line"> * 并且自定义在Excel中的列顺序</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void writeExcel5() &#123;</span><br><span class="line">	//创建文件保存的位置,以及文件名</span><br><span class="line">	String fileName=&quot;user5.xlsx&quot;;</span><br><span class="line">	/**</span><br><span class="line">	 * 构建要写入的数据</span><br><span class="line">	 */</span><br><span class="line">	List&lt;IndexUser&gt; data = new ArrayList&lt;&gt;();</span><br><span class="line">	IndexUser user = new IndexUser(1001,&quot;枫桥夜泊&quot;,new Date());</span><br><span class="line">	data.add(user);</span><br><span class="line">	EasyExcel.write(fileName, IndexUser.class).sheet(&quot;abc&quot;).doWrite(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-复杂头数据写入"><a href="#2-6-复杂头数据写入" class="headerlink" title="2.6 复杂头数据写入"></a>2.6 复杂头数据写入</h4></li>
<li><p>写Excel的Java对象类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 构建复杂头信息数据的类</span><br><span class="line"> * @Author 夜泊 </span><br><span class="line"> * @BLOG   https://hd1611756908.github.io/</span><br><span class="line"> */</span><br><span class="line">public class ComplexHeadUser &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * &#123;&quot;用户主题1&quot;,&quot;用户编号&quot;&#125;这种遇到格式设置多级主题</span><br><span class="line">	 * 第一个参数为一级主题(第一行)</span><br><span class="line">	 * 第二个参数为二级主题(第二行)</span><br><span class="line">	 * 如果一级主题名称相同,那么他们会合并单元格</span><br><span class="line">	 */</span><br><span class="line">	@ExcelProperty(&#123;&quot;用户主题1&quot;,&quot;用户编号&quot;&#125;)</span><br><span class="line">	private Integer userId;</span><br><span class="line">	@ExcelProperty(&#123;&quot;用户主题2&quot;,&quot;用户名称&quot;&#125;)</span><br><span class="line">	private String userName;</span><br><span class="line">	@ExcelProperty(&#123;&quot;用户主题3&quot;,&quot;入职时间&quot;&#125;)</span><br><span class="line">	private Date hireDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向Excel中写数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 写入复杂头信息到Excel</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void writeExcel6() &#123;</span><br><span class="line">	//创建文件保存的位置,以及文件名</span><br><span class="line">	String fileName=&quot;user6.xlsx&quot;;</span><br><span class="line">	/**</span><br><span class="line">	 * 构建要写入的数据</span><br><span class="line">	 */</span><br><span class="line">	List&lt;ComplexHeadUser&gt; data = new ArrayList&lt;&gt;();</span><br><span class="line">	ComplexHeadUser user = new ComplexHeadUser(1001,&quot;枫桥夜泊&quot;,new Date());</span><br><span class="line">	data.add(user);</span><br><span class="line">	EasyExcel.write(fileName, ComplexHeadUser.class).sheet(&quot;abc&quot;).doWrite(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-7-重复写到Excel的同一个sheet中"><a href="#2-7-重复写到Excel的同一个sheet中" class="headerlink" title="2.7 重复写到Excel的同一个sheet中"></a>2.7 重复写到Excel的同一个sheet中</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 重复写到同一个sheet中</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void writeExcel7() &#123;</span><br><span class="line">	//创建文件保存的位置,以及文件名</span><br><span class="line">	String fileName=&quot;user7.xlsx&quot;;</span><br><span class="line">	//构建数据</span><br><span class="line">	List&lt;User&gt; data = new ArrayList&lt;&gt;();</span><br><span class="line">	User user1 = new User(2001,&quot;李雷1&quot;,&quot;男&quot;,1000.123,new Date());</span><br><span class="line">	User user2 = new User(2002,&quot;李雷2&quot;,&quot;男&quot;,1000.123,new Date());</span><br><span class="line">	User user3 = new User(2003,&quot;李雷3&quot;,&quot;男&quot;,1000.123,new Date());</span><br><span class="line">	User user4 = new User(2004,&quot;李雷4&quot;,&quot;男&quot;,1000.123,new Date());</span><br><span class="line">	data.add(user1);</span><br><span class="line">	data.add(user2);</span><br><span class="line">	data.add(user3);</span><br><span class="line">	data.add(user4);</span><br><span class="line">	//创建ExcelWriter对对象并设置用哪个Class(数据类型)去写</span><br><span class="line">	ExcelWriter excelWriter = EasyExcel.write(fileName, User.class).build();</span><br><span class="line">	//创建sheet</span><br><span class="line">	WriteSheet writeSheet = EasyExcel.writerSheet(&quot;用户信息&quot;).build();</span><br><span class="line">	//模拟重复写入,模拟重复写入5次</span><br><span class="line">	for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">		excelWriter.write(data, writeSheet);</span><br><span class="line">	&#125;</span><br><span class="line">	//关闭流</span><br><span class="line">	excelWriter.finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-8-重复的写到Excel的不同sheet中"><a href="#2-8-重复的写到Excel的不同sheet中" class="headerlink" title="2.8 重复的写到Excel的不同sheet中"></a>2.8 重复的写到Excel的不同sheet中</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 重复写到不同sheet中</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void writeExcel8() &#123;</span><br><span class="line">	//创建文件保存的位置,以及文件名</span><br><span class="line">	String fileName=&quot;user8.xlsx&quot;;</span><br><span class="line">	//构建数据</span><br><span class="line">	List&lt;User&gt; data = new ArrayList&lt;&gt;();</span><br><span class="line">	User user1 = new User(2001,&quot;李雷1&quot;,&quot;男&quot;,1000.123,new Date());</span><br><span class="line">	User user2 = new User(2002,&quot;李雷2&quot;,&quot;男&quot;,1000.123,new Date());</span><br><span class="line">	User user3 = new User(2003,&quot;李雷3&quot;,&quot;男&quot;,1000.123,new Date());</span><br><span class="line">	User user4 = new User(2004,&quot;李雷4&quot;,&quot;男&quot;,1000.123,new Date());</span><br><span class="line">	data.add(user1);</span><br><span class="line">	data.add(user2);</span><br><span class="line">	data.add(user3);</span><br><span class="line">	data.add(user4);</span><br><span class="line">	//创建ExcelWriter对对象并设置用哪个Class(数据类型)去写</span><br><span class="line">	ExcelWriter excelWriter = EasyExcel.write(fileName, User.class).build();</span><br><span class="line">	</span><br><span class="line">	//模拟重复写入,模拟重复写入5次</span><br><span class="line">	for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">		//创建sheet(因为写入到不同的sheet,所以需要多次创建sheet)</span><br><span class="line">		//WriteSheet writeSheet = EasyExcel.writerSheet(i,&quot;用户信息&quot;+i).build(); //用下面的格式也可以</span><br><span class="line">		WriteSheet writeSheet = EasyExcel.writerSheet(&quot;用户信息&quot;+i).build();</span><br><span class="line">		excelWriter.write(data, writeSheet);</span><br><span class="line">	&#125;</span><br><span class="line">	//关闭流</span><br><span class="line">	excelWriter.finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-9-日期、数字类型格式化"><a href="#2-9-日期、数字类型格式化" class="headerlink" title="2.9 日期、数字类型格式化"></a>2.9 日期、数字类型格式化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于日期和数字有时候我们需要对其展示的样式进行格式化,easyexcel提供了一下注解</span><br><span class="line">@DateTimeFormat : 日期格式化</span><br><span class="line">@NumberFormat   : 数字格式化(小数或者百分数)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>写Excel的Java对象类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 创建User类,用于构建向Excel表格中写数据的类型;</span><br><span class="line"> * @ExcelProperty:这个注解是EasyExcel提供,用于生成Excel表格头</span><br><span class="line"> * @Author 夜泊 </span><br><span class="line"> * @BLOG   https://hd1611756908.github.io/</span><br><span class="line"> */</span><br><span class="line">public class User &#123;</span><br><span class="line">	@ExcelProperty(&quot;用户编号&quot;)</span><br><span class="line">	private Integer userId;</span><br><span class="line">	@ExcelProperty(&quot;姓名&quot;)</span><br><span class="line">	private String userName;</span><br><span class="line">	@ExcelProperty(&quot;性别&quot;)</span><br><span class="line">	private String gender;</span><br><span class="line">	//格式化小数类型,如果是百分数那么定义为  #.##% 比如:9.12%</span><br><span class="line">	@NumberFormat(&quot;#.##&quot;)</span><br><span class="line">	@ExcelProperty(&quot;工资&quot;)</span><br><span class="line">	private Double salary;</span><br><span class="line">	//格式化时间</span><br><span class="line">	@DateTimeFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;)</span><br><span class="line">	@ExcelProperty(&quot;入职时间&quot;)</span><br><span class="line">	private Date hireDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向Excel中写数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 日期、数字格式化</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void writeExcel9() &#123;</span><br><span class="line">	//创建文件保存的位置,以及文件名</span><br><span class="line">	String fileName=&quot;user9.xlsx&quot;;</span><br><span class="line">	//构建数据</span><br><span class="line">	List&lt;User&gt; data = new ArrayList&lt;&gt;();</span><br><span class="line">	User user1 = new User(2001,&quot;李雷1&quot;,&quot;男&quot;,1000.12223,new Date());</span><br><span class="line">	User user2 = new User(2002,&quot;李雷2&quot;,&quot;男&quot;,1000.12223,new Date());</span><br><span class="line">	User user3 = new User(2003,&quot;李雷3&quot;,&quot;男&quot;,1000.12223,new Date());</span><br><span class="line">	User user4 = new User(2004,&quot;李雷4&quot;,&quot;男&quot;,1000.13323,new Date());</span><br><span class="line">	data.add(user1);</span><br><span class="line">	data.add(user2);</span><br><span class="line">	data.add(user3);</span><br><span class="line">	data.add(user4);</span><br><span class="line">	</span><br><span class="line">	EasyExcel.write(fileName, User.class).sheet(&quot;用戶信息&quot;).doWrite(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-10-写入图片到Excel"><a href="#2-10-写入图片到Excel" class="headerlink" title="2.10 写入图片到Excel"></a>2.10 写入图片到Excel</h4></li>
<li><p>写Excel的Java对象类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 构建向Excel中写图片的类 支持5种数据类型的图片类型 </span><br><span class="line"> * 1. 图片可以是一个File格式 </span><br><span class="line"> * 2. 图片可以是一个InputStream输入流的方式 </span><br><span class="line"> * 3. 图片可以是一个byte[]数组的方式 </span><br><span class="line"> * 4. 图片可以是 一个网络的java.net.URL对象方式 </span><br><span class="line"> * 5. 图片也可以是一个String类型方式(当是String类型是，需要StringImageConverter类型转换器)</span><br><span class="line"> * </span><br><span class="line"> * @Author 夜泊</span><br><span class="line"> * @BLOG https://hd1611756908.github.io/</span><br><span class="line"> */</span><br><span class="line">@ContentRowHeight(100)  // 内容高度</span><br><span class="line">@ColumnWidth(100 / 8)   // 列宽</span><br><span class="line">public class ImageData &#123;</span><br><span class="line">	// 使用抽象文件表示一个图片</span><br><span class="line">	private File file;</span><br><span class="line">	// 使用输入流保存一个图片</span><br><span class="line">	private InputStream inputStream;</span><br><span class="line">	/**</span><br><span class="line">	 * 当使用String类型保存一个图片的时候需要使用StringImageConverter转换器</span><br><span class="line">	 */</span><br><span class="line">	@ExcelProperty(converter = StringImageConverter.class)</span><br><span class="line">	private String string;</span><br><span class="line">	// 使用二进制数据保存为一个图片</span><br><span class="line">	private byte[] byteArray;</span><br><span class="line">	// 使用网络链接保存一个图片</span><br><span class="line">	private URL url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向Excel中写数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将图片写入到Excel表格中</span><br><span class="line"> * EasyExcel提供了5种数据格式进行图片写入</span><br><span class="line"> * @throws IOException </span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void writeExcel10() throws IOException &#123;</span><br><span class="line">	//创建文件保存的位置,以及文件名</span><br><span class="line">	String fileName=&quot;user10.xlsx&quot;;</span><br><span class="line">	</span><br><span class="line">	List&lt;ImageData&gt; list = new ArrayList&lt;ImageData&gt;();</span><br><span class="line">	ImageData imageData = new ImageData();</span><br><span class="line">	//根据File写入</span><br><span class="line">	imageData.setFile(new File(&quot;imgs/img.png&quot;));</span><br><span class="line">	//根据InputStream写入</span><br><span class="line">	imageData.setInputStream(new FileInputStream(&quot;imgs/img.png&quot;));</span><br><span class="line">	//根据String类型写入</span><br><span class="line">	imageData.setString(&quot;imgs/img.png&quot;);</span><br><span class="line">	/*</span><br><span class="line">	 * 使用二进制方式写入步骤:</span><br><span class="line">	 * 1. 获取文件大小</span><br><span class="line">	 * 2. 读成二进制流</span><br><span class="line">	 */</span><br><span class="line">	File file = new File(&quot;imgs/img.png&quot;);</span><br><span class="line">	//创建一个指定大小的二进制数组</span><br><span class="line">	byte[] byteArray = new byte[(int)file.length()];</span><br><span class="line">	FileInputStream in = new FileInputStream(file);</span><br><span class="line">	//将文件流写入到二进制数组中</span><br><span class="line">	in.read(byteArray, 0, (int)file.length());</span><br><span class="line">	imageData.setByteArray(byteArray);</span><br><span class="line">	//只用网络链接</span><br><span class="line">	imageData.setUrl(new URL(&quot;https://pics5.baidu.com/feed/e850352ac65c10384dcf6805a7540815b17e890b.jpeg?token=46fd105a95d8754d3daf93de7e8a7f6f&quot;));</span><br><span class="line">	list.add(imageData);</span><br><span class="line">	EasyExcel.write(fileName, ImageData.class).sheet().doWrite(list);</span><br><span class="line">	//关闭输入流</span><br><span class="line">	in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-11-设置写入Excel的列宽行高设置"><a href="#2-11-设置写入Excel的列宽行高设置" class="headerlink" title="2.11 设置写入Excel的列宽行高设置"></a>2.11 设置写入Excel的列宽行高设置</h4><ul>
<li><p>写Excel的Java对象类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ContentRowHeight(30) //设置内容高度</span><br><span class="line">@HeadRowHeight(40)    //设置标题高度</span><br><span class="line">@ColumnWidth(25)      //设置列宽</span><br><span class="line">public class WidthAndHeightData &#123;</span><br><span class="line"></span><br><span class="line">	@ExcelProperty(&quot;字符串标题&quot;)</span><br><span class="line">	private String string;</span><br><span class="line">	@ExcelProperty(&quot;日期标题&quot;)</span><br><span class="line">	private Date date;</span><br><span class="line">	@ColumnWidth(50)   //设置列宽(可以修饰类,也可以修饰具体属性)</span><br><span class="line">	@ExcelProperty(&quot;数字标题&quot;)</span><br><span class="line">	private Double doubleData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向Excel中写数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 设置Excel的列宽行高</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void writeExcel11()&#123;</span><br><span class="line">	//创建文件保存的位置,以及文件名</span><br><span class="line">	String fileName=&quot;user11.xlsx&quot;;</span><br><span class="line">	//构建数据</span><br><span class="line">	List&lt;WidthAndHeightData&gt; list = new ArrayList&lt;WidthAndHeightData&gt;();</span><br><span class="line">	WidthAndHeightData wahd = new WidthAndHeightData();</span><br><span class="line">	wahd.setString(&quot;小明&quot;);</span><br><span class="line">	wahd.setDoubleData(200.12);</span><br><span class="line">	wahd.setDate(new Date());</span><br><span class="line">	list.add(wahd);</span><br><span class="line">	//写数据</span><br><span class="line">	EasyExcel.write(fileName, WidthAndHeightData.class).sheet(&quot;信息&quot;).doWrite(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-12-通过注解形式设置写入Excel的样式"><a href="#2-12-通过注解形式设置写入Excel的样式" class="headerlink" title="2.12 通过注解形式设置写入Excel的样式"></a>2.12 通过注解形式设置写入Excel的样式</h4><ul>
<li><p>写Excel的Java对象类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//头背景设置成红色 IndexedColors.RED.getIndex()</span><br><span class="line">@HeadStyle(fillPatternType = FillPatternType.SOLID_FOREGROUND, fillForegroundColor = 10)</span><br><span class="line">//头字体设置成20</span><br><span class="line">@HeadFontStyle(fontHeightInPoints = 20)</span><br><span class="line">//内容的背景设置成绿色 IndexedColors.GREEN.getIndex()</span><br><span class="line">@ContentStyle(fillPatternType = FillPatternType.SOLID_FOREGROUND, fillForegroundColor = 17)</span><br><span class="line">//内容字体设置成20</span><br><span class="line">@ContentFontStyle(fontHeightInPoints = 20)</span><br><span class="line">public class DemoStyleData &#123;</span><br><span class="line"></span><br><span class="line">	// 字符串的头背景设置成粉红 IndexedColors.PINK.getIndex()</span><br><span class="line">	@HeadStyle(fillPatternType = FillPatternType.SOLID_FOREGROUND, fillForegroundColor = 14)</span><br><span class="line">	// 字符串的头字体设置成20</span><br><span class="line">	@HeadFontStyle(fontHeightInPoints = 30)</span><br><span class="line">	// 字符串的内容的背景设置成天蓝 IndexedColors.SKY_BLUE.getIndex()</span><br><span class="line">	@ContentStyle(fillPatternType = FillPatternType.SOLID_FOREGROUND, fillForegroundColor = 40)</span><br><span class="line">	// 字符串的内容字体设置成20</span><br><span class="line">	@ContentFontStyle(fontHeightInPoints = 30)</span><br><span class="line">	@ExcelProperty(&quot;字符串标题&quot;)</span><br><span class="line">	private String string;</span><br><span class="line">	@ExcelProperty(&quot;日期标题&quot;)</span><br><span class="line">	private Date date;</span><br><span class="line">	@ExcelProperty(&quot;数字标题&quot;)</span><br><span class="line">	private Double doubleData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向Excel中写数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 注解形式设置Excel样式</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void writeExcel12()&#123;</span><br><span class="line">	//创建文件保存的位置,以及文件名</span><br><span class="line">	String fileName=&quot;user12.xlsx&quot;;</span><br><span class="line">	//构建数据</span><br><span class="line">	List&lt;DemoStyleData&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">	DemoStyleData dsld = new DemoStyleData();</span><br><span class="line">	dsld.setDate(new Date());</span><br><span class="line">	dsld.setDoubleData(200.12);</span><br><span class="line">	dsld.setString(&quot;韓梅梅&quot;);</span><br><span class="line">	list.add(dsld);</span><br><span class="line">	EasyExcel.write(fileName, DemoStyleData.class).sheet(&quot;信息&quot;).doWrite(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-13-合并单元格"><a href="#2-13-合并单元格" class="headerlink" title="2.13 合并单元格"></a>2.13 合并单元格</h4><ul>
<li><p>写Excel的Java对象类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @OnceAbsoluteMerge: 指定从哪一行开始，哪一行结束，哪一列开始，哪一列结束，进行合并单元格</span><br><span class="line"> * firstRowIndex   : 起始行索引 从0开始</span><br><span class="line"> * lastRowIndex    : 结束行索引</span><br><span class="line"> * firstColumnIndex: 起始列索引 从0开始</span><br><span class="line"> * lastColumnIndex : 结束列索引</span><br><span class="line"> * 例如: 第2-3行,2-3列进行合并</span><br><span class="line"> */</span><br><span class="line">@OnceAbsoluteMerge(firstRowIndex = 1,lastRowIndex = 2,firstColumnIndex = 1,lastColumnIndex = 2)</span><br><span class="line">public class DemoMergeData &#123;</span><br><span class="line">	//每隔两行合并一次(竖着合并单元格)</span><br><span class="line">	//@ContentLoopMerge(eachRow = 2)</span><br><span class="line">	@ExcelProperty(&quot;字符串标题&quot;)</span><br><span class="line">	private String string;</span><br><span class="line">	@ExcelProperty(&quot;日期标题&quot;)</span><br><span class="line">	private Date date;</span><br><span class="line">	@ExcelProperty(&quot;数字标题&quot;)</span><br><span class="line">	private Double doubleData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向Excel中写数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 合并单元格</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void writeExcel13()&#123;</span><br><span class="line">	//创建文件保存的位置,以及文件名</span><br><span class="line">	String fileName=&quot;user13.xlsx&quot;;</span><br><span class="line">	//构建数据</span><br><span class="line">	List&lt;DemoMergeData&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">	DemoMergeData dmd = new DemoMergeData();</span><br><span class="line">	dmd.setDate(new Date());</span><br><span class="line">	dmd.setDoubleData(200.12);</span><br><span class="line">	dmd.setString(&quot;韓梅梅&quot;);</span><br><span class="line">	DemoMergeData dmd2 = new DemoMergeData();</span><br><span class="line">	dmd2.setDate(new Date());</span><br><span class="line">	dmd2.setDoubleData(200.12);</span><br><span class="line">	dmd2.setString(&quot;韓梅梅&quot;);</span><br><span class="line">	DemoMergeData dmd3 = new DemoMergeData();</span><br><span class="line">	dmd3.setDate(new Date());</span><br><span class="line">	dmd3.setDoubleData(200.12);</span><br><span class="line">	dmd3.setString(&quot;韓梅梅&quot;);</span><br><span class="line">	DemoMergeData dmd4 = new DemoMergeData();</span><br><span class="line">	dmd4.setDate(new Date());</span><br><span class="line">	dmd4.setDoubleData(200.12);</span><br><span class="line">	dmd4.setString(&quot;韓梅梅&quot;);</span><br><span class="line">	DemoMergeData dmd5 = new DemoMergeData();</span><br><span class="line">	dmd5.setDate(new Date());</span><br><span class="line">	dmd5.setDoubleData(200.12);</span><br><span class="line">	dmd5.setString(&quot;韓梅梅&quot;);</span><br><span class="line">	list.add(dmd);</span><br><span class="line">	list.add(dmd2);</span><br><span class="line">	list.add(dmd3);</span><br><span class="line">	list.add(dmd4);</span><br><span class="line">	list.add(dmd5);</span><br><span class="line">	EasyExcel.write(fileName, DemoMergeData.class).sheet(&quot;信息&quot;).doWrite(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第3节-读Excel"><a href="#第3节-读Excel" class="headerlink" title="第3节 读Excel"></a>第3节 读Excel</h3><h4 id="3-1-最简单的读取Excel"><a href="#3-1-最简单的读取Excel" class="headerlink" title="3.1 最简单的读取Excel"></a>3.1 最简单的读取Excel</h4><ul>
<li>Excel表格数据类型</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEBd0b986a78d3129445d7cb5c5d8ae148d?method=download&shareKey=d499346d2c26e9eef3c36b363302f099"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBd0b986a78d3129445d7cb5c5d8ae148d?method=download&shareKey=d499346d2c26e9eef3c36b363302f099" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><p>盛装数据的Java对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 承装Excel表格数据的类</span><br><span class="line"> * 注意点: Java类中的属性的顺序和Excel中的列头的顺序是相同的</span><br><span class="line"> * @Author 夜泊 </span><br><span class="line"> * @BLOG   https://hd1611756908.github.io/</span><br><span class="line"> */</span><br><span class="line">public class DemoData &#123;</span><br><span class="line">    </span><br><span class="line">	private String name;</span><br><span class="line">	private Date hireDate;</span><br><span class="line">	private Double salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>读取Excel数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 最简单的读取Excel内容(方式一)</span><br><span class="line"> * 默认读取Excel文件中的第一个sheet</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testRead1() &#123;</span><br><span class="line">	//读取的文件路径</span><br><span class="line">	String fileName=&quot;user11.xlsx&quot;;</span><br><span class="line">	Class&lt;DemoData&gt; head = DemoData.class; //创建一个数据格式来承装读取到数据</span><br><span class="line">	//读取数据</span><br><span class="line">	EasyExcel.read(fileName, head, new AnalysisEventListener&lt;DemoData&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 解析每一条数据的时候被调用</span><br><span class="line">		 */</span><br><span class="line">		@Override</span><br><span class="line">		public void invoke(DemoData data, AnalysisContext context) &#123;</span><br><span class="line">			//在这里操作，将解析的每一条数据保存到数据库中,在这里可以调用数据库</span><br><span class="line">			System.out.println(&quot;解析的数据为: &quot;+data);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 解析完所有数据的时候被调用</span><br><span class="line">		 */</span><br><span class="line">		@Override</span><br><span class="line">		public void doAfterAllAnalysed(AnalysisContext context) &#123;</span><br><span class="line">			System.out.println(&quot;数据解析完成..........&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).sheet().doRead();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 最简单的读取Excel内容(方式二)</span><br><span class="line"> * 默认读取Excel文件中的第一个sheet</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testRead2() &#123;</span><br><span class="line">	//读取的文件路径</span><br><span class="line">	String fileName=&quot;user11.xlsx&quot;;</span><br><span class="line">	Class&lt;DemoData&gt; head = DemoData.class; //创建一个数据格式来承装读取到数据</span><br><span class="line">	//创建ExcelReader对象</span><br><span class="line">	ExcelReader excelReader = EasyExcel.read(fileName, head, new AnalysisEventListener&lt;DemoData&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void invoke(DemoData data, AnalysisContext context) &#123;</span><br><span class="line">			System.out.println(&quot;读取到的数据为:&quot;+data);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void doAfterAllAnalysed(AnalysisContext context) &#123;</span><br><span class="line">			System.out.println(&quot;数据解析已完成&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).build();</span><br><span class="line">	//创建sheet对象,并读取Excel的第1个sheet(下标从0开始)</span><br><span class="line">	ReadSheet readSheet = EasyExcel.readSheet(0).build();</span><br><span class="line">	excelReader.read(readSheet);</span><br><span class="line">	//关闭流操作，在读取文件时会创建临时文件,如果不关闭,磁盘爆掉</span><br><span class="line">	excelReader.finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-2-根据Excel中指定的列名或者列的下标读取指定列的数据"><a href="#3-2-根据Excel中指定的列名或者列的下标读取指定列的数据" class="headerlink" title="3.2 根据Excel中指定的列名或者列的下标读取指定列的数据"></a>3.2 根据Excel中指定的列名或者列的下标读取指定列的数据</h4><ul>
<li><p>盛装数据的Java对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class IndexOrNameData &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 强制读取第三个 这里不建议 index 和 name 同时用，要么一个对象只用index，要么一个对象只用name去匹配</span><br><span class="line">	 */</span><br><span class="line">	@ExcelProperty(index = 2)</span><br><span class="line">	private Double doubleData;</span><br><span class="line">	/**</span><br><span class="line">	 * 用名字去匹配，这里需要注意，如果名字重复，会导致只有一个字段读取到数据</span><br><span class="line">	 */</span><br><span class="line">	@ExcelProperty(&quot;字符串标题&quot;)</span><br><span class="line">	private String string;</span><br><span class="line">	@ExcelProperty(&quot;日期标题&quot;)</span><br><span class="line">	private Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>读取Excel数据操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 根据名称或者下标获取指定的Excel表格数据</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testRead3() &#123;</span><br><span class="line">	//读取的文件路径</span><br><span class="line">	String fileName=&quot;user11.xlsx&quot;;</span><br><span class="line">	Class&lt;IndexOrNameData&gt; head = IndexOrNameData.class; //创建一个数据格式来承装读取到数据</span><br><span class="line">	//读取数据</span><br><span class="line">	EasyExcel.read(fileName, head, new AnalysisEventListener&lt;IndexOrNameData&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 解析每一条数据的时候被调用</span><br><span class="line">		 */</span><br><span class="line">		@Override</span><br><span class="line">		public void invoke(IndexOrNameData data, AnalysisContext context) &#123;</span><br><span class="line">			//在这里操作，将解析的每一条数据保存到数据库中,在这里可以调用数据库</span><br><span class="line">			System.out.println(&quot;解析的数据为: &quot;+data);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 解析完所有数据的时候被调用</span><br><span class="line">		 */</span><br><span class="line">		@Override</span><br><span class="line">		public void doAfterAllAnalysed(AnalysisContext context) &#123;</span><br><span class="line">			System.out.println(&quot;数据解析完成..........&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).sheet().doRead();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-3-格式化Excel中的数据格式-例如时间"><a href="#3-3-格式化Excel中的数据格式-例如时间" class="headerlink" title="3.3 格式化Excel中的数据格式(例如时间)"></a>3.3 格式化Excel中的数据格式(例如时间)</h4><ul>
<li><p>盛装数据的Java对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 定义需要被格式化的字段</span><br><span class="line"> * 如果使用@NumberFormat(&quot;#.##&quot;)注解，建议数据类型采用String,如果使用double可能不能被格式化</span><br><span class="line"> * @Author 夜泊</span><br><span class="line"> * @BLOG https://hd1611756908.github.io/</span><br><span class="line"> */</span><br><span class="line">public class ConverterData &#123;</span><br><span class="line"></span><br><span class="line">	@NumberFormat(&quot;#.#&quot;)</span><br><span class="line">	@ExcelProperty(&quot;数字标题&quot;)</span><br><span class="line">	private String salary;</span><br><span class="line">	@DateTimeFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class="line">	@ExcelProperty(&quot;日期标题&quot;)</span><br><span class="line">	private Date hireDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>读取Excel数据操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 格式化Excel中的数据格式(例如时间)</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testRead4() &#123;</span><br><span class="line">	//读取的文件路径</span><br><span class="line">	String fileName=&quot;user11.xlsx&quot;;</span><br><span class="line">	Class&lt;ConverterData&gt; head = ConverterData.class; //创建一个数据格式来承装读取到数据</span><br><span class="line">	//读取数据</span><br><span class="line">	EasyExcel.read(fileName, head, new AnalysisEventListener&lt;ConverterData&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 解析每一条数据的时候被调用</span><br><span class="line">		 */</span><br><span class="line">		@Override</span><br><span class="line">		public void invoke(ConverterData data, AnalysisContext context) &#123;</span><br><span class="line">			//在这里操作，将解析的每一条数据保存到数据库中,在这里可以调用数据库</span><br><span class="line">			System.out.println(&quot;解析的数据为: &quot;+data);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 解析完所有数据的时候被调用</span><br><span class="line">		 */</span><br><span class="line">		@Override</span><br><span class="line">		public void doAfterAllAnalysed(AnalysisContext context) &#123;</span><br><span class="line">			System.out.println(&quot;数据解析完成..........&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).sheet().doRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-4-读取多个或者全部的Sheet"><a href="#3-4-读取多个或者全部的Sheet" class="headerlink" title="3.4 读取多个或者全部的Sheet"></a>3.4 读取多个或者全部的Sheet</h4><ul>
<li><p>盛装数据的Java对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 承装Excel表格数据的类</span><br><span class="line"> * 注意点: Java类中的属性的顺序和Excel中的列头的顺序是相同的</span><br><span class="line"> * @Author 夜泊 </span><br><span class="line"> * @BLOG   https://hd1611756908.github.io/</span><br><span class="line"> */</span><br><span class="line">public class DemoData &#123;</span><br><span class="line"></span><br><span class="line">	private String name;</span><br><span class="line">	private Date hireDate;</span><br><span class="line">	private Double salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>读取Excel数据操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 读取Excel中的多个或者全部sheet</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testRead5() &#123;</span><br><span class="line">	//读取的文件路径</span><br><span class="line">	String fileName=&quot;user11.xlsx&quot;;</span><br><span class="line">	Class&lt;DemoData&gt; head = DemoData.class; //创建一个数据格式来承装读取到数据</span><br><span class="line">	/**</span><br><span class="line">	 * 读取全部sheet</span><br><span class="line">	 */</span><br><span class="line">	EasyExcel.read(fileName, head, new AnalysisEventListener&lt;DemoData&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void invoke(DemoData data, AnalysisContext context) &#123;</span><br><span class="line">			// 每解析一条数据被调用一次</span><br><span class="line">			System.out.println(&quot;解析的数据为: &quot;+data);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void doAfterAllAnalysed(AnalysisContext context) &#123;</span><br><span class="line">			// 数据解析完成之后被调用</span><br><span class="line">			System.out.println(&quot;数据解析完成......&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).doReadAll();</span><br><span class="line">	</span><br><span class="line">	System.out.println(&quot;============================================================&quot;);</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 读取其中的某几个sheet</span><br><span class="line">	 */</span><br><span class="line">	//构建ExcelReader对象</span><br><span class="line">	ExcelReader excelReader = EasyExcel.read(fileName).build();</span><br><span class="line">	//创建想要获取的sheet对象</span><br><span class="line">	ReadSheet sheet1 = EasyExcel.readSheet(0).head(DemoData.class).registerReadListener(new AnalysisEventListener&lt;DemoData&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void invoke(DemoData data, AnalysisContext context) &#123;</span><br><span class="line">			// 每解析一条数据被调用一次</span><br><span class="line">			System.out.println(&quot;解析的数据为: &quot;+data);				</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void doAfterAllAnalysed(AnalysisContext context) &#123;</span><br><span class="line">			// 数据解析完成之后被调用</span><br><span class="line">			System.out.println(&quot;数据解析完成......&quot;);				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).build();</span><br><span class="line">	</span><br><span class="line">	ReadSheet sheet2 = EasyExcel.readSheet(2).head(DemoData.class).registerReadListener(new AnalysisEventListener&lt;DemoData&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void invoke(DemoData data, AnalysisContext context) &#123;</span><br><span class="line">			// 每解析一条数据被调用一次</span><br><span class="line">			System.out.println(&quot;解析的数据为: &quot;+data);				</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void doAfterAllAnalysed(AnalysisContext context) &#123;</span><br><span class="line">			// 数据解析完成之后被调用</span><br><span class="line">			System.out.println(&quot;数据解析完成......&quot;);				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).build();</span><br><span class="line">	//读取sheet</span><br><span class="line">	excelReader.read(sheet1,sheet2);</span><br><span class="line">	//关闭</span><br><span class="line">	excelReader.finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第4节-填充Excel"><a href="#第4节-填充Excel" class="headerlink" title="第4节 填充Excel"></a>第4节 填充Excel</h3><h4 id="4-1-简单填充"><a href="#4-1-简单填充" class="headerlink" title="4.1 简单填充"></a>4.1 简单填充</h4><ul>
<li><p>创建Excel模板格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">填充单个属性使用&#123;&#125;作为占位符,在大括号里面定义属性名称,如果&#123;&#125;想不作为占位符展示出来,可以使用反斜杠进行转义.</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB69924e488f22f85f277b6742d945a479?method=download&shareKey=272a78e39f2565b413d5ac6744e602b8"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB69924e488f22f85f277b6742d945a479?method=download&shareKey=272a78e39f2565b413d5ac6744e602b8" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><p>填充数据的Java类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FillData &#123;</span><br><span class="line">	private String name;</span><br><span class="line">    private double number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>填充的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 简单的单个对象填充</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void excelFull() &#123;</span><br><span class="line">	//读取模板文件</span><br><span class="line">	String templateFileName=&quot;templateFileName.xlsx&quot;;</span><br><span class="line">	//通过模板文件生成的填充之后的文件</span><br><span class="line">	String fullFile=&quot;fullFile.xlsx&quot;;</span><br><span class="line">	//构建要填充的数据</span><br><span class="line">	FillData data = new FillData();</span><br><span class="line">	data.setName(&quot;张三&quot;);</span><br><span class="line">	data.setNumber(5.2);</span><br><span class="line">	//填充操作</span><br><span class="line">	EasyExcel.write(fullFile).withTemplate(templateFileName).sheet().doFill(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>填充之后的效果</p>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB92a74953f77024100d786804cc770dcc?method=download&shareKey=9a3c73044c0c269c3f944e35373e1f8e"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB92a74953f77024100d786804cc770dcc?method=download&shareKey=9a3c73044c0c269c3f944e35373e1f8e" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<h4 id="4-2-列表填充"><a href="#4-2-列表填充" class="headerlink" title="4.2 列表填充"></a>4.2 列表填充</h4><ul>
<li><p>创建Excel模板格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当占位符是一个列表时,&#123;&#125;里面的属性前面要加一个点代表多个</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB52736389f77c9328af30c3cb04c91297?method=download&shareKey=88e7cf711726d1c856e29a056b9b715b"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB52736389f77c9328af30c3cb04c91297?method=download&shareKey=88e7cf711726d1c856e29a056b9b715b" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><p>填充数据的Java类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FillData &#123;</span><br><span class="line">	private String name;</span><br><span class="line">    private double number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>填充的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 简单的列表对象填充</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void excelFull2() &#123;</span><br><span class="line">	//读取模板文件</span><br><span class="line">	String templateFileName=&quot;templateFileName2.xlsx&quot;;</span><br><span class="line">	//通过模板文件生成的填充之后的文件</span><br><span class="line">	String fullFile=&quot;fullFile2.xlsx&quot;;</span><br><span class="line">	//构建要填充的数据列表</span><br><span class="line">	List&lt;FillData&gt; list = new ArrayList&lt;FillData&gt;();</span><br><span class="line">	FillData data1 = new FillData();</span><br><span class="line">	data1.setName(&quot;张三&quot;);</span><br><span class="line">	data1.setNumber(5.2);</span><br><span class="line">	FillData data2 = new FillData();</span><br><span class="line">	data2.setName(&quot;张三&quot;);</span><br><span class="line">	data2.setNumber(5.2);</span><br><span class="line">	list.add(data1);</span><br><span class="line">	list.add(data2);</span><br><span class="line">	//填充操作</span><br><span class="line">	EasyExcel.write(fullFile).withTemplate(templateFileName).sheet().doFill(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>填充之后的效果</p>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB8f8db5fae2863c9590428ea967f822de?method=download&shareKey=296324d30db3647daf6c4b2285c89e6f"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB8f8db5fae2863c9590428ea967f822de?method=download&shareKey=296324d30db3647daf6c4b2285c89e6f" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<h3 id="第5节-Web操作-Excel上传-下载"><a href="#第5节-Web操作-Excel上传-下载" class="headerlink" title="第5节 Web操作(Excel上传/下载)"></a>第5节 Web操作(Excel上传/下载)</h3><h4 id="5-1-Excel下载"><a href="#5-1-Excel下载" class="headerlink" title="5.1 Excel下载"></a>5.1 Excel下载</h4><ul>
<li><p>HTML</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/DownLoadExcel&quot;&gt;下载&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>封装数据的Java类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">	@ExcelProperty(&quot;用户编号&quot;)</span><br><span class="line">	private Integer userId;</span><br><span class="line">	@ExcelProperty(&quot;用户名称&quot;)</span><br><span class="line">	private String userName;</span><br><span class="line">	@ExcelProperty(&quot;用户性别&quot;)</span><br><span class="line">	private String gender;</span><br><span class="line">	@ExcelProperty(&quot;创建时间&quot;)</span><br><span class="line">	private Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>下载操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * EasyExcel下载步骤</span><br><span class="line">	 */</span><br><span class="line">	//设置响应头</span><br><span class="line">	response.setContentType(&quot;application/vnd.ms-excel&quot;);</span><br><span class="line">	response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">	//设置防止文件名中文乱码</span><br><span class="line">	String fileName = URLEncoder.encode(&quot;中文文件名&quot;,&quot;utf-8&quot;);</span><br><span class="line">	response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot;+ fileName + &quot;.xlsx&quot;);</span><br><span class="line">	//构建写入到Excel中的数据(此数据可以从数据库中获取)</span><br><span class="line">	List&lt;User&gt; users = new ArrayList&lt;&gt;();</span><br><span class="line">	User user1 = new User(1001, &quot;李雷1&quot;, &quot;男&quot;, new Date());</span><br><span class="line">	User user2 = new User(1002, &quot;李雷2&quot;, &quot;男&quot;, new Date());</span><br><span class="line">	User user3 = new User(1003, &quot;李雷3&quot;, &quot;男&quot;, new Date());</span><br><span class="line">	users.add(user1);</span><br><span class="line">	users.add(user2);</span><br><span class="line">	users.add(user3);</span><br><span class="line">	EasyExcel.write(response.getOutputStream(),User.class).sheet(&quot;用户信息&quot;).doWrite(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-2-Excel上传"><a href="#5-2-Excel上传" class="headerlink" title="5.2 Excel上传"></a>5.2 Excel上传</h4><ul>
<li><p>前端页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/UploadExcelServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">	&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;</span><br><span class="line">	&lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>接收从Excel中获取到的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">	@ExcelProperty(&quot;用户编号&quot;)</span><br><span class="line">	private Integer userId;</span><br><span class="line">	@ExcelProperty(&quot;用户名称&quot;)</span><br><span class="line">	private String userName;</span><br><span class="line">	@ExcelProperty(&quot;用户性别&quot;)</span><br><span class="line">	private String gender;</span><br><span class="line">	@ExcelProperty(&quot;创建时间&quot;)</span><br><span class="line">	private Date createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上传操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">	</span><br><span class="line">	DiskFileItemFactory factory = new DiskFileItemFactory();</span><br><span class="line">	ServletFileUpload fileUpload = new ServletFileUpload(factory);</span><br><span class="line">	//设置单个文件为3M</span><br><span class="line">	fileUpload.setFileSizeMax(1024*1024*3);</span><br><span class="line">	//总文件大小为30M</span><br><span class="line">	fileUpload.setSizeMax(1024*1024*3*10);</span><br><span class="line">	</span><br><span class="line">	try &#123;</span><br><span class="line">		List&lt;FileItem&gt; list = fileUpload.parseRequest(req);</span><br><span class="line">		</span><br><span class="line">		for (FileItem fileItem : list) &#123;</span><br><span class="line">			</span><br><span class="line">			//判断是否为附件</span><br><span class="line">			if(!fileItem.isFormField()) &#123;</span><br><span class="line">				//是附件</span><br><span class="line">				InputStream inputStream = fileItem.getInputStream();</span><br><span class="line">				EasyExcel.read(inputStream,User.class,new AnalysisEventListener&lt;User&gt;() &#123;</span><br><span class="line"></span><br><span class="line">					@Override</span><br><span class="line">					public void doAfterAllAnalysed(AnalysisContext arg0) &#123;</span><br><span class="line">						System.out.println(&quot;Excel全部读完被执行......&quot;);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					@Override</span><br><span class="line">					public void invoke(User data, AnalysisContext arg1) &#123;</span><br><span class="line">						//读完一行就执行一次(调用数据库进行插入操作)</span><br><span class="line">						System.out.println(&quot;解析一行: &quot;+data);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;).sheet().doRead();</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				//普通表单</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; catch (FileUploadException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	//上传完成进行转发或者重定向</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2021/08/08/JDBC%E7%9A%84/</url>
    <content><![CDATA[<h3 id="1-1-JDBC是什么"><a href="#1-1-JDBC是什么" class="headerlink" title="1.1 JDBC是什么"></a>1.1 JDBC是什么</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、JDBC (Java DataBase Connectivity) 是一组用于操作数据库的Java API</span><br><span class="line">2、JDBC 由一组Java类和接口组成</span><br><span class="line">3、可以为多种关系型数据库提供统一访问</span><br></pre></td></tr></table></figure>



<h3 id="1-2-JDBC原理图"><a href="#1-2-JDBC原理图" class="headerlink" title="1.2 JDBC原理图"></a>1.2 JDBC原理图</h3><p><a href="https://note.youdao.com/yws/api/personal/file/WEBb977189bf473acd2106e4411cde86ae1?method=download&shareKey=e0d91763520b4c25ab021011bc061d91"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBb977189bf473acd2106e4411cde86ae1?method=download&shareKey=e0d91763520b4c25ab021011bc061d91" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<h3 id="1-3-JDBC提供的常用接口和类"><a href="#1-3-JDBC提供的常用接口和类" class="headerlink" title="1.3 JDBC提供的常用接口和类"></a>1.3 JDBC提供的常用接口和类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. DriverManager: 管理数据库驱动程序,用于建立数据库连接</span><br><span class="line"></span><br><span class="line">2. Driver:        提供给各个数据库厂商的接口，每一个数据库厂商要想可以使用Java语言来与他们的数据库进行通信,必须实现此接口.(主要处理与数据库服务器之间的通信)</span><br><span class="line">                   </span><br><span class="line">3. Connection:    此接口具有用于联系数据库的所有方法</span><br><span class="line"></span><br><span class="line">4. Statement:     从此接口创建的对象将SQL语句提交到数据库</span><br><span class="line"></span><br><span class="line">5. ResultSet:     在使用Statement对象执行SQL查询后，这个对象保存从数据库检索的数据</span><br><span class="line"></span><br><span class="line">6. SQLException: 处理数据库应用程序中发生的异常</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第二章-JDBC入门"><a href="#第二章-JDBC入门" class="headerlink" title="第二章 JDBC入门"></a>第二章 JDBC入门</h2><blockquote>
<p>以一个用户表为例来使用JDBC进行增删该查的操作</p>
</blockquote>
<ul>
<li><p>数据库环境搭建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1)、创建数据库</span><br><span class="line">CREATE DATABASE jdbc DEFAULT CHARACTER SET UTF8;</span><br><span class="line">// 2)、切换数据库</span><br><span class="line">USE jdbc;</span><br><span class="line">// 3)、创建数据库表</span><br><span class="line">CREATE TABLE user(</span><br><span class="line">    `user_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">    `user_name` VARCHAR(20) NOT NULL COMMENT &#x27;用户名&#x27;,</span><br><span class="line">    `price` double(10,2) DEFAULT 0.0 COMMENT &#x27;价格&#x27;,</span><br><span class="line">    `create_time` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=UTF8 COMMENT=&quot;用户表&quot;;</span><br></pre></td></tr></table></figure></li>
<li><p>添加用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//①加载数据库驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//②创建数据库连接</span><br><span class="line">Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///jdbc?characterEncoding=utf-8&quot;,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">//③创建Statement对象</span><br><span class="line">Statement statement = conn.createStatement();</span><br><span class="line">//④创建添加SQL语句</span><br><span class="line">String sql=&quot;INSERT INTO user(user_name,price,create_time) VALUES(&#x27;admin&#x27;,100.12,now())&quot;;</span><br><span class="line">//⑤执行sql语句,返回影响行数,如果需要获取主键,要配置Statement.RETURN_GENERATED_KEYS参数</span><br><span class="line">int row = statement.executeUpdate(sql,Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">//⑥打印影响行数</span><br><span class="line">System.out.println(&quot;row:&quot;+row);</span><br><span class="line"></span><br><span class="line">//如果想获取插入用户的主键可以使用statement.getGeneratedKeys()获取</span><br><span class="line"></span><br><span class="line">ResultSet resultSet=statement.getGeneratedKeys();</span><br><span class="line">if(resultSet.next())&#123;</span><br><span class="line">    int id = resultSet.getInt(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>更新用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//①加载数据库驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//②创建数据库连接</span><br><span class="line">Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///jdbc?characterEncoding=utf-8&quot;,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">//③创建Statement对象</span><br><span class="line">Statement statement = conn.createStatement();</span><br><span class="line">//④创建更新SQL语句</span><br><span class="line">String sql=&quot;UPDATE user SET user_name=&#x27;admin1&#x27;,price=12.12,create_time=now() WHERE user_id=100&quot;;</span><br><span class="line">//⑤执行sql语句,返回影响行数</span><br><span class="line">int row = statement.executeUpdate(sql);</span><br><span class="line">//⑥打印影响行数</span><br><span class="line">System.out.println(&quot;row:&quot;+row);</span><br></pre></td></tr></table></figure></li>
<li><p>删除用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//①加载数据库驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//②创建数据库连接</span><br><span class="line">Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///jdbc?characterEncoding=utf-8&quot;,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">//③创建Statement对象</span><br><span class="line">Statement statement = conn.createStatement();</span><br><span class="line">//④创建更新SQL语句</span><br><span class="line">String sql=&quot;DELETE FROM user WHERE user_id=100&quot;;</span><br><span class="line">//⑤执行sql语句,返回影响行数</span><br><span class="line">int row = statement.executeUpdate(sql);</span><br><span class="line">//⑥打印影响行数</span><br><span class="line">System.out.println(&quot;row:&quot;+row);</span><br></pre></td></tr></table></figure></li>
<li><p>查询用户列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建一个集合对象,将从数据库查询出来的数据保存到集合中</span><br><span class="line">List&lt;User&gt; users = new ArrayList&lt;&gt;();</span><br><span class="line">//①加载数据库驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//②创建数据库连接</span><br><span class="line">Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///jdbc?characterEncoding=utf-8&quot;,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">//③创建Statement对象</span><br><span class="line">Statement statement = conn.createStatement();</span><br><span class="line">//④创建SQL语句</span><br><span class="line">String sql=&quot;SELECT * FROM user&quot;;</span><br><span class="line">//⑤执行sql语句,返回结果集对象</span><br><span class="line">ResultSet result = statement.executeQuery(sql);</span><br><span class="line">while(result.next())&#123;</span><br><span class="line">	User user = new User();</span><br><span class="line">	int userId = result.getInt(&quot;user_id&quot;);</span><br><span class="line">	user.setUserId(userId);</span><br><span class="line">	String userName = result.getString(&quot;user_name&quot;);</span><br><span class="line">	user.setUserName(userName);</span><br><span class="line">	double price = result.getDouble(&quot;price&quot;);</span><br><span class="line">	user.setPrice(price);</span><br><span class="line">	Date createTime = result.getDate(&quot;create_time&quot;);</span><br><span class="line">	user.setCreateTime(createTime);</span><br><span class="line">	users.add(user);</span><br><span class="line">&#125;</span><br><span class="line">//打印从数据库查询出来的对象</span><br><span class="line">System.out.println(users);</span><br></pre></td></tr></table></figure></li>
<li><p>查询一个用户(因为JDBC没有提供一个查询单个对象的结果集,所以查询单个对象时也是使用ResultSet对象)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建一个集合对象,将从数据库查询出来的数据保存到集合中</span><br><span class="line">List&lt;User&gt; users = new ArrayList&lt;&gt;();</span><br><span class="line">//①加载数据库驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//②创建数据库连接</span><br><span class="line">Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///jdbc?characterEncoding=utf-8&quot;,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">//③创建Statement对象</span><br><span class="line">Statement statement = conn.createStatement();</span><br><span class="line">//④创建SQL语句</span><br><span class="line">String sql=&quot;SELECT * FROM user&quot;;</span><br><span class="line">//⑤执行sql语句,返回结果集对象</span><br><span class="line">ResultSet result = statement.executeQuery(sql);</span><br><span class="line">if(result.next())&#123;</span><br><span class="line">	User user = new User();</span><br><span class="line">	int userId = result.getInt(&quot;user_id&quot;);</span><br><span class="line">	user.setUserId(userId);</span><br><span class="line">	String userName = result.getString(&quot;user_name&quot;);</span><br><span class="line">	user.setUserName(userName);</span><br><span class="line">	double price = result.getDouble(&quot;price&quot;);</span><br><span class="line">	user.setPrice(price);</span><br><span class="line">	Date createTime = result.getDate(&quot;create_time&quot;);</span><br><span class="line">	user.setCreateTime(createTime);</span><br><span class="line">	users.add(user);</span><br><span class="line">&#125;</span><br><span class="line">//打印从数据库查询出来的对象</span><br><span class="line">System.out.println(users);</span><br></pre></td></tr></table></figure></li>
<li><p>查询数据库总记录数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//①加载数据库驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//②创建数据库连接</span><br><span class="line">Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///jdbc?characterEncoding=utf-8&quot;,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">//③创建Statement对象</span><br><span class="line">Statement statement = conn.createStatement();</span><br><span class="line">//④创建SQL语句</span><br><span class="line">String sql=&quot;SELECT COUNT(*) AS count FROM user&quot;;</span><br><span class="line">//⑤执行sql语句,返回结果集对象</span><br><span class="line">ResultSet result = statement.executeQuery(sql);</span><br><span class="line">if(result.next())&#123;</span><br><span class="line">	int count = result.getInt(&quot;count&quot;);</span><br><span class="line">	System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分页查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MYSQL数据库分页的语法</span><br><span class="line">SELECT * FROM user LIMIT [offset],[max];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MYSQL的SQL语句的语法格式带有两个参数分别是offset和max,而我们前端或者是客户端给后台发送过来的数据为pageNo(当前页)和pageSize(每页显示多少条数),而SQL语句里面的max和我们前端传送过来的pageSize是相同的都是为每页显示的条数。但是offset和pageNo不是相同的所以需要转换。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">转换的公式:</span><br><span class="line">offset=(pageNo-1)*pageSize</span><br></pre></td></tr></table></figure></li>
<li><p>中文乱码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url：jdbc:mysql:///jdbc?characterEncoding=utf-8&amp;useUnicode=true</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第三章-PreparedStatement接口"><a href="#第三章-PreparedStatement接口" class="headerlink" title="第三章 PreparedStatement接口"></a>第三章 PreparedStatement接口</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 它是扩展了Statement的接口(PreparedStatement本身也是接口)</span><br><span class="line">2. 功能比Statement更强大</span><br><span class="line">3. 可以动态地提供/接受参数</span><br><span class="line">4. 创建PreparedStatement对象 --&gt; conn.prepareStatement(通过Connection对象获取)</span><br><span class="line">5. 可以使用占位符(?)来进行数据绑定</span><br><span class="line">6. 通过stmt.setInt(1, 35);绑定参数</span><br></pre></td></tr></table></figure>

<ul>
<li><p>添加用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//①加载数据库驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//②创建数据库连接</span><br><span class="line">Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///jdbc?characterEncoding=utf-8&quot;,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">//③准备sql，带有（?）占位符</span><br><span class="line">String sql=&quot;INSERT INTO user(user_name,price,create_time) VALUES(?,?,?)&quot;;</span><br><span class="line">//④预编译</span><br><span class="line">PreparedStatement prepareStatement = conn.prepareStatement(sql);</span><br><span class="line">//⑤绑定参数(参数的下标从1开始而不是像数组或者集合从0开始)</span><br><span class="line">prepareStatement.setString(1, &quot;admin&quot;);</span><br><span class="line">prepareStatement.setDouble(2, 100.12);</span><br><span class="line">prepareStatement.setDate(3, new Date(new java.util.Date().getTime()));</span><br><span class="line">//⑥执行进行绑定参数之后的sql语句</span><br><span class="line">int row = prepareStatement.executeUpdate();</span><br><span class="line">System.out.println(&quot;row:&quot;+row);</span><br></pre></td></tr></table></figure></li>
<li><p>其余(删改查)操作自己完成</p>
</li>
</ul>
<hr>
<h2 id="第四章-JDBC的事务处理"><a href="#第四章-JDBC的事务处理" class="headerlink" title="第四章 JDBC的事务处理"></a>第四章 JDBC的事务处理</h2><h3 id="第1节-数据库事务简介"><a href="#第1节-数据库事务简介" class="headerlink" title="第1节 数据库事务简介"></a>第1节 数据库事务简介</h3><ul>
<li><p>什么是事务?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务是逻辑上的一组操作,这组操作要么全部成功，有一个失败就全部失败</span><br></pre></td></tr></table></figure></li>
<li><p>事务的特性?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 原子性</span><br><span class="line">2. 一致性</span><br><span class="line">3. 隔离性</span><br><span class="line">4. 永久性</span><br></pre></td></tr></table></figure></li>
<li><p>事务的隔离级别?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 读已提交 -&gt; READ-COMMITTED    -&gt; 防止脏读</span><br><span class="line">2. 读未提交 -&gt; READ-UNCOMMITTED  -&gt; 不能保证数据安全</span><br><span class="line">3. 可重复读 -&gt; REPEATABLE-READ   -&gt; 可以防止脏读和不可重复读</span><br><span class="line">4. 串行化   -&gt; SERIALIZABLE      -&gt; 防止脏读、幻读、不可重复读,但是性能较差</span><br></pre></td></tr></table></figure></li>
<li><p>没有隔离级别产生的问题</p>
</li>
<li><ul>
<li><p>脏读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个事物读取的数据是另一个事物还没有来得及提交的数据，会造成脏读的问题</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>幻读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同一事务中，用同样的操作读取两次，得到的记录数不相同</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>不可重复读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在同一事务中，两次读取同一数据，得到内容不同</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>MYSQL的事务操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. mysql默认的隔离级别 : REPEATABLE-READ</span><br><span class="line">2. oracle默认的隔离级别 : READ-COMMITTED</span><br><span class="line">3. 查询当前mysql事务 : select @@tx_isolation;</span><br><span class="line">4. 修改当前mysql事务 : set tx_isolation=&#x27;REPEATABLE-READ&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第2节-JDBC对事务的操作"><a href="#第2节-JDBC对事务的操作" class="headerlink" title="第2节 JDBC对事务的操作"></a>第2节 JDBC对事务的操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc默认情况下每执行完一条SQL就会提交到数据库一次,因为jdbc默认提交事务的方式是自动提交,但是在正常的业务逻辑下,一个业务正常要执行多条sql语句,如果每执行完一条sql都进行事务提交就很容易出现前后数据不一致的问题,所以要保证这一组的sql语句操作都在一个事务管理中,所以我们要取消JDBC的默认事务提交</span><br><span class="line">1. 使用Connection对象的setAutoCommit()方法关闭他的自动提交</span><br><span class="line">2. 手动提交事务调用connection的commit()方法</span><br><span class="line">3. 事务回滚调用connection的rollback()方法</span><br></pre></td></tr></table></figure>

<h4 id="2-1-JDBC事务代码测试"><a href="#2-1-JDBC事务代码测试" class="headerlink" title="2.1 JDBC事务代码测试"></a>2.1 JDBC事务代码测试</h4><ul>
<li><p>业务介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">转账 : z3给l4转500块钱</span><br></pre></td></tr></table></figure></li>
<li><p>数据库表创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 账户表</span><br><span class="line">CREATE TABLE account(</span><br><span class="line">	account_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &quot;主键&quot;,</span><br><span class="line">	account_name VARCHAR(20) NOT NULL COMMENT &quot;账户名&quot;,</span><br><span class="line">	money double(10,2) DEFAULT 0.0 COMMENT &quot;账户金额&quot;</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=10000  DEFAULT CHARSET=UTF8;</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO account(account_name,money) VALUES(&quot;z3&quot;,1000),(&quot;l4&quot;,1000);</span><br></pre></td></tr></table></figure></li>
<li><p>Java代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test02()  &#123;</span><br><span class="line">	Connection connection = null;</span><br><span class="line">	//执行</span><br><span class="line">	int row1=0;</span><br><span class="line">	int row2=0;</span><br><span class="line">	try &#123;</span><br><span class="line">		//加载数据库驱动</span><br><span class="line">		Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">		//获取数据库连接</span><br><span class="line">		connection = DriverManager.getConnection(&quot;jdbc:mysql:///jdbc?characterEncoding=utf-8&amp;useUnicode=true&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">		</span><br><span class="line">		//取消默认提交</span><br><span class="line">		connection.setAutoCommit(false);</span><br><span class="line">		</span><br><span class="line">		//创建Statement</span><br><span class="line">		Statement statement = connection.createStatement();</span><br><span class="line">		//准备sql语句</span><br><span class="line">		String sql1=&quot;UPDATE account SET money=money-500 WHERE account_name=&#x27;z3&#x27;&quot;;</span><br><span class="line">		String sql2=&quot;UPDATE account SET money=money+500 WHERE account_name=&#x27;l4&#x27;&quot;;</span><br><span class="line">		</span><br><span class="line">		row1 = statement.executeUpdate(sql1);</span><br><span class="line">		//异常</span><br><span class="line">		int i=1/0;</span><br><span class="line">		row2 = statement.executeUpdate(sql2);</span><br><span class="line">		System.out.println(row1);</span><br><span class="line">		System.out.println(row2);</span><br><span class="line">		//手动提交</span><br><span class="line">		connection.commit();</span><br><span class="line">		</span><br><span class="line">	&#125; catch (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">		//事务回滚</span><br><span class="line">		if(null!=connection) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				connection.rollback();</span><br><span class="line">			&#125; catch (SQLException e1) &#123;</span><br><span class="line">				e1.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第五章-JDBC批量处理"><a href="#第五章-JDBC批量处理" class="headerlink" title="第五章 JDBC批量处理"></a>第五章 JDBC批量处理</h2><blockquote>
<p>使用JDBC进行批处理的对象有两个:</p>
<blockquote>
<ol>
<li>Statement</li>
<li>PreparedStatement</li>
</ol>
</blockquote>
</blockquote>
<ul>
<li><p>Statement</p>
</li>
<li><ul>
<li><p>介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①使用Statement对象批量添加要执行的SQL语句,事例如下:</span><br><span class="line"></span><br><span class="line">  statement.addBatch(sql1);</span><br><span class="line">  statement.addBatch(sql2);</span><br><span class="line">  statement.addBatch(sql3);</span><br><span class="line">  statement.addBatch(sql4);</span><br><span class="line">②执行批处理SQL语句：statement.executeBatch();</span><br><span class="line">③清除批处理命令：statement.clearBatch();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">//批量准备SQL</span><br><span class="line">String sql1=&quot;INSERT INTO user(user_name,price,create_time) VALUES(&#x27;AA&#x27;,12.12,NOW())&quot;;</span><br><span class="line">String sql2=&quot;INSERT INTO user(user_name,price,create_time) VALUES(&#x27;BB&#x27;,13.12,NOW())&quot;;</span><br><span class="line">String sql3=&quot;INSERT INTO user(user_name,price,create_time) VALUES(&#x27;CC&#x27;,14.12,NOW())&quot;;</span><br><span class="line">String sql4=&quot;DELETE FROM user WHERE user_id=100&quot;;</span><br><span class="line">//批量添加SQL</span><br><span class="line">statement.addBatch(sql1);</span><br><span class="line">statement.addBatch(sql2);</span><br><span class="line">statement.addBatch(sql3);</span><br><span class="line">statement.addBatch(sql4);</span><br><span class="line">//批量执行</span><br><span class="line">statement.executeBatch();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>PreparedStatement</p>
</li>
<li><ul>
<li><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String sql=&quot;INSERT INTO user(user_name,price,create_time) VALUES(?,?,?)&quot;;</span><br><span class="line">PreparedStatement prepareStatement = connection.prepareStatement(sql);</span><br><span class="line">//绑定参数1</span><br><span class="line">prepareStatement.setString(1, &quot;AA&quot;);</span><br><span class="line">prepareStatement.setDouble(2, 12.12);</span><br><span class="line">prepareStatement.setDate(2, new Date(new java.util.Date().getTime()));</span><br><span class="line">prepareStatement.addBatch();</span><br><span class="line">//绑定参数2</span><br><span class="line">prepareStatement.setString(1, &quot;BB&quot;);</span><br><span class="line">prepareStatement.setDouble(2, 12.12);</span><br><span class="line">prepareStatement.setDate(2, new Date(new java.util.Date().getTime()));</span><br><span class="line">prepareStatement.addBatch();</span><br><span class="line">//执行</span><br><span class="line">prepareStatement.executeBatch();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Statement和PrepareStatement的优缺点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Statement可以添加不同的SQL语句INSERT UPDATE DELETE可以同时进行批处理,但是效率相对较差</span><br><span class="line"></span><br><span class="line">2.PrepareStatement执行同一条SQL不同参数的SQL语句，但是效率相对较高</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第六章-JDBC存储大字段到MYSQL-了解"><a href="#第六章-JDBC存储大字段到MYSQL-了解" class="headerlink" title="第六章 JDBC存储大字段到MYSQL(了解)"></a>第六章 JDBC存储大字段到MYSQL(了解)</h2><h3 id="6-1-大字段介绍"><a href="#6-1-大字段介绍" class="headerlink" title="6.1 大字段介绍"></a>6.1 大字段介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于字段长度要求超过 255 个的情况下，MySQL 提供了 TEXT 和 BLOB 两种类型。根据存储数据的大小，它们都有不同的子类型。这些大型的数据用于存储文本块或图像、声音文件等二进制数据类型</span><br></pre></td></tr></table></figure>

<h3 id="6-2-大字段类型"><a href="#6-2-大字段类型" class="headerlink" title="6.2 大字段类型"></a>6.2 大字段类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4种文本: TINYTEXT(0-255字节)、TEXT(0-65535字节)、MEDIUMTEXT(0-16777215字节) 和 LONGTEXT(0-4294967295字节)</span><br><span class="line">4种二进制: TINYBLOB(0-255字节)、BLOB(0-65535字节)、MEDIUMBLOB(0-16777215字节) 和 LONGBLOB(0-4294967295字节)</span><br></pre></td></tr></table></figure>

<h3 id="6-3-具体使用图示"><a href="#6-3-具体使用图示" class="headerlink" title="6.3 具体使用图示"></a>6.3 具体使用图示</h3><p><a href="https://note.youdao.com/yws/api/personal/file/WEBd10f2cc79dc0dccf7136dd84b3f0056c?method=download&shareKey=e4e9330886254cabda982c96082ea2c6"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBd10f2cc79dc0dccf7136dd84b3f0056c?method=download&shareKey=e4e9330886254cabda982c96082ea2c6" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<h3 id="6-4-大字段的操作"><a href="#6-4-大字段的操作" class="headerlink" title="6.4 大字段的操作"></a>6.4 大字段的操作</h3><ul>
<li><p>创建保存大字段的表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE big_data(</span><br><span class="line">	`id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">	`image` MEDIUMBLOB  COMMENT &#x27;图片&#x27;,</span><br><span class="line">	`article` TEXT NOT NULL COMMENT &#x27;大字段文本&#x27;</span><br><span class="line">)ENGINE=InnoDB DEFAULT CHARSET=UTF8;</span><br></pre></td></tr></table></figure></li>
<li><p>存储图片/文本的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 保存大字段数据</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test01() throws ClassNotFoundException, SQLException, IOException &#123;</span><br><span class="line">	//加载数据库驱动</span><br><span class="line">	Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">	//获取数据库连接</span><br><span class="line">	Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///bigdata?characterEncoding=utf8&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">	//准备sql语句</span><br><span class="line">	String sql=&quot;INSERT INTO user(image,article) VALUES(?,?)&quot;;</span><br><span class="line">	//获取preparedStatement对象</span><br><span class="line">	PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">	//绑定参数</span><br><span class="line">	//获取二进制流</span><br><span class="line">	InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(&quot;mysql.jpg&quot;);</span><br><span class="line">	ps.setBinaryStream(1, inputStream, inputStream.available());</span><br><span class="line">	//获取文本流</span><br><span class="line">	File file = new File(&quot;mysql.sql&quot;);</span><br><span class="line">	FileReader reader = new FileReader(file);</span><br><span class="line">	ps.setCharacterStream(2, reader, file.length());</span><br><span class="line">	ps.executeUpdate();</span><br><span class="line">	ps.close();</span><br><span class="line">	conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>读取图片/文本的例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 查询大字段数据</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test02() throws SQLException, ClassNotFoundException, IOException &#123;</span><br><span class="line">	//加载数据库驱动</span><br><span class="line">	Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">	//获取数据库连接</span><br><span class="line">	Connection conn = DriverManager.getConnection(&quot;jdbc:mysql:///bigdata?characterEncoding=utf8&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">	//准备sql语句</span><br><span class="line">	String sql=&quot;SELECT id,image,article FROM user WHERE id=?&quot;;</span><br><span class="line">	//获取preparedStatement对象</span><br><span class="line">	PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">	ps.setInt(1, 1);</span><br><span class="line">	ResultSet resultSet = ps.executeQuery();</span><br><span class="line">	if(resultSet.next()) &#123;</span><br><span class="line">		InputStream binaryStream = resultSet.getBinaryStream(&quot;image&quot;);</span><br><span class="line">		Reader characterStream = resultSet.getCharacterStream(&quot;article&quot;);</span><br><span class="line">		FileOutputStream outputStream = new FileOutputStream(new File(&quot;1.jpg&quot;));</span><br><span class="line">		byte[] b = new byte[1024];</span><br><span class="line">		int len_=0;</span><br><span class="line">		while((len_=binaryStream.read(b))!=-1) &#123;</span><br><span class="line">			outputStream.write(b, 0, len_);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;=============&quot;);</span><br><span class="line">		char[] c = new char[512];</span><br><span class="line">		int len=0;</span><br><span class="line">		while((len=characterStream.read(c))!=-1) &#123;</span><br><span class="line">			System.out.println(new String(c, 0,len));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第七章-封装JDBC工具类"><a href="#第七章-封装JDBC工具类" class="headerlink" title="第七章 封装JDBC工具类"></a>第七章 封装JDBC工具类</h2><ul>
<li><p>封装获取和关闭数据库连接的工具类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①获取数据库连接</span><br><span class="line">    --加载数据库驱动</span><br><span class="line">    --获取数据库连接</span><br><span class="line">②关闭数据库连接</span><br><span class="line">    --关闭ResultSet</span><br><span class="line">    --关闭PreparedStatement</span><br><span class="line">    --关闭Connection</span><br></pre></td></tr></table></figure></li>
<li><ul>
<li><p>代码(v1.0版本)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class JdbcUtils &#123;</span><br><span class="line">	</span><br><span class="line">	private static final String DRIVER_CLASS = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">	private static final String URL = &quot;jdbc:mysql:///oa&quot;;</span><br><span class="line">	private static final String USER = &quot;root&quot;;</span><br><span class="line">	private static final String PASSWORD = &quot;root&quot;;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 获取数据库连接</span><br><span class="line">	 * @throws SQLException </span><br><span class="line">	 * @throws ClassNotFoundException </span><br><span class="line">	 */</span><br><span class="line">	public static Connection getConnection() throws SQLException, ClassNotFoundException &#123;</span><br><span class="line">		//加载数据库驱动</span><br><span class="line">		Class.forName(DRIVER_CLASS);</span><br><span class="line">		Connection connection = DriverManager.getConnection(URL, USER, PASSWORD);</span><br><span class="line">		return connection;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 关闭数据库连接</span><br><span class="line">	 */</span><br><span class="line">	public static void close(Connection conn) &#123;</span><br><span class="line">		if (conn != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 关闭连接</span><br><span class="line">	 * </span><br><span class="line">	 * @param conn</span><br><span class="line">	 * @param ps</span><br><span class="line">	 */</span><br><span class="line">	public static void close(Connection conn, Statement statement) &#123;</span><br><span class="line">		if (statement != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				statement.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (conn != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 关闭连接</span><br><span class="line">	 * </span><br><span class="line">	 * @param conn</span><br><span class="line">	 * @param ps</span><br><span class="line">	 * @param rs</span><br><span class="line">	 */</span><br><span class="line">	public static void close(Connection conn, Statement statement, ResultSet rs) &#123;</span><br><span class="line">		if (rs != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				rs.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (statement != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				statement.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (conn != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 关闭连接</span><br><span class="line">	 * </span><br><span class="line">	 * @param conn</span><br><span class="line">	 * @param ps</span><br><span class="line">	 */</span><br><span class="line">	public static void close(Connection conn, PreparedStatement ps) &#123;</span><br><span class="line">		if (ps != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				ps.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (conn != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 关闭连接</span><br><span class="line">	 * </span><br><span class="line">	 * @param conn</span><br><span class="line">	 * @param ps</span><br><span class="line">	 * @param rs</span><br><span class="line">	 */</span><br><span class="line">	public static void close(Connection conn, PreparedStatement ps, ResultSet rs) &#123;</span><br><span class="line">		if (rs != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				rs.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ps != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				ps.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (conn != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;</span><br><span class="line">		Connection connection = getConnection();</span><br><span class="line">		System.out.println(connection);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>代码(v2.0版本)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.properties</span><br><span class="line"></span><br><span class="line">driverClass=com.mysql.jdbc.Driver</span><br><span class="line">jdbcUrl=jdbc:mysql://localhost:3306/jdbc?characterEncoding=utf-8</span><br><span class="line">jdbcUser=root</span><br><span class="line">jdbcPassword=root</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class JdbcUtils &#123;</span><br><span class="line">	private static Properties properties = null;</span><br><span class="line">	static &#123;</span><br><span class="line">		//通过类加载器</span><br><span class="line">		InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;);</span><br><span class="line">		properties = new Properties();</span><br><span class="line">		try &#123;</span><br><span class="line">			properties.load(in);</span><br><span class="line">			Class.forName(properties.getProperty(&quot;driverClass&quot;));</span><br><span class="line">		&#125; catch (ClassNotFoundException | IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 获取数据库连接</span><br><span class="line">	 * @throws SQLException </span><br><span class="line">	 */</span><br><span class="line">	public static Connection getConnection() throws SQLException &#123;</span><br><span class="line">		return DriverManager.getConnection(properties.getProperty(&quot;jdbcUrl&quot;), properties.getProperty(&quot;jdbcUser&quot;), properties.getProperty(&quot;jdbcPassword&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 关闭连接</span><br><span class="line">	 */</span><br><span class="line">	public static void close(Connection conn,Statement statement,ResultSet rs) &#123;</span><br><span class="line">		if(conn!=null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(statement!=null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				statement.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(rs!=null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				rs.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void close(Connection conn,Statement statement) &#123;</span><br><span class="line">		if(conn!=null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(statement!=null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				statement.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void close(Connection conn,PreparedStatement ps,ResultSet rs) &#123;</span><br><span class="line">		if(conn!=null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(ps!=null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				ps.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(rs!=null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				rs.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void close(Connection conn,PreparedStatement ps) &#123;</span><br><span class="line">		if(conn!=null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(ps!=null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				ps.close();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>封装操作数据库Dao层的通用类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通用数据库操作类</span><br><span class="line"> */</span><br><span class="line">public class BaseDao&lt;T&gt; &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 通用的增删改</span><br><span class="line">	 */</span><br><span class="line">	public void update(Connection conn,String sql,Object ...args) throws SQLException &#123;</span><br><span class="line">		PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">		//赋值</span><br><span class="line">		if(args!=null &amp;&amp; args.length&gt;0) &#123;</span><br><span class="line">			for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">				ps.setObject(i+1, args[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ps.executeUpdate();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 查询列表</span><br><span class="line">	 * 原生反射</span><br><span class="line">	 */</span><br><span class="line">	public List&lt;T&gt; getList(Connection connection,String sql,Class&lt;T&gt; clazz,Object ...args) throws SQLException, InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException &#123;</span><br><span class="line">		List&lt;T&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">		T t = null;</span><br><span class="line">		//获取PreparedStatement</span><br><span class="line">		PreparedStatement ps = connection.prepareStatement(sql);</span><br><span class="line">		//赋值</span><br><span class="line">		if(args!=null &amp;&amp; args.length&gt;0) &#123;</span><br><span class="line">			for(int i=0;i&lt;args.length;i++) &#123;</span><br><span class="line">				ps.setObject(i+1, args[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//执行</span><br><span class="line">		ResultSet rs = ps.executeQuery();</span><br><span class="line">		//获取数据库表的元数据信息</span><br><span class="line">		ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">		//获取数据库表的列总数</span><br><span class="line">		int columnCount = rsmd.getColumnCount();</span><br><span class="line">		while(rs.next()) &#123;</span><br><span class="line">			//实例化对象</span><br><span class="line">			t=clazz.newInstance();</span><br><span class="line">			//循环获取列名</span><br><span class="line">			for(int i=0;i&lt;columnCount;i++) &#123;</span><br><span class="line">				//通过列的下标获取列名</span><br><span class="line">				String columnLabel = rsmd.getColumnLabel(i+1);</span><br><span class="line">				//通过列标签获取列值</span><br><span class="line">				Object columnValue = rs.getObject(columnLabel);</span><br><span class="line">				//反射通过名称获取java对象中描述属性的对象</span><br><span class="line">				Field field = clazz.getDeclaredField(columnLabel);//dept_id as deptId </span><br><span class="line">				//取消私有权限</span><br><span class="line">				field.setAccessible(true);</span><br><span class="line">				//给属性对象赋值</span><br><span class="line">				field.set(t, columnValue);</span><br><span class="line">			&#125;</span><br><span class="line">			list.add(t);</span><br><span class="line">		&#125;</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 通用查询(单个)</span><br><span class="line">	 * 原生反射</span><br><span class="line">	 */</span><br><span class="line">	public T getT(Connection connection,String sql,Class&lt;T&gt; clazz,Object ...args) throws SQLException, InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException &#123;</span><br><span class="line">		T t = null;</span><br><span class="line">		//获取PreparedStatement</span><br><span class="line">		PreparedStatement ps = connection.prepareStatement(sql);</span><br><span class="line">		//赋值</span><br><span class="line">		if(args!=null &amp;&amp; args.length&gt;0) &#123;</span><br><span class="line">			for(int i=0;i&lt;args.length;i++) &#123;</span><br><span class="line">				ps.setObject(i+1, args[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//执行</span><br><span class="line">		ResultSet rs = ps.executeQuery();</span><br><span class="line">		//获取数据库表的元数据信息</span><br><span class="line">		ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">		//获取数据库表的列总数</span><br><span class="line">		int columnCount = rsmd.getColumnCount();</span><br><span class="line">		if(rs.next()) &#123;</span><br><span class="line">			//实例化对象</span><br><span class="line">			t=clazz.newInstance();</span><br><span class="line">			//循环获取列名</span><br><span class="line">			for(int i=0;i&lt;columnCount;i++) &#123;</span><br><span class="line">				//通过列的下标获取列名</span><br><span class="line">				String columnLabel = rsmd.getColumnLabel(i+1);</span><br><span class="line">				//通过列标签获取列值</span><br><span class="line">				Object columnValue = rs.getObject(columnLabel);</span><br><span class="line">				//反射通过名称获取java对象中描述属性的对象</span><br><span class="line">				Field field = clazz.getDeclaredField(columnLabel);//dept_id as deptId </span><br><span class="line">				//取消私有权限</span><br><span class="line">				field.setAccessible(true);</span><br><span class="line">				//给属性对象赋值</span><br><span class="line">				field.set(t, columnValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 通用查询(单个)</span><br><span class="line">	 * 使用下面工具进行反射赋值</span><br><span class="line">	 * commons-beanutils-1.8.0.jar</span><br><span class="line">	 * commons-logging-1.1.1.jar</span><br><span class="line">	 */</span><br><span class="line">	public T getT_(Connection connection,String sql,Class&lt;T&gt; clazz,Object ...args) throws SQLException, InstantiationException, IllegalAccessException, NoSuchFieldException, SecurityException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line">		T t = null;</span><br><span class="line">		//获取PreparedStatement</span><br><span class="line">		PreparedStatement ps = connection.prepareStatement(sql);</span><br><span class="line">		//赋值</span><br><span class="line">		if(args!=null &amp;&amp; args.length&gt;0) &#123;</span><br><span class="line">			for(int i=0;i&lt;args.length;i++) &#123;</span><br><span class="line">				ps.setObject(i+1, args[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//执行</span><br><span class="line">		ResultSet rs = ps.executeQuery();</span><br><span class="line">		//获取数据库表的元数据信息</span><br><span class="line">		ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">		//获取数据库表的列总数</span><br><span class="line">		int columnCount = rsmd.getColumnCount();</span><br><span class="line">		if(rs.next()) &#123;</span><br><span class="line">			//实例化对象</span><br><span class="line">			t=clazz.newInstance();</span><br><span class="line">			//循环获取列名</span><br><span class="line">			for(int i=0;i&lt;columnCount;i++) &#123;</span><br><span class="line">				//通过列的下标获取列名</span><br><span class="line">				String columnLabel = rsmd.getColumnLabel(i+1);</span><br><span class="line">				//通过列标签获取列值</span><br><span class="line">				Object columnValue = rs.getObject(columnLabel);</span><br><span class="line">				//反射通过名称获取java对象中描述属性的对象</span><br><span class="line">				//Field field = clazz.getDeclaredField(columnLabel);//dept_id as deptId </span><br><span class="line">				//取消私有权限</span><br><span class="line">				//field.setAccessible(true);</span><br><span class="line">				//给属性对象赋值</span><br><span class="line">				//field.set(t, columnValue);</span><br><span class="line">				PropertyUtils.setProperty(t, columnLabel, columnValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第八章-数据库连接池"><a href="#第八章-数据库连接池" class="headerlink" title="第八章 数据库连接池"></a>第八章 数据库连接池</h2><h3 id="8-1-连接池介绍"><a href="#8-1-连接池介绍" class="headerlink" title="8.1 连接池介绍"></a>8.1 连接池介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库连接池的概念：负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个连接来操作数据库.</span><br></pre></td></tr></table></figure>

<h3 id="8-2-常见连接池"><a href="#8-2-常见连接池" class="headerlink" title="8.2 常见连接池"></a>8.2 常见连接池</h3><ul>
<li><p>C3P0:比较古老的数据库连接池</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网地址: https://www.mchange.com/projects/c3p0/</span><br><span class="line"></span><br><span class="line">C3P0提供了多种创建数据库连接的方式,根据官网任选其一即可</span><br></pre></td></tr></table></figure></li>
<li><p>Druid:alibaba的基于Java的高效的数据库连接池</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网地址: https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98</span><br></pre></td></tr></table></figure>

<h3 id="8-3-C3P0连接池使用-API调用"><a href="#8-3-C3P0连接池使用-API调用" class="headerlink" title="8.3 C3P0连接池使用(API调用)"></a>8.3 C3P0连接池使用(API调用)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ComboPooledDataSource pool = new ComboPooledDataSource();</span><br><span class="line">pool.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">pool.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/jdbc&quot;);</span><br><span class="line">pool.setUser(&quot;root&quot;);</span><br><span class="line">pool.setPassword(&quot;root&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="8-4-Druid-ˈdruːɪd-连接池使用-API调用"><a href="#8-4-Druid-ˈdruːɪd-连接池使用-API调用" class="headerlink" title="8.4 Druid[ˈdruːɪd]连接池使用(API调用)"></a>8.4 Druid[ˈdruːɪd]连接池使用(API调用)</h3></li>
<li><p>Druid的API介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. DruidDataSource : 创建数据库连接池的核心类(通过new对象创建Druid的数据库连接池)</span><br><span class="line">2. getConnection   : 获取数据库连接池的方法(通过DruidDataSource对象获取数据库连接)</span><br><span class="line">3. DruidDataSourceFactory : 通过工厂类获取DruidDataSource对象(是获取DruidDataSource对象的另一种方式)</span><br></pre></td></tr></table></figure></li>
<li><p>Druid的使用</p>
</li>
<li><ul>
<li><p>方式一(直接创建DruidDataSource对象方式)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建Druid的核心连接池对象DruidDataSource</span><br><span class="line">DruidDataSource ds = new DruidDataSource();</span><br><span class="line">//设置初始化参数</span><br><span class="line">ds.setUrl(URL);</span><br><span class="line">ds.setUsername(USER); </span><br><span class="line">ds.setPassword(PASSWORD);</span><br><span class="line">ds.setDriverClassName(DRIVER_CLASS);</span><br><span class="line">Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>方式二(使用DruidDataSourceFactory工厂类获取DruidDataSource对象)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.properties</span><br><span class="line"></span><br><span class="line">url=jdbc:mysql:///oa</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">注意: properties文件的key值必须是以上的key值(可以通过源码解析进行讲解)</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">//听过加载外部配置文件的方式</span><br><span class="line">Properties p = new Properties();</span><br><span class="line">p.load(JdbcUtils.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;));</span><br><span class="line">//采用Druid提供的工厂类创建DruidDataSource对象</span><br><span class="line">DataSource dataSource = DruidDataSourceFactory.createDataSource(p);</span><br><span class="line">Connection conn = dataSource.getConnection();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="第九章-DBUtils工具类"><a href="#第九章-DBUtils工具类" class="headerlink" title="第九章 DBUtils工具类"></a>第九章 DBUtils工具类</h2><h3 id="9-1-DBUtils介绍"><a href="#9-1-DBUtils介绍" class="headerlink" title="9.1 DBUtils介绍"></a>9.1 DBUtils介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DBUtils是apache的一个组件,算是一个轻量级的JDBC框架,官网地址</span><br><span class="line"></span><br><span class="line">https://commons.apache.org/proper/commons-dbutils/</span><br><span class="line"></span><br><span class="line">DbUtils是一个非常小的类库，不需要花很长的时间去看他的API类或者是接口，只需要知道QueryRunner和ReulthSthand两个/接口类即可</span><br></pre></td></tr></table></figure>

<h3 id="9-2-DBUtils使用"><a href="#9-2-DBUtils使用" class="headerlink" title="9.2 DBUtils使用"></a>9.2 DBUtils使用</h3><ul>
<li><p>通过BeanHandler查询一个ResultSet返回一个JavaBean对象(查询单个对象)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QueryRunner run = new QueryRunner(dataSource);</span><br><span class="line"></span><br><span class="line">ResultSetHandler&lt;Person&gt; h = new BeanHandler&lt;Person&gt;(Person.class);</span><br><span class="line"></span><br><span class="line">Person p = run.query(&quot;SELECT * FROM Person WHERE name=?&quot;, h, &quot;John Doe&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>通过BeanListHandler查询所有的ResultSet返回一组JavaBean列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QueryRunner run = new QueryRunner(dataSource);</span><br><span class="line"></span><br><span class="line">ResultSetHandler&lt;List&lt;Person&gt;&gt; h = new BeanListHandler&lt;Person&gt;(Person.class);</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; persons = run.query(&quot;SELECT * FROM Person&quot;, h);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第十章-多线程安全问题"><a href="#第十章-多线程安全问题" class="headerlink" title="第十章 多线程安全问题"></a>第十章 多线程安全问题</h2><p><a href="https://note.youdao.com/yws/api/personal/file/WEB48ea58239b8b65384853a621e21598fb?method=download&shareKey=9abcc32dd1ad3c5f41d589896aa84fd6"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB48ea58239b8b65384853a621e21598fb?method=download&shareKey=9abcc32dd1ad3c5f41d589896aa84fd6" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多线程安全问题产生的原因</span><br><span class="line">1. 一个业务请求中执行的多条sql不能保证在同一个连接或者同一个事物管理中</span><br><span class="line">2. 多用户操作时，可能发生当前业务中的一条sql语句已经出错，进行了回滚,而另一条sql语句却被别的连接提交.</span><br><span class="line"></span><br><span class="line">解决方案: 主要是怎么保证一个线程内的所有被执行的SQL语句都是用的是同一个数据库连接(Connection),是解决问题的关键。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解决方案</p>
</li>
<li><ul>
<li><p>ThreadLocal简介</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 通过JDK的API文档了解ThreadLocal这个类</span><br><span class="line">2. 通过文档可以得出此对象可以保存线程中产生的局部变量</span><br><span class="line">3. 并且可以将这些局部变量与响应的线程相关联</span><br><span class="line">4. 在线程消失之后，其线程局部实例的所有副本都会被垃圾回收</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li>ThreadLocal的API</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">返回值类型</th>
<th align="left">方法名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T</td>
<td align="left">get()</td>
<td align="left">返回此线程局部变量的当前线程副本中的值</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">remove()</td>
<td align="left">移除此线程局部变量当前线程的值</td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">set(T value)</td>
<td align="left">将此线程局部变量的当前线程副本中的值设置为指定值</td>
</tr>
</tbody></table>
<ul>
<li><ul>
<li><p>实例代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class JdbcUtil &#123;</span><br><span class="line">	private static ThreadLocal&lt;Connection&gt; pool = new ThreadLocal&lt;&gt;();</span><br><span class="line">	/**</span><br><span class="line">	 * 获取当前请求线程上的Connection</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public static Connection getConnection() &#123;</span><br><span class="line">		Connection conn = pool.get();</span><br><span class="line">		if(conn==null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">				conn = DriverManager.getConnection(&quot;&quot;, &quot;&quot;, &quot;&quot;);</span><br><span class="line">				pool.set(conn);</span><br><span class="line">			&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; catch (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return conn;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 关闭当前请求线程上的Connection</span><br><span class="line">	 */</span><br><span class="line">	public static void close()&#123;</span><br><span class="line">	    Connection conn = pool.get();</span><br><span class="line">	    conn.close();//关闭连接</span><br><span class="line">	    pool.remove();//要将关闭之后的连接移除</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>1. </p>
]]></content>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2021/08/08/Redis/</url>
    <content><![CDATA[<h2 id="第一章-redis简介"><a href="#第一章-redis简介" class="headerlink" title="第一章 redis简介"></a>第一章 redis简介</h2><h3 id="第1节-NoSQL"><a href="#第1节-NoSQL" class="headerlink" title="第1节 NoSQL"></a>第1节 NoSQL</h3><h4 id="1-1-NoSQL简介"><a href="#1-1-NoSQL简介" class="headerlink" title="1.1 NoSQL简介"></a>1.1 NoSQL简介</h4><p>NoSQL，泛指非关系型的数据库，NoSQL即Not-Only SQL，它可以作为关系型数据库的良好补充。随着互联网web2.0网站的兴起，非关系型的数据库现在成了一个极其热门的新领域，非关系数据库产品的发展非常迅速。</p>
<h4 id="1-2-NoSQL类别"><a href="#1-2-NoSQL类别" class="headerlink" title="1.2 NoSQL类别"></a>1.2 NoSQL类别</h4><ul>
<li><p>键值(Key-Value)存储数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相关产品: Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</span><br><span class="line">典型应用: 内容缓存，主要用于处理大量数据的高访问负载</span><br><span class="line">数据模型: 一系列键值对</span><br><span class="line">优势: 快速查询</span><br><span class="line">劣势: 存储的数据缺少结构化</span><br></pre></td></tr></table></figure></li>
<li><p>列存储数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相关产品:Cassandra, HBase, Riak 典型应用:分布式的文件系统 </span><br><span class="line">数据模型:以列簇式存储，将同一列数据存在一起 </span><br><span class="line">优势:查找速度快，可扩展性强，更容易进行分布式扩展</span><br><span class="line">劣势:功能相对局限</span><br></pre></td></tr></table></figure></li>
<li><p>文档型数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相关产品:CouchDB、MongoDB </span><br><span class="line">典型应用:Web应用(与Key-Value类似，Value是结构化的) </span><br><span class="line">数据模型: 一系列键值对</span><br><span class="line">优势:数据结构要求不严格</span><br><span class="line">劣势:查询性能不高，而且缺乏统一的查询语法</span><br></pre></td></tr></table></figure></li>
<li><p>图形(Graph)数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相关数据库:Neo4J、InfoGrid、Infinite Graph 典型应用:社交网络</span><br><span class="line">数据模型:图结构</span><br><span class="line">优势:利用图结构相关算法</span><br><span class="line">劣势:需要对整个图做计算才能得出结果，不容易做分布式的集群方案</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-3-redis简介"><a href="#1-3-redis简介" class="headerlink" title="1.3 redis简介"></a>1.3 redis简介</h4><p>2008年，意大利的一家创业公司Merzia推出了一款基于MySQL的网站实时统计系统LLOOGG，然而没过多久该公司的创始人 Salvatore Sanfilippo(萨尔瓦托桑菲利波)便对MySQL的性能感到失望，于是他决定亲自为LLOOGG量身定做一个数据库，并于2009年开发完 成，这个数据库就是Redis。不过Salvatore Sanfilippo并不满足只将Redis用于LLOOGG这一款产品，而是希望更多的人使用它，于是在同一年Salvatore Sanfilippo将Redis开源发布，并开始和Redis的另一名主要的代码贡献者Pieter Noordhuis(皮耶特诺德休斯)一起继续着Redis的开发，直到今天。</p>
<h4 id="1-4-redis支持的数据类型"><a href="#1-4-redis支持的数据类型" class="headerlink" title="1.4 redis支持的数据类型"></a>1.4 redis支持的数据类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis是用C语言开发的一个开源的高性能键值对(key-value)数据库。它通过提供多种键值数据类型来适应不同场景下的 存储需求，目前为止Redis支持的键值数据类型如下:</span><br><span class="line">  </span><br><span class="line">  String（字符串）</span><br><span class="line">  Hash（哈希，类似java里的Map）</span><br><span class="line">  List(列表)</span><br><span class="line">  Set（集合）</span><br><span class="line">  zset(sorted set：有序集合)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h4 id="1-5-redis特点"><a href="#1-5-redis特点" class="headerlink" title="1.5 redis特点"></a>1.5 redis特点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis 与其他 key - value 缓存产品有以下三个特点:</span><br><span class="line">- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</span><br><span class="line">- Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 </span><br><span class="line">- Redis支持数据的备份，即master-slave模式的数据备份。</span><br><span class="line">Redis 提供的API支持:C、C++、C#、Clojure、Java、JavaScript、Lua、PHP、Python、Ruby、Go、Scala、 Perl等多种语言</span><br></pre></td></tr></table></figure>

<h4 id="1-6-redis使用场景"><a href="#1-6-redis使用场景" class="headerlink" title="1.6 redis使用场景"></a>1.6 redis使用场景</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、缓存</span><br><span class="line">缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提</span><br><span class="line">升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也</span><br><span class="line">提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。</span><br><span class="line"></span><br><span class="line">2、排行榜</span><br><span class="line">很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行</span><br><span class="line">榜等。Redis提供的有序集合数据类构能实现各 种复杂的排行榜应用</span><br><span class="line"></span><br><span class="line">3、计数器</span><br><span class="line">什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保</span><br><span class="line">证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无</span><br><span class="line">疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性</span><br><span class="line">能非常好，非常适 用于这些计数场景。</span><br><span class="line"></span><br><span class="line">等等....</span><br></pre></td></tr></table></figure>

<h4 id="1-7-redis的优缺点"><a href="#1-7-redis的优缺点" class="headerlink" title="1.7 redis的优缺点"></a>1.7 redis的优缺点</h4><ul>
<li><p>优点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s</span><br><span class="line">丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets </span><br><span class="line">及 Ordered Sets 数据类型操作</span><br><span class="line">原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行(事务)</span><br><span class="line">丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性</span><br></pre></td></tr></table></figure></li>
<li><p>缺点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(一)缓存和数据库双写一致性问题</span><br><span class="line">分析:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。</span><br><span class="line">数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个</span><br><span class="line">前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只</span><br><span class="line">能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说降低</span><br><span class="line">不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放</span><br><span class="line">缓存</span><br><span class="line">回答:《分布式之数据库和缓存双写一致性方案解析》给出了详细的分析，在</span><br><span class="line">这里简单的说一说。首先，采取正确更新策略，先更新数据库，再删缓存。</span><br><span class="line">其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利</span><br><span class="line">用消息队列.</span><br><span class="line"></span><br><span class="line">(二)缓存雪崩问题、缓存穿透</span><br><span class="line">分析:这两个问题,一般中小型传统软件企业,很难碰到这个问题。如果有大</span><br><span class="line">并发的项目,日流量有KW级上。这两个问题一定要深刻考虑。缓存穿透,即</span><br><span class="line">黑客故意去请求缓存中不存在的数据,导致所有的请求都怼到数据库上,从</span><br><span class="line">而数据库连接异常.</span><br></pre></td></tr></table></figure>

<h4 id="1-8-redis面向互联网的解决方案"><a href="#1-8-redis面向互联网的解决方案" class="headerlink" title="1.8 redis面向互联网的解决方案"></a>1.8 redis面向互联网的解决方案</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 主从:一主多从，主机可写，从机备份。类似于Mysql的读写分离，存在问</span><br><span class="line">题是一但主节点down掉，整个Redis不可用</span><br><span class="line">- 哨兵(2.x):启用一个哨兵程序(节点)，监控其余节点的状态，根据选举策</span><br><span class="line">略，进行主从切换。缺点:每个节点的数据依旧是一致的，仍无法实现分布式</span><br><span class="line">的数据库</span><br><span class="line">- 集群(3.x):结合上述两种模式，多主多从，实现高可用、分布式数据存储(</span><br><span class="line">绝大部分的使用集群)</span><br></pre></td></tr></table></figure>

<h2 id="第二章-redis单机安装-linux"><a href="#第二章-redis单机安装-linux" class="headerlink" title="第二章 redis单机安装(linux)"></a>第二章 redis单机安装(linux)</h2></li>
</ul>
<h3 id="第1节-在linux安装"><a href="#第1节-在linux安装" class="headerlink" title="第1节 在linux安装"></a>第1节 在linux安装</h3><blockquote>
<p>第1步: 使用 wget 命令获取redis安装包</p>
<blockquote>
<p>wget <a href="http://download.redis.io/releases/redis-5.0.0.tar.gz">http://download.redis.io/releases/redis-5.0.0.tar.gz</a></p>
<p>如果wget命令不存在使用此命令安装 yum install wget</p>
</blockquote>
<p>第2步: 将下载的安装包解压到指定的位置 比如 /opt文件夹下</p>
<blockquote>
<p>tar -xzvf redis-5.0.0.tar.gz -C /opt</p>
</blockquote>
<p>第3步: 切换到解压之后的redis文件夹内，然后执行编译命令</p>
<blockquote>
<p>make</p>
<p>如果报没有gcc编译器使用此命令安装gcc编译器 yum install gcc</p>
</blockquote>
<p>第4步: 指定安装位置（将redis安装到/usr/local/redis目录下，方便我们以后查找）</p>
<blockquote>
<p>make install PREFIX=/usr/local/redis</p>
</blockquote>
<p>第5步: 拷贝安装目录下配置文件到 /usr/local/redis/etc</p>
<blockquote>
<p>mkdir /usr/local/redis/etc/ 创建etc文件夹<br>cp /opt/redis-5.0.0/redis.conf /usr/local/redis/etc/ 将redis配置文件拷贝到我们自己定义的文件夹下方便查找</p>
</blockquote>
<p>第6步: 修改配置文件 /usr/local/redis/etc/redis.conf</p>
<blockquote>
<p>vim /usr/local/redis/etc/redis.conf</p>
<p>如果vim命令不存在可以使用此命令安装<br>yum -y install vim*<br>yum install vim</p>
<p>配置文件简答修改:</p>
<p>1、 protected-mode : yes/no 关闭保护模式(如果不关闭保护模式,外部机器访问此redis服务器时,必须指定bind属性绑定的主机才能访问) 外部网络可以直接访问</p>
<p>2、daemonize: no/yes 开启守护进程(开启守护进程redis可以后台运行)</p>
<p>3、bind 127.0.0.1：绑定本机ip,当保护模式关闭以后可以不用指定具体主机IP,但是设置为 0.0.0.0</p>
<p>4、pidfile /var/run/redis_6379.pid redis进程文件，当开启守护进程之后会在本地生成一个pid文件</p>
<p>5、logfile /var/log/redis_6379.log 配置redis服务器日志生成和保存位置</p>
<p>6、dir /usr/local/redis/data/ 快照数据存放目录</p>
</blockquote>
<p>第7步: 启动redis服务器</p>
<blockquote>
<p>redis启动命令在我们的安装目录下,当我们使用make install PREFIX=/usr/local/redis命令进行安装时</p>
<p>将redis安装到了/usr/local/redis目录下,在此目录下会自动生成一个bin目录,启动redis的脚本在这个目录下</p>
<p>启动命令: /usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf</p>
<p>ps aux | grep redis 命令查看redis服务器是否启动</p>
</blockquote>
<p>第8步: 连接适应redis自带的客户端连接redis服务器</p>
<blockquote>
<p>进入到我们redis安装目录下的bin目录,找到我们redis启动脚本</p>
<p>启动redis服务器使用 redis-server脚本</p>
<p>使用redis客户端连接redis服务器采用redis-cli脚本</p>
<p>连接方式: ./redis-cli -h 127.0.0.1 -p 6379</p>
<p>-h : 指定连接redis服务器主机地址</p>
<p>-p : 指定连接应用(redis服务器应用)的端口号</p>
</blockquote>
</blockquote>
<h2 id="第三章-redis常用命令"><a href="#第三章-redis常用命令" class="headerlink" title="第三章 redis常用命令"></a>第三章 redis常用命令</h2><h3 id="第1节-字符串-String"><a href="#第1节-字符串-String" class="headerlink" title="第1节 字符串(String)"></a>第1节 字符串(String)</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">set key value</td>
<td align="left">想redis服务器中设置一个字符串</td>
<td align="left">set key01 value01</td>
</tr>
<tr>
<td align="left">get key</td>
<td align="left">通过key指从服务器中获取值</td>
<td align="left">get key01</td>
</tr>
<tr>
<td align="left">del key</td>
<td align="left">删除指定的key</td>
<td align="left">del key01</td>
</tr>
<tr>
<td align="left">getset key value</td>
<td align="left">给指定的key赋值,并且返回旧值</td>
<td align="left">getset key01 value02</td>
</tr>
<tr>
<td align="left">mset key01 value01 key02 value02</td>
<td align="left">同时设置一个或多个 key-value 对</td>
<td align="left">mset key04 value04 key05 value05 key06 value06</td>
</tr>
<tr>
<td align="left">mget key01 key02 …</td>
<td align="left">获取多个key值</td>
<td align="left">mget key01 key02</td>
</tr>
<tr>
<td align="left">setnx key value</td>
<td align="left">给不存在的key赋值,如果存在赋值失败</td>
<td align="left">setnx key03 value03</td>
</tr>
<tr>
<td align="left">msetnx key01 value01 key02 value02</td>
<td align="left">同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在，如果有一个key存在，那么存储失败</td>
<td align="left">msetnx key04 value04 key07 value07</td>
</tr>
<tr>
<td align="left">setex key [时间以秒为单位] value</td>
<td align="left">给数据设置超时时间,如果key存在就覆盖</td>
<td align="left">setex key04 10 value04</td>
</tr>
<tr>
<td align="left">psetex key07 [毫秒值] value07</td>
<td align="left">给数据设置超时时间,如果key存在就覆盖</td>
<td align="left">psetex key07 10000 value07</td>
</tr>
<tr>
<td align="left">strlen key</td>
<td align="left">获取指定字符串的长度</td>
<td align="left">strlen key06</td>
</tr>
</tbody></table>
<h3 id="第2节-哈希-Hash"><a href="#第2节-哈希-Hash" class="headerlink" title="第2节 哈希(Hash)"></a>第2节 哈希(Hash)</h3><blockquote>
<p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象</p>
<p>Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hset hashname filed value</td>
<td align="left">hset:设值命令;hashname:集合名称;field:集合中的属性名;value:集合中的属性值</td>
<td align="left">hset myhash hkey01 hvalue01</td>
</tr>
<tr>
<td align="left">hget hashname filed</td>
<td align="left">hget:获取值命令;hashname:获取哪一个hash集合;field:获取哪一个hash集合中的属性</td>
<td align="left">hget myhash hkey01</td>
</tr>
<tr>
<td align="left">hdel hashname filed1 [filed2]</td>
<td align="left">删除一个或多个哈希表字段</td>
<td align="left">hdel myhash hkey01 hkey02</td>
</tr>
<tr>
<td align="left">hexists hashname filed</td>
<td align="left">查看指定哈希表中，指定的字段是否存在</td>
<td align="left">hexists myhash hkey01</td>
</tr>
<tr>
<td align="left">hgetall hashname</td>
<td align="left">获取指定哈希表中所有字段和值</td>
<td align="left">hgetall myhash</td>
</tr>
<tr>
<td align="left">hkeys hashname</td>
<td align="left">获取指定hash表中的所有field</td>
<td align="left">hkeys myhash</td>
</tr>
<tr>
<td align="left">hlen hashname</td>
<td align="left">获取哈希表中字段的数量</td>
<td align="left">hlen myhash</td>
</tr>
<tr>
<td align="left">hmget hashname filed1 filed2 filed3</td>
<td align="left">获取所有给定字段的值</td>
<td align="left">hmget myhash hkey01 hkey02 hkey03</td>
</tr>
<tr>
<td align="left">hmset hashname filed1 hvalue1 hkey2 hvalue2</td>
<td align="left">同时将多个 field-value 设置到哈希表中</td>
<td align="left">hmset myhash hkey03 hvalue03 hkey04 hvalue04 hkey05 hvalue05</td>
</tr>
<tr>
<td align="left">hsetnx hashname filed value</td>
<td align="left">只有在字段 field 不存在时，设置哈希表字段的值</td>
<td align="left">hsetnx myhash hkey03 hvalue03</td>
</tr>
<tr>
<td align="left">hvals hashname</td>
<td align="left">获取哈希表中所有值</td>
<td align="left">hvals myhash</td>
</tr>
</tbody></table>
<h3 id="第3节-列表-List"><a href="#第3节-列表-List" class="headerlink" title="第3节 列表(List)"></a>第3节 列表(List)</h3><blockquote>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）,一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">lpush key value [value …]</td>
<td align="left">将一个或多个值插入到列表头部</td>
<td align="left">lpush mylist lvalue01</td>
</tr>
<tr>
<td align="left">lpushx key value</td>
<td align="left">将一个值插入到已存在的列表头部</td>
<td align="left">lpushx mylist value03</td>
</tr>
<tr>
<td align="left">lset key index value</td>
<td align="left">通过索引设置列表元素的值</td>
<td align="left">lset mylist 0 lvalue001</td>
</tr>
<tr>
<td align="left">rpushx key value</td>
<td align="left">为已存在的列表添加值</td>
<td align="left">rpushx mylist lvalue03</td>
</tr>
<tr>
<td align="left">rpushx key value1 value2[value…]</td>
<td align="left">在列表中添加一个或多个值</td>
<td align="left">rpush mylist lvalue04 lvalue05</td>
</tr>
<tr>
<td align="left">blpop key01 key02 100</td>
<td align="left">移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
<td align="left">blpop mylist 100</td>
</tr>
<tr>
<td align="left">brpop key01 key02 100</td>
<td align="left">移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
<td align="left">brpop mylist 200</td>
</tr>
<tr>
<td align="left">lindex key index</td>
<td align="left">通过索引获取列表中的元素</td>
<td align="left">lindex mylist 1</td>
</tr>
<tr>
<td align="left">llen key</td>
<td align="left">获取列表长度</td>
<td align="left">llen mylist</td>
</tr>
<tr>
<td align="left">lpop key</td>
<td align="left">移出并获取列表的第一个元素</td>
<td align="left">lpop mylist</td>
</tr>
<tr>
<td align="left">rpop key</td>
<td align="left">移除列表的最后一个元素，返回值为移除的元素</td>
<td align="left">rpop mylist</td>
</tr>
</tbody></table>
<h3 id="第4节-集合-Set"><a href="#第4节-集合-Set" class="headerlink" title="第4节 集合(Set)"></a>第4节 集合(Set)</h3><blockquote>
<p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sadd key value[value…]</td>
<td align="left">向集合添加一个或多个成员</td>
<td align="left">sadd myset1 myvalue01 myvalue02</td>
</tr>
<tr>
<td align="left">scard key</td>
<td align="left">获取集合的成员数</td>
<td align="left">scard myset1</td>
</tr>
<tr>
<td align="left">sinter key1 key2</td>
<td align="left">返回给定所有集合的交集</td>
<td align="left">sinter myset1 myset2</td>
</tr>
<tr>
<td align="left">sismember key member</td>
<td align="left">判断 member 元素是否是集合 key 的成员</td>
<td align="left">sismember myset1 myvalue01</td>
</tr>
<tr>
<td align="left">smembers key</td>
<td align="left">返回集合中的所有成员</td>
<td align="left">smembers myset1</td>
</tr>
<tr>
<td align="left">srem key value</td>
<td align="left">移除集合中一个或多个成员</td>
<td align="left">srem myset2 myvalue01</td>
</tr>
<tr>
<td align="left">sunion key1 key2</td>
<td align="left">返回所有给定集合的并集</td>
<td align="left">sunion myset1 myset2</td>
</tr>
</tbody></table>
<h3 id="第5节-有序集合-sorted-set"><a href="#第5节-有序集合-sorted-set" class="headerlink" title="第5节 有序集合(sorted set)"></a>第5节 有序集合(sorted set)</h3><blockquote>
<p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复</p>
<p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ZADD key score1 zvalue01 score2 zvalue02</td>
<td align="left">向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
<td align="left">ZADD zset 1 zvalue01 2 zvalue02</td>
</tr>
<tr>
<td align="left">ZCARD key</td>
<td align="left">获取有序集合的成员数</td>
<td align="left">ZCARD zset</td>
</tr>
<tr>
<td align="left">ZRANK key member</td>
<td align="left">返回有序集合中指定成员的索引</td>
<td align="left">ZRANK zset zvalue02</td>
</tr>
<tr>
<td align="left">ZREM key member [member …]</td>
<td align="left">移除有序集合中的一个或多个成员</td>
<td align="left">ZREM zset zvalue02</td>
</tr>
<tr>
<td align="left">ZSCORE key member</td>
<td align="left">返回有序集中，成员的分数值</td>
<td align="left">ZSCORE zset zvalue01</td>
</tr>
<tr>
<td align="left">ZRANGE key start stop [WITHSCORES]</td>
<td align="left">通过索引区间返回有序集合指定区间内的成员</td>
<td align="left">ZRANGE zset 0 -1 WITHSCORES</td>
</tr>
</tbody></table>
<h3 id="第6节-Redis-HyperLogLog"><a href="#第6节-Redis-HyperLogLog" class="headerlink" title="第6节 Redis HyperLogLog"></a>第6节 Redis HyperLogLog</h3><blockquote>
<p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比</p>
</blockquote>
<h4 id="6-1-什么是基数"><a href="#6-1-什么是基数" class="headerlink" title="6.1 什么是基数"></a>6.1 什么是基数</h4><blockquote>
<p>在数学上，基数（cardinal number）是集合论中刻画任意集合大小的一个概念 (集合长度)</p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PFADD key element [element …]</td>
<td align="left">添加指定元素到 HyperLogLog 中</td>
<td align="left">PFADD ploglog a b c d</td>
</tr>
<tr>
<td align="left">PFCOUNT key [key …]</td>
<td align="left">返回给定 HyperLogLog 的基数估算值</td>
<td align="left">PFCOUNT ploglog</td>
</tr>
<tr>
<td align="left">PFMERGE destkey sourcekey [sourcekey …]</td>
<td align="left">将多个 HyperLogLog 合并为一个 HyperLogLog</td>
<td align="left">PFMERGE hll3 hll1 hll2</td>
</tr>
</tbody></table>
<h3 id="第七节-持久化"><a href="#第七节-持久化" class="headerlink" title="第七节 持久化"></a>第七节 持久化</h3><h4 id="7-1-RDB"><a href="#7-1-RDB" class="headerlink" title="7.1 RDB"></a>7.1 RDB</h4><blockquote>
<p>定义：在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是的Snapshot快照，它恢复时是将快照文件直接读到内存里<br>优势:适合大规模的数据恢复<br>对数据完整性和一致性要求不高<br>劣势：在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</p>
</blockquote>
<h4 id="7-2-AOF"><a href="#7-2-AOF" class="headerlink" title="7.2 AOF"></a>7.2 AOF</h4><blockquote>
<p>以日志的形式来记录每个写操作,将Redis执行过的所有写指令记录下来(读操作不记录),只许追加文件但不可以改写文件,redis启动之初会读取该文件重新构建数据,换言之,redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作<br>优势:每修改同步：appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘<br>性能较差但数据完整性比较好每秒同步：appendfsync everysec异步操作，每秒记录 如果一秒内宕机，有数据丢失不同步：appendfsync no   从不同步<br>劣势:相同数据集的数据而言aof文件要远大于rdb文件,恢复速度慢于rdbAof运行效率要慢于rdb,每秒同步策略效率较好,不同步效率和rdb相同</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.   RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</span><br><span class="line"></span><br><span class="line">2.   AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复</span><br><span class="line">     原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</span><br><span class="line"></span><br><span class="line">3.  只做缓存:如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</span><br><span class="line"></span><br><span class="line">4.同时开启两种持久化方式(官方建议)</span><br><span class="line">    在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整</span><br><span class="line">    RDB的数据不实时,同时使用两者时服务器重启也只会找AOF文件.那要不要只使用AOF呢？作者建议不要,因为RDB更适合用于备份数据库(AOF在不断变化不好备份),快速重启，而且不会有AOF可能潜在的bug,留着作为一个万一的手段.</span><br><span class="line"></span><br><span class="line">5.性能建议</span><br><span class="line">      因为RDB文件只用作后备用途,建议只在Slave上持久化RDB文件,而且只要15分钟备份一次就够了,只保留save 900 1 这条规则。</span><br><span class="line">      如果Enalbe AOF,好处是在最恶劣情况下也只会丢失不超过两秒数据,启动脚本较简单只load自己的AOF文件就可以了.代价一是带来了持续的IO,二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的.只要硬盘许可，应该尽量减少AOF rewrite的频率,AOF重写的基础大小默认值64M太小了,可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值.</span><br><span class="line">      如果不Enable AOF,仅靠Master-Slave Replication 实现高可用性也可以.能省掉一大笔IO也减少了rewrite时带来的系统波.代价是如果Master/Slave同时倒掉,会丢失十几分钟的数据,启动脚本也要比较两个Master/Slave中的RDB文件,载入较新的那个.新浪微博就选用了这种架构</span><br></pre></td></tr></table></figure>

<h2 id="第四章-redis集群"><a href="#第四章-redis集群" class="headerlink" title="第四章 redis集群"></a>第四章 redis集群</h2><ul>
<li>redis的高级命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keys * : 返回满足的所有键 ,可以模糊匹配 比如 keys abc* 代表 abc 开头的key</span><br><span class="line">exists key ：是否存在指定的key，存在返回1，不存在返回0</span><br><span class="line">expire key second：设置某个key的过期时间 时间为秒</span><br><span class="line">del key:删除某个key</span><br><span class="line">select : 选择数据库 数据库为0-15（默认一共16个数据库） 设计成多个数据库实际上是为了数据库安全和备份</span><br><span class="line">move key dbindex ： 将当前数据中的key转移到其他数据库</span><br><span class="line">echo：打印命令</span><br><span class="line">dbsize：查看数据库的key数量</span><br><span class="line">info：查看数据库信息</span><br><span class="line">flushdb ：清空当前数据库</span><br><span class="line">flushall ：清空所有数据库</span><br></pre></td></tr></table></figure>

<h3 id="第1节-主从模式"><a href="#第1节-主从模式" class="headerlink" title="第1节 主从模式"></a>第1节 主从模式</h3><p><a href="https://note.youdao.com/yws/api/personal/file/WEBf948e8e3d8b29109bc6a53819a7af424?method=download&shareKey=f5c717aea60fb421f87206396dc1a66b"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBf948e8e3d8b29109bc6a53819a7af424?method=download&shareKey=f5c717aea60fb421f87206396dc1a66b" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<h4 id="1-1-优点"><a href="#1-1-优点" class="headerlink" title="1.1 优点"></a>1.1 优点</h4><ul>
<li>高可靠性：一方面，采用双机主备架构，能够在主库出现故障时自动进行主备切换，从库提升为主库提供服<br>务，保证服务平稳运行；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和<br>数据异常丢失的问题</li>
<li>读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作</li>
</ul>
<h4 id="1-2-缺点"><a href="#1-2-缺点" class="headerlink" title="1.2 缺点"></a>1.2 缺点</h4><ul>
<li>故障恢复复杂</li>
<li>当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐.</li>
<li>应用较少</li>
</ul>
<h3 id="1-3-配置方式"><a href="#1-3-配置方式" class="headerlink" title="1.3 配置方式"></a>1.3 配置方式</h3><ul>
<li><p>配置文件master_6379</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 外部访问设置</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">#端口号</span><br><span class="line">port 6379</span><br><span class="line"># 开启守护进程</span><br><span class="line">daemonize yes</span><br><span class="line"># 关闭保护模式，可以被外部主机访问</span><br><span class="line">protected-mode no</span><br><span class="line"># 存储日志位置</span><br><span class="line">logfile &quot;./log/master_6379.log&quot;</span><br><span class="line"># 指定数据库文件名</span><br><span class="line">dbfilename master_dump_6379.rdb</span><br><span class="line"># 快照保存位置</span><br><span class="line">dir ./data</span><br><span class="line">#数据是否压缩</span><br><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件slave_6380</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 外部访问设置</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">#端口号</span><br><span class="line">port 6380</span><br><span class="line"># 开启守护进程(136)</span><br><span class="line">daemonize yes</span><br><span class="line"># 关闭保护模式，可以被外部主机访问</span><br><span class="line">protected-mode no</span><br><span class="line"># 存储日志位置(171)</span><br><span class="line">logfile &quot;./log/slave_6380.log&quot;</span><br><span class="line"># 指定数据库文件名(254)</span><br><span class="line">dbfilename salve_dump_6380.rdb</span><br><span class="line"># 快照保存位置</span><br><span class="line">dir ./data</span><br><span class="line">#数据是否压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"># 复制主机位置</span><br><span class="line">SLAVEOF 127.0.0.1 6379</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件slave_6381</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 外部访问设置</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">#端口号</span><br><span class="line">port 6381</span><br><span class="line"># 开启守护进程</span><br><span class="line">daemonize yes</span><br><span class="line"># 关闭保护模式，可以被外部主机访问</span><br><span class="line">protected-mode no</span><br><span class="line"># 存储日志位置</span><br><span class="line">logfile &quot;./log/slave_6381.log&quot;</span><br><span class="line"># 指定数据库文件名</span><br><span class="line">dbfilename salve_dump_6381.rdb</span><br><span class="line"># 快照保存位置</span><br><span class="line">dir ./data</span><br><span class="line">#数据是否压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"># 复制主机位置</span><br><span class="line">SLAVEOF 127.0.0.1 6379</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第2节-哨兵模式"><a href="#第2节-哨兵模式" class="headerlink" title="第2节 哨兵模式"></a>第2节 哨兵模式</h3><p>Redis Sentinel是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel集群和Redis数据集群（略）</p>
<h3 id="第3节-集群模式"><a href="#第3节-集群模式" class="headerlink" title="第3节 集群模式"></a>第3节 集群模式</h3><p><a href="https://note.youdao.com/yws/api/personal/file/WEBe06ac603290e485c206536687d4e7902?method=download&shareKey=71a5542dacd94193a1f22b04dfff9d3e"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBe06ac603290e485c206536687d4e7902?method=download&shareKey=71a5542dacd94193a1f22b04dfff9d3e" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<h4 id="3-1-配置方式"><a href="#3-1-配置方式" class="headerlink" title="3.1 配置方式"></a>3.1 配置方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">步骤:</span><br><span class="line">第1步 创建一个文件夹取名为redis_cluster</span><br><span class="line">第2步 在redis_cluster文件夹下创建六个文件夹 redis_7000 ~ redis_7006 </span><br><span class="line">第3步 拷贝redis_server和redis_cli脚本到分别到redis_7000 ~ redis_7006文件夹中</span><br><span class="line">第4步 创建redis_7000.cnf~redis_7006.cnf配置文件 配置文件样例</span><br><span class="line"></span><br><span class="line"># 外部访问设置</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">#端口号</span><br><span class="line">port 7001</span><br><span class="line"># 开启守护进程</span><br><span class="line">daemonize yes</span><br><span class="line"># 关闭保护模式，可以被外部主机访问</span><br><span class="line">protected-mode no</span><br><span class="line">#数据是否压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"># 是否开启集群</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># 群集节点每次发生更改时自动保留群集配置</span><br><span class="line">cluster-config-file &quot;node_7001.conf&quot;</span><br><span class="line"># 设置超时时间</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"></span><br><span class="line">第5步 将6个节点全部运行起来</span><br></pre></td></tr></table></figure>

<h4 id="3-2-启动集群"><a href="#3-2-启动集群" class="headerlink" title="3.2 启动集群"></a>3.2 启动集群</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">现在6个节点已经启动完成,这是需要一条命令将6个节点关联起来</span><br><span class="line">redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<h4 id="3-3-使用客户端连接任意一个服务节点即可"><a href="#3-3-使用客户端连接任意一个服务节点即可" class="headerlink" title="3.3 使用客户端连接任意一个服务节点即可"></a>3.3 使用客户端连接任意一个服务节点即可</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./redis-cli -c -h [ip地址] -p [端口号]</span><br></pre></td></tr></table></figure>

<h4 id="3-4-进行验证"><a href="#3-4-进行验证" class="headerlink" title="3.4 进行验证"></a>3.4 进行验证</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster info(查看集群信息)</span><br><span class="line">cluster nodes(查看节点列表)</span><br></pre></td></tr></table></figure>

<h2 id="第五章-redis常见客户端"><a href="#第五章-redis常见客户端" class="headerlink" title="第五章 redis常见客户端"></a>第五章 redis常见客户端</h2><p>官网介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.redis.cn/</span><br></pre></td></tr></table></figure>

<ul>
<li>Redisson</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redisson：实现了分布式和可扩展的Java数据结构</span><br></pre></td></tr></table></figure>

<ul>
<li>Jedis</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jedis：是老牌的Redis的Java实现客户端，提供了比较全面的Redis命令的支持</span><br></pre></td></tr></table></figure>

<ul>
<li>lettuce</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lettuce：高级Redis客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优点</p>
<blockquote>
<p>Jedis：比较全面的提供了Redis的操作特性</p>
<p>Redisson：促使使用者对Redis的关注分离，提供很多分布式相关操作服务，例如，分布式锁，分布式集合，可通过Redis支持延迟队列</p>
<p>Lettuce：基于Netty框架的事件驱动的通信层，其方法调用是异步的。Lettuce的API是线程安全的，所以可以操作单个Lettuce连接来完成各种操作</p>
</blockquote>
</li>
</ul>
<h2 id="第六章-redis在项目中的应用"><a href="#第六章-redis在项目中的应用" class="headerlink" title="第六章 redis在项目中的应用"></a>第六章 redis在项目中的应用</h2><h3 id="第1节-Jedis-API操作"><a href="#第1节-Jedis-API操作" class="headerlink" title="第1节 Jedis API操作"></a>第1节 Jedis API操作</h3><p>官网地址:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/xetorthio/jedis</span><br></pre></td></tr></table></figure>

<p>pom.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">    &lt;type&gt;jar&lt;/type&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-单个节点"><a href="#1-1-单个节点" class="headerlink" title="1.1 单个节点"></a>1.1 单个节点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jedis jedis = new Jedis(&quot;localhost&quot;);</span><br><span class="line">jedis.set(&quot;foo&quot;, &quot;bar&quot;);</span><br><span class="line">String value = jedis.get(&quot;foo&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="1-2-jedis连接池"><a href="#1-2-jedis连接池" class="headerlink" title="1.2 jedis连接池"></a>1.2 jedis连接池</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取连接池</span><br><span class="line">JedisPool pool = new JedisPool();</span><br><span class="line">//获取jedis</span><br><span class="line">Jedis jedis = pool.getResource();</span><br><span class="line">//获取数据</span><br><span class="line">String foo = jedis.get(&quot;foo&quot;);</span><br><span class="line">System.out.println(foo);</span><br></pre></td></tr></table></figure>

<h4 id="1-3-集群使用"><a href="#1-3-集群使用" class="headerlink" title="1.3 集群使用"></a>1.3 集群使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;HostAndPort&gt; jedisClusterNodes = new HashSet&lt;HostAndPort&gt;();</span><br><span class="line">jedisClusterNodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 7379));</span><br><span class="line">JedisCluster jc = new JedisCluster(jedisClusterNodes);</span><br><span class="line">jc.set(&quot;foo&quot;, &quot;bar&quot;);</span><br><span class="line">String value = jc.get(&quot;foo&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意:使用集群模式一定要开启集群配置</li>
</ul>
<h3 id="第2节-与Spring框架整合-Jedis"><a href="#第2节-与Spring框架整合-Jedis" class="headerlink" title="第2节 与Spring框架整合(Jedis)"></a>第2节 与Spring框架整合(Jedis)</h3><h4 id="2-1-单节点连接池配置"><a href="#2-1-单节点连接池配置" class="headerlink" title="2.1 单节点连接池配置"></a>2.1 单节点连接池配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--导入外部属性资源文件--&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:redis.properties&quot;&gt;&lt;/context:property-placeholder&gt;</span><br><span class="line">&lt;!--连接池配置--&gt;</span><br><span class="line">&lt;bean id=&quot;poolConfig&quot; class=&quot;org.apache.commons.pool2.impl.GenericObjectPoolConfig&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;maxTotal&quot; value=&quot;$&#123;redis_max_total&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;redis_max_idle&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;redis_min_idle&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置jedis连接池jedispool--&gt;</span><br><span class="line">&lt;bean id=&quot;jedisPool&quot; class=&quot;redis.clients.jedis.JedisPool&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; ref=&quot;poolConfig&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; value=&quot;127.0.0.1&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;2&quot; value=&quot;6379&quot; type=&quot;int&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-集群配置"><a href="#2-2-集群配置" class="headerlink" title="2.2 集群配置"></a>2.2 集群配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;jedisCluster&quot; class=&quot;redis.clients.jedis.JedisCluster&quot;&gt; </span><br><span class="line">	&lt;constructor-arg&gt;</span><br><span class="line">		&lt;set&gt;</span><br><span class="line">			&lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">				&lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.1.194&quot;/&gt;</span><br><span class="line">				&lt;constructor-arg name=&quot;port&quot; value=&quot;6011&quot;/&gt;</span><br><span class="line">			&lt;/bean&gt;</span><br><span class="line">			&lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">				&lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.1.194&quot;/&gt;</span><br><span class="line">				&lt;constructor-arg name=&quot;port&quot; value=&quot;6012&quot;/&gt;</span><br><span class="line">			&lt;/bean&gt;</span><br><span class="line">			&lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">				&lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.1.194&quot;/&gt;</span><br><span class="line">				&lt;constructor-arg name=&quot;port&quot; value=&quot;6013&quot;/&gt;</span><br><span class="line">			&lt;/bean&gt;</span><br><span class="line">			&lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">				&lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.1.194&quot;/&gt;</span><br><span class="line">				&lt;constructor-arg name=&quot;port&quot; value=&quot;6014&quot;/&gt;</span><br><span class="line">			&lt;/bean&gt;</span><br><span class="line">			&lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">				&lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.1.194&quot;/&gt;</span><br><span class="line">				&lt;constructor-arg name=&quot;port&quot; value=&quot;6015&quot;/&gt;</span><br><span class="line">			&lt;/bean&gt;</span><br><span class="line">			&lt;bean class=&quot;redis.clients.jedis.HostAndPort&quot;&gt;</span><br><span class="line">				&lt;constructor-arg name=&quot;host&quot; value=&quot;192.168.1.194&quot;/&gt;</span><br><span class="line">				&lt;constructor-arg name=&quot;port&quot; value=&quot;6016&quot;/&gt;</span><br><span class="line">			&lt;/bean&gt;			</span><br><span class="line">		&lt;/set&gt;</span><br><span class="line">	&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意: 在配置jedisPool时配置主机IP地址以及端口号要指定类型,否则可能报错.</li>
</ul>
<h3 id="第3节-与SpringBoot框架整合（Jedis）"><a href="#第3节-与SpringBoot框架整合（Jedis）" class="headerlink" title="第3节 与SpringBoot框架整合（Jedis）"></a>第3节 与SpringBoot框架整合（Jedis）</h3><ul>
<li><p>添加依赖</p>
</li>
<li><p>创建配置类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class jedisConfiguration &#123;</span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(jedisConfiguration.class);</span><br><span class="line">    @Value(&quot;$&#123;redis_host&#125;&quot;)</span><br><span class="line">    private String host;</span><br><span class="line">    @Value(&quot;$&#123;redis_port&#125;&quot;)</span><br><span class="line">    private int port;</span><br><span class="line">    /**</span><br><span class="line">     * 配置JedisPool</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public JedisPool getJedisPool()&#123;</span><br><span class="line">        GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();</span><br><span class="line">        JedisPool jedisPool = new JedisPool(poolConfig,host,port);</span><br><span class="line">        LOGGER.info(&quot;jedis pool 创建成功 地址=&#123;&#125;==&gt; 端口号=&#123;&#125;&quot;,host,port);</span><br><span class="line">        return jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试是否配置成功</p>
</li>
</ul>
<h3 id="第4节-SpringBoot中操作redis-lettuce"><a href="#第4节-SpringBoot中操作redis-lettuce" class="headerlink" title="第4节 SpringBoot中操作redis(lettuce)"></a>第4节 SpringBoot中操作redis(lettuce)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网: https://lettuce.io/</span><br></pre></td></tr></table></figure>

<ul>
<li><p>SpringBoot整合lettuce(Springboot2.x版本默认提供了redis客户端为lettuce)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--默认是lettuce客户端--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- redis依赖commons-pool2 这个依赖一定要添加 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># redis数据库索引</span><br><span class="line">spring.redis.database=0</span><br><span class="line">#redis服务器地址</span><br><span class="line">spring.redis.host=127.0.0.1</span><br><span class="line">#redis服务器端口号</span><br><span class="line">spring.redis.port=6379</span><br><span class="line"></span><br><span class="line"># lettuce基本配置</span><br><span class="line"># Lettuce连接池,最大连接数(如若为负值表示没有限制)</span><br><span class="line">spring.redis.lettuce.pool.max-active=8</span><br><span class="line"># 连接池最大阻塞等待时间(使用负值表示没有限制)</span><br><span class="line">spring.redis.lettuce.pool.max-wait=10000ms</span><br><span class="line"># 连接池中的最大空闲连接</span><br><span class="line">spring.redis.lettuce.pool.max-idle=8</span><br><span class="line"># 连接池中的最小空闲连接</span><br><span class="line">spring.redis.lettuce.pool.min-idle=0</span><br><span class="line"># 关闭超时时间</span><br><span class="line">spring.redis.lettuce.shutdown-timeout=100ms</span><br></pre></td></tr></table></figure></li>
<li><p>lettuce使用</p>
</li>
</ul>
<p>spring-boot-starter-data-redis2.x提供的客户端默认是lettuce,SpringBoot redis提供了两个比较常用的操作redis数据库的模板工具分别为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、RedisTemplate:</span><br><span class="line">    1.1 操作对象的类 </span><br><span class="line">    1.2 线程安全 </span><br><span class="line">    1.3 使用Java自带的序列化方式(序列化和反序列化都采用Java再带的序列化/反序列化工具) </span><br><span class="line">    1.4 我们也可以自定义序列化方式</span><br><span class="line">    1.5 默认采用jdk序列化工具,会将key和value序列化为我们不可读的数据</span><br><span class="line">    </span><br><span class="line">2、StringRedisTemplate:</span><br><span class="line">    1.1 是RedisTemplate的子类</span><br><span class="line">    1.1 操作字符串</span><br><span class="line">    1.2 线程安全</span><br><span class="line">    1.3 存储数据易读(key value 不会序列化成用户不易读数据)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">3、RedisTemplate和StringRedisTemplate区别</span><br><span class="line">    3.1 两者数据各自存，各自取，数据不互通。</span><br><span class="line">        RedisTemplate不能取StringRedisTemplate存入的数据</span><br><span class="line">        StringRedisTemplate不能取RedisTemplate存入的数据</span><br><span class="line">    3.2 序列化策略不同</span><br><span class="line">        RedisTemplate采用JDK的序列化策略</span><br><span class="line">        StringRedisTemplate采用String的序列化策略</span><br><span class="line">4、使用</span><br><span class="line">    4.1 如果你操作的是字符串类型那么使用StringRedisTemplate</span><br><span class="line">    4.2 如果你操作的是复杂的对象类型,那么使用RedisTemplate</span><br></pre></td></tr></table></figure>

<h4 id="4-1-使用StringRedisTemplate操作字符串"><a href="#4-1-使用StringRedisTemplate操作字符串" class="headerlink" title="4.1 使用StringRedisTemplate操作字符串"></a>4.1 使用StringRedisTemplate操作字符串</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">StringRedisTemplate对象中提供了opsForValue()进行字符串操作</span><br><span class="line"></span><br><span class="line">当然也提供了其他数据结构类型的操作</span><br></pre></td></tr></table></figure>

<h4 id="4-2-使用RedisTemplate操作对象"><a href="#4-2-使用RedisTemplate操作对象" class="headerlink" title="4.2 使用RedisTemplate操作对象"></a>4.2 使用RedisTemplate操作对象</h4><p>步骤:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1步: 自定义RedisTemplate模板操作对象的类型</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @Auther: hushuang</span><br><span class="line"> * @Date: 2019/12/1 15:09</span><br><span class="line"> * @Email: hd1611756908@163.com</span><br><span class="line"> * @Description: 配置需要保存的数据类型</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class RedisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public RedisTemplate&lt;String, Serializable&gt; redisTemplate(LettuceConnectionFactory connectionFactory) &#123;</span><br><span class="line">        RedisTemplate&lt;String, Serializable&gt; redisTemplate = new RedisTemplate&lt;&gt;();</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        //key的序列化方式,使用string类型的序列化方式</span><br><span class="line">        redisTemplate.setKeySerializer(new StringRedisSerializer());</span><br><span class="line">        //value序列化方式 采用jackson</span><br><span class="line">        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());</span><br><span class="line">        return redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">第2步:操作redis数据库</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private RedisTemplate&lt;String,Serializable&gt; redisTemplate;</span><br></pre></td></tr></table></figure>
<h2 id="第七章-centos防火墙"><a href="#第七章-centos防火墙" class="headerlink" title="第七章 centos防火墙"></a>第七章 centos防火墙</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">centos7 防火墙:</span><br><span class="line"></span><br><span class="line">network.service是系统提供的服务之一管理命令格式</span><br><span class="line">systemctl start|stop|restart|status network</span><br><span class="line">查询状态</span><br><span class="line">systemctl status network  </span><br><span class="line"> 或</span><br><span class="line">systemctl status network.service</span><br><span class="line">重启网络服务</span><br><span class="line">systemctl restart network </span><br><span class="line">或</span><br><span class="line">systemctl restart network.serice </span><br><span class="line"></span><br><span class="line">设置开机启动</span><br><span class="line">systemctl enable network</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">防火墙设置</span><br><span class="line">centos7和Centos6 防火墙的区别：</span><br><span class="line">Centos6 使用的是iptables, Centos7 使用的是filewalld</span><br><span class="line">关闭firewall：</span><br><span class="line">systemctl status firewalld.service   #查看防火墙状态</span><br><span class="line">systemctl restart firewalld.service  #重新启动防火墙</span><br><span class="line">systemctl stop firewalld.service      #停止firewall</span><br><span class="line">systemctl disable firewalld.service  #禁止firewall开机启动</span><br><span class="line">systemctl enable firewalld.service   #firewall开机启动</span><br><span class="line"></span><br><span class="line">查询、开放、关闭端口</span><br><span class="line"># 查询端口是否开放</span><br><span class="line">firewall-cmd  --query-port=8080/tcp</span><br><span class="line"># 开放80端口</span><br><span class="line">firewall-cmd  --permanent  --add-port=80/tcp</span><br><span class="line">firewall-cmd  --permanent  --add-port=8080-8085/tcp</span><br><span class="line"># 移除端口</span><br><span class="line">firewall-cmd  --permanent  --remove-port=8080/tcp</span><br><span class="line">查看防火墙的开放的端口</span><br><span class="line">firewall-cmd  --permanent --list-ports</span><br><span class="line">#重启防火墙(修改配置后要重启防火墙)</span><br><span class="line">firewall-cmd  --reload</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Shiro</title>
    <url>/2021/08/08/Shiro/</url>
    <content><![CDATA[<h2 id="第一章-Shiro简介"><a href="#第一章-Shiro简介" class="headerlink" title="第一章 Shiro简介"></a>第一章 Shiro简介</h2><h3 id="第1节-shiro介绍"><a href="#第1节-shiro介绍" class="headerlink" title="第1节 shiro介绍"></a>第1节 shiro介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网地址: http://shiro.apache.org/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Apache Shiro 是一个功能强大,易于使用的Java安全框架,他执行认证、授权、加密、会话管理等功能,使用Shiro易于理解的API,使你能够轻松的保护任何应用,如移动端应用,大型web应用以及企业级应用.</p>
</blockquote>
<blockquote>
<p>Shiro可以非常容易的开发出足够好的应用,不仅可以用在JavaSE环境,也可以用在JavaEE环境</p>
</blockquote>
<h3 id="第2节-整体功能图"><a href="#第2节-整体功能图" class="headerlink" title="第2节 整体功能图"></a>第2节 整体功能图</h3><p><a href="http://wiki.jikexueyuan.com/project/shiro/images/1.png"><img "" class="lazyload placeholder" data-original="http://wiki.jikexueyuan.com/project/shiro/images/1.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li>Authentication[ɔːˌθentɪˈkeɪʃn]:身份认证 / 登录,验证用户是不是拥有相应的身份</li>
<li>Authorization[ˌɔːθəraɪˈzeɪʃn]:授权,即权限验证,验证某个已认证的用户是否拥有某个权限</li>
<li>Session Manager:会话管理,即用户登录后就是一次会话,在没有退出之前,它的所有信息都在会话中</li>
<li>Cryptography[krɪpˈtɒɡrəfi]:加密,保护数据的安全性,如密码加密存储到数据库,而不是明文存储</li>
<li>Web Support:Web 支持,可以非常容易的集成到 Web 环境</li>
<li>Caching:缓存,比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查数据库,这样可以提高效率</li>
<li>Remember Me:记住我,这个是非常常见的功能,即一次登录后,下次再来的话不用登录了</li>
</ul>
<h3 id="第3节-核心API"><a href="#第3节-核心API" class="headerlink" title="第3节 核心API"></a>第3节 核心API</h3><p><a href="http://wiki.jikexueyuan.com/project/shiro/images/2.png"><img "" class="lazyload placeholder" data-original="http://wiki.jikexueyuan.com/project/shiro/images/2.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li>Subject：主体,代表了当前 “用户”,获取用户传递过来的数据,然后传递给SecurityManager: 安全管理器</li>
<li>SecurityManager: 安全管理器(Shiro的核心),将用户传递过来的认证信息和数据库中保存的信息进行校验</li>
<li>Realm:域,Shiro的Realm主要从数据库中获取安全数据(如用户、角色、权限)通过方法传递给SecurityManager安全管理器进行数据验证</li>
</ul>
<h3 id="第4节-内部架构图"><a href="#第4节-内部架构图" class="headerlink" title="第4节 内部架构图"></a>第4节 内部架构图</h3><p><a href="http://wiki.jikexueyuan.com/project/shiro/images/3.png"><img "" class="lazyload placeholder" data-original="http://wiki.jikexueyuan.com/project/shiro/images/3.png" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li>Subject:当前用户主体(可以使任何与应用交互的用户)</li>
<li>SecurityManager: 是Shiro的心脏;所有具体的交互都通过SecurityManager 进行控制;它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理</li>
<li>Authenticator[ɔːˈθɛntɪkeɪtə]:认证器,负责主体认证的,这是一个扩展点,如果用户觉得 Shiro 默认的不好,可以自定义实现</li>
<li>Authrizer:授权器,或者访问控制器</li>
<li>Realm:可以有1个或多个Realm,是安全实体数据源,Shiro不知道你的用户 / 权限存储在哪及以何种格式存储,所以我们一般在应用中都需要实现自己的 Realm</li>
<li>SessionManager: 会话管理器</li>
<li>SessionDAO: session可以保存到数据库中或者是缓存中,或者是redis中,我们可以实现自己的SessionDAO对数据进行CRUD</li>
<li>CacheManager:缓存控制器,来管理如用户、角色、权限等的缓存的;因为这些数据基本上很少去改变,放到缓存中后可以提高访问的性能</li>
<li>Cryptography [krɪpˈtɒɡrəfi]:密码模块,Shiro提高了一些常见的加密组件用于如密码加密</li>
</ul>
<h3 id="第5节-核心名词介绍"><a href="#第5节-核心名词介绍" class="headerlink" title="第5节 核心名词介绍"></a>第5节 核心名词介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">身份验证就是我们通常说的登录,一般使用用户名/密码这样的常见组合,我们shiro中使用:</span><br><span class="line">1. principals [ˈprɪnsəpəlz](用户名):身份,可以是任何东西,如用户名,邮箱等唯一即可。</span><br><span class="line">2. credentials [krəˈdenʃlz]:证明 / 凭证，即只有主体知道的安全值,如密码 / 数字证书等</span><br><span class="line">最常见的 principals 和 credentials 组合就是用户名 / 密码了</span><br><span class="line">Subject: 主体</span><br><span class="line">Realm  : 验证主体的数据源</span><br></pre></td></tr></table></figure>

<h3 id="第6节-Shiro核心对象介绍"><a href="#第6节-Shiro核心对象介绍" class="headerlink" title="第6节 Shiro核心对象介绍"></a>第6节 Shiro核心对象介绍</h3><ul>
<li><p>Md5Hash: MD5密码加密类</p>
</li>
<li><p>DelegatingFilterProxy:代理类对象,存在spring-web包中,其作用就是一个filter的代理,用这个类的好处是可以通过spring容器来管理filter的生命周期</p>
</li>
<li><p>ShiroFilterFactoryBean:ShiroFilter:权限控制的核心配置对象有Spring IOC容器创建，交给DelegatingFilterProxy代理</p>
</li>
<li><p>DefaultWebSecurityManager: Shiro关于web的安全管理器对象</p>
</li>
<li><p>AuthorizingRealm: 自定义Realm需要被继承的类,用于自定义Realm</p>
</li>
<li><p>HashedCredentialsMatcher: 用于密码加密的类</p>
</li>
<li><p>DefaultWebSessionManager: web的会话管理类</p>
</li>
<li><p>UsernamePasswordToken: 封装用户名密码</p>
</li>
<li><p>SimpleAuthenticationInfo:Realm认证方法的返回对象,封装从数据库查询出来认证的安全数据</p>
</li>
<li><p>SimpleAuthorizationInfo:Realm授权方法的返回对象,封装从数据库查询出来授权的安全数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以上是常见的认证/授权需要用到的类</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第二章-Shiro快速入门"><a href="#第二章-Shiro快速入门" class="headerlink" title="第二章 Shiro快速入门"></a>第二章 Shiro快速入门</h2><ul>
<li><p>Github源码下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/apache/shiro.git</span><br></pre></td></tr></table></figure></li>
<li><p>在线源码下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://downloads.apache.org/shiro/1.2.6/shiro-root-1.2.6-source-release.zip</span><br></pre></td></tr></table></figure></li>
<li><p>查看源码快速入门</p>
</li>
<li><ul>
<li><p>shiro.ini 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[users]</span><br><span class="line"># # 用户名=密码,角色   root: 用户名  secret:密码 admin: 角色</span><br><span class="line">root = secret, admin</span><br><span class="line"># 用户名=密码,角色</span><br><span class="line">guest = guest, guest</span><br><span class="line"># 用户名=密码,角色</span><br><span class="line">presidentskroob = 12345, president</span><br><span class="line"># 用户名=密码,角色,角色</span><br><span class="line">darkhelmet = ludicrousspeed, darklord, schwartz</span><br><span class="line"># 用户名=密码,角色,角色</span><br><span class="line">lonestarr = vespa, goodguy, schwartz</span><br><span class="line"></span><br><span class="line"># -----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">[roles]</span><br><span class="line"># 角色= *    *: 通配符代表所有权限</span><br><span class="line">admin = *</span><br><span class="line"># The &#x27;schwartz&#x27; role can do anything (*) with any lightsaber:</span><br><span class="line">schwartz = lightsaber:*</span><br><span class="line"># The &#x27;goodguy&#x27; role is allowed to &#x27;drive&#x27; (action) the winnebago (type) with</span><br><span class="line"># license plate &#x27;eagle5&#x27; (instance specific id)</span><br><span class="line">goodguy = winnebago:drive:eagle5</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>入门代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    // 创建安全管理器 SecurityManager</span><br><span class="line">    Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</span><br><span class="line">    SecurityManager securityManager = factory.getInstance();</span><br><span class="line"></span><br><span class="line">    // 将安全管理器设置到SecurityUtils中</span><br><span class="line">    SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">    // 获取实体</span><br><span class="line">    Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">    // 获取会话</span><br><span class="line">    Session session = currentUser.getSession();</span><br><span class="line">    session.setAttribute(&quot;someKey&quot;, &quot;aValue&quot;);</span><br><span class="line">    String value = (String) session.getAttribute(&quot;someKey&quot;);</span><br><span class="line">    if (value.equals(&quot;aValue&quot;)) &#123;</span><br><span class="line">        log.info(&quot;Retrieved the correct value! [&quot; + value + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断是否认证</span><br><span class="line">    if (!currentUser.isAuthenticated()) &#123;</span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(&quot;lonestarr&quot;, &quot;vespa&quot;);</span><br><span class="line">        token.setRememberMe(true);</span><br><span class="line">        try &#123;</span><br><span class="line">            currentUser.login(token);</span><br><span class="line">        &#125; catch (UnknownAccountException uae) &#123;</span><br><span class="line">            log.info(&quot;There is no user with username of &quot; + token.getPrincipal());</span><br><span class="line">        &#125; catch (IncorrectCredentialsException ice) &#123;</span><br><span class="line">            log.info(&quot;Password for account &quot; + token.getPrincipal() + &quot; was incorrect!&quot;);</span><br><span class="line">        &#125; catch (LockedAccountException lae) &#123;</span><br><span class="line">            log.info(&quot;The account for username &quot; + token.getPrincipal() + &quot; is locked.  &quot; +</span><br><span class="line">                    &quot;Please contact your administrator to unlock it.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 其他异常</span><br><span class="line">        catch (AuthenticationException ae) &#123;</span><br><span class="line">            //unexpected condition?  error?</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // </span><br><span class="line">    log.info(&quot;User [&quot; + currentUser.getPrincipal() + &quot;] logged in successfully.&quot;);</span><br><span class="line"></span><br><span class="line">    // 判断当前用户有哪些角色</span><br><span class="line">    if (currentUser.hasRole(&quot;schwartz&quot;)) &#123;</span><br><span class="line">        log.info(&quot;May the Schwartz be with you!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.info(&quot;Hello, mere mortal.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断当前用户是否有lightsaber角色的weild权限</span><br><span class="line">    if (currentUser.isPermitted(&quot;lightsaber:weild&quot;)) &#123;</span><br><span class="line">        log.info(&quot;You may use a lightsaber ring.  Use it wisely.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.info(&quot;Sorry, lightsaber rings are for schwartz masters only.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断当前用户是否有winnebago角色的drive权限的eagle5操作</span><br><span class="line">    if (currentUser.isPermitted(&quot;winnebago:drive:eagle5&quot;)) &#123;</span><br><span class="line">        log.info(&quot;You are permitted to &#x27;drive&#x27; the winnebago with license plate (id) &#x27;eagle5&#x27;.  &quot; +</span><br><span class="line">                &quot;Here are the keys - have fun!&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        log.info(&quot;Sorry, you aren&#x27;t allowed to drive the &#x27;eagle5&#x27; winnebago!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 登出</span><br><span class="line">    currentUser.logout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="第三章-加密技术"><a href="#第三章-加密技术" class="headerlink" title="第三章 加密技术"></a>第三章 加密技术</h2><h3 id="第1节-数据加密"><a href="#第1节-数据加密" class="headerlink" title="第1节 数据加密"></a>第1节 数据加密</h3><blockquote>
<p>所谓数据加密（Data Encryption）技术是指将一个信息（或称明文,plain text）经过加密钥匙（Encryption key）及加密函数转换,变成无意义的密文（cipher text）,而接收方则将此密文经过解密函数、解密钥匙（Decryption key）还原成明文,加密技术是网络安全技术的基石</p>
</blockquote>
<h3 id="第2节-常见加密方式"><a href="#第2节-常见加密方式" class="headerlink" title="第2节 常见加密方式"></a>第2节 常见加密方式</h3><h4 id="2-1-对称加密"><a href="#2-1-对称加密" class="headerlink" title="2.1 对称加密"></a>2.1 对称加密</h4><blockquote>
<p>对称加密算法是应用较早的加密算法,又称为共享密钥加密算法。在对称加密算法中,使用的密钥只有一个,发送和接收双方都使用这个密钥对数据进行加密和解密.这就要求加密和解密方事先都必须知道加密的密钥.</p>
</blockquote>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEBfb86657ef464546adfc6a9a4af2dc60f?method=download&shareKey=505619aea2ba33a41e44658c44ad2dd8"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBfb86657ef464546adfc6a9a4af2dc60f?method=download&shareKey=505619aea2ba33a41e44658c44ad2dd8" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<h4 id="2-2-非对称加密"><a href="#2-2-非对称加密" class="headerlink" title="2.2 非对称加密"></a>2.2 非对称加密</h4><blockquote>
<p>非对称加密算法,又称为公开密钥加密算法。它需要两个密钥,一个称为公开密钥 (public key),即公钥,另一个称为私有密钥 (private key),即私钥。因为加密和解密使用的是两个不同的密钥,所以这种算法称为非对称加密算法.</p>
</blockquote>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB477a71e1b5cf75b80cdc23ed72705622?method=download&shareKey=3f83efd617229a7cb3bd348f8104a86c"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB477a71e1b5cf75b80cdc23ed72705622?method=download&shareKey=3f83efd617229a7cb3bd348f8104a86c" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<h3 id="第3节-常见的摘要算法"><a href="#第3节-常见的摘要算法" class="headerlink" title="第3节 常见的摘要算法"></a>第3节 常见的摘要算法</h3><h4 id="3-1-MD5加密"><a href="#3-1-MD5加密" class="headerlink" title="3.1 MD5加密"></a>3.1 MD5加密</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MD5是一种摘要算法,它的典型应用是对一段信息产生信息摘要,以防止被篡改</span><br><span class="line"></span><br><span class="line">public static final byte[] computeMD5(byte[] content) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">        return md5.digest(content);</span><br><span class="line">    &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-SHA-1加密"><a href="#3-2-SHA-1加密" class="headerlink" title="3.2 SHA-1加密"></a>3.2 SHA-1加密</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHA-1 是和 MD5 一样流行的 消息摘要算法，然而 SHA-1 比 MD5 的 安全性更强。对于长度小于 2 ^ 64 位的消息</span><br><span class="line"></span><br><span class="line">SHA-1 会产生一个 160 位的 消息摘要。基于 MD5、SHA-1 的信息摘要特性以及 不可逆，可以被应用在检查文件完整性以及数字签名等场景</span><br><span class="line"></span><br><span class="line">public static byte[] computeSHA1(byte[] content) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        MessageDigest sha1 = MessageDigest.getInstance(&quot;SHA1&quot;);</span><br><span class="line">        return sha1.digest(content);</span><br><span class="line">    &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        throw new RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第四章-Shiro在ssm框架-spring-springmvc-mybatis-中的使用"><a href="#第四章-Shiro在ssm框架-spring-springmvc-mybatis-中的使用" class="headerlink" title="第四章 Shiro在ssm框架(spring+springmvc+mybatis)中的使用"></a>第四章 Shiro在ssm框架(spring+springmvc+mybatis)中的使用</h2><h3 id="第1节-ssm框架整合"><a href="#第1节-ssm框架整合" class="headerlink" title="第1节 ssm框架整合"></a>第1节 ssm框架整合</h3><ul>
<li><p>pom.xml依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;spring.version&gt;4.3.27.RELEASE&lt;/spring.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;7.0&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;shiro-all&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.4.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.6.11&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-instrument&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-instrument-tomcat&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc-portlet&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-websocket&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!-- mybatis核心包 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.4.5&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.3.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.40&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.8.7&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.8.7&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.8.7&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;!--打印日志 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.7.5&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.7.5&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;jstl&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.1.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>整合(略)</p>
</li>
<li><p>数据库SQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1.sys_users用户表</span><br><span class="line"></span><br><span class="line">CREATE TABLE sys_users (</span><br><span class="line">  user_id bigint PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;编号&#x27;,</span><br><span class="line">  username VARCHAR (100) UNIQUE COMMENT &#x27;用户名&#x27;,</span><br><span class="line">  password VARCHAR(100) COMMENT &#x27;密码&#x27;,</span><br><span class="line">  salt VARCHAR(100) COMMENT &#x27;盐值&#x27;</span><br><span class="line">) charset=utf8 ENGINE=InnoDB COMMENT=&quot;用户表&quot;;</span><br><span class="line"></span><br><span class="line">-- 2.sys_roles角色表</span><br><span class="line"></span><br><span class="line">CREATE TABLE sys_roles (</span><br><span class="line">  role_id bigint PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;角色编号&#x27;,</span><br><span class="line">  role_name VARCHAR(100) COMMENT &#x27;角色名称&#x27;</span><br><span class="line">) charset=utf8 ENGINE=InnoDB COMMENT=&quot;角色表&quot;;</span><br><span class="line"></span><br><span class="line">-- 3.sys_permissions权限表（或资源表）</span><br><span class="line"></span><br><span class="line">CREATE TABLE sys_permissions (</span><br><span class="line">  permission_id bigint PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;编号&#x27;,</span><br><span class="line">  permission_name VARCHAR(100) COMMENT &#x27;权限&#x27;</span><br><span class="line">) charset=utf8 ENGINE=InnoDB COMMENT=&quot;权限表&quot;;</span><br><span class="line"></span><br><span class="line">-- 4.sys_users_roles用户-角色关联表</span><br><span class="line"></span><br><span class="line">CREATE TABLE sys_users_roles (</span><br><span class="line">  ur_id  bigint PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;编号&#x27;,</span><br><span class="line">  user_id bigint COMMENT &#x27;用户编号&#x27;,</span><br><span class="line">  role_id bigint COMMENT &#x27;角色编号&#x27;</span><br><span class="line">) charset=utf8 ENGINE=InnoDB COMMENT=&quot;用户-角色关联表&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 5.sys_roles_permissions角色-权限关联表（或角色-资源关联表）</span><br><span class="line">CREATE TABLE sys_roles_permissions (</span><br><span class="line">  rp_id bigint PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;编号&#x27;,</span><br><span class="line">  role_id bigint COMMENT &#x27;角色编号&#x27;,</span><br><span class="line">  permission_id bigint COMMENT &#x27;权限编号&#x27;</span><br><span class="line">) charset=utf8 ENGINE=InnoDB COMMENT=&quot;角色-权限关联表&quot;;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第2节-在WEB-INF-views文件夹下创建需要的页面"><a href="#第2节-在WEB-INF-views文件夹下创建需要的页面" class="headerlink" title="第2节 在WEB-INF/views文件夹下创建需要的页面"></a>第2节 在WEB-INF/views文件夹下创建需要的页面</h3><ul>
<li><p>首页 index.jsp(首页创建在webapp下,非WEB-INF/views下)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;首页&lt;/h1&gt;</span><br><span class="line">    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/home&quot;&gt;跳转Home页面&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>主页 home.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1 style=&quot;text-align: center&quot;&gt;Home页面&lt;/h1&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;table border=&quot;1&quot;&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;th&gt;测试请求地址&lt;/th&gt;</span><br><span class="line">                &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    /jumpLogin</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/jumpLogin&quot;&gt;测试跳转登陆页面地址&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    /jumpRegister</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/jumpRegister&quot;&gt;测试跳转注册页面地址&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    /getUserList</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/getUserList&quot;&gt;测试获取用户列表页面地址&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    /jumpEdit</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">                &lt;td&gt;</span><br><span class="line">                    &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/jumpEdit&quot;&gt;测试跳转更新页面地址&lt;/a&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/tbody&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>登陆页面 login.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;登录&lt;/h1&gt;</span><br><span class="line">    &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/login&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt;</span><br><span class="line">        &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;</span><br><span class="line">        &lt;label for=&quot;password&quot;&gt;用户名:&lt;/label&gt;</span><br><span class="line">        &lt;input id=&quot;password&quot; type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注册页面 register.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;注册&lt;/h1&gt;</span><br><span class="line">    &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/register&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        &lt;label for=&quot;username&quot;&gt;用户名:&lt;/label&gt;</span><br><span class="line">        &lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;</span><br><span class="line">        &lt;label for=&quot;password&quot;&gt;用户名:&lt;/label&gt;</span><br><span class="line">        &lt;input id=&quot;password&quot; type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br/&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>数据列表页面 user_list.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;用户列表页面&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>为授权页面 unauthorized.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;没有权限&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>更新页面 edit.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1 style=&quot;text-align: center&quot;&gt;我是更新页面,我需要认证并且需要授权才能登陆&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第3节-Shiro的基本配置"><a href="#第3节-Shiro的基本配置" class="headerlink" title="第3节 Shiro的基本配置"></a>第3节 Shiro的基本配置</h3><ul>
<li><p>在web.xml配置shiro的代理filter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        参数的意义:</span><br><span class="line">        默认targetFilterLifecycle为false,当他为false的时候shiroFilter代理对象默认加入到IOC容器中</span><br><span class="line">        并且在IOC容器中遵循IOC的生命周期管理,将其设置为true,让其受tomcat容器生命周期管理</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;true&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在spring的核心配置文件(applicatioContext.xml)中配置其他Shiro其他配置</p>
</li>
<li><ul>
<li><p>配置被web.xml中Filter象代理的类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--被web.xml中配置的Filter代理对象代理的类--&gt;</span><br><span class="line">&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;</span><br><span class="line">    &lt;!--配置安全管理器--&gt;</span><br><span class="line">    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--如果访问的页面或者是请求地址需要认证才能访问,在没有访问的时候访问了,跳转此地址--&gt;</span><br><span class="line">    &lt;property name=&quot;loginUrl&quot; value=&quot;/jumpLogin&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--设置没有授权需要被跳转的地址--&gt;</span><br><span class="line">    &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/jumpUnauthorized&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--设置拦截规则--&gt;</span><br><span class="line">    &lt;property name=&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            # anon: shiro的核心过滤器,表示/这个请求,可以匿名访问</span><br><span class="line">            / = anon</span><br><span class="line">            /home = anon</span><br><span class="line">            /jumpLogin = anon</span><br><span class="line">            /jumpRegister = anon</span><br><span class="line">            # authc: shiro的核心过滤器,表示getUserList必须认证(登陆)才能访问</span><br><span class="line">            /getUserList = authc</span><br><span class="line">            # roles: shiro的核心过滤器,表示jumpEdit必须拥有admin角色才能访问</span><br><span class="line">            /jumpEdit = authc,roles[admin]</span><br><span class="line">            # ** :通配符,表示除了上面配置的拦截,其余的所有请求都需要认证</span><br><span class="line">            /** = authc</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li>Shiro常见核心过滤器介绍</li>
</ul>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB831385f01bad3de5616855f5e6781e0c?method=download&shareKey=a810f2c8c1cf83dc912f9408618bd070"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB831385f01bad3de5616855f5e6781e0c?method=download&shareKey=a810f2c8c1cf83dc912f9408618bd070" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><ul>
<li><p>配置Web安全管理器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>编写控制器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 跳转Home页面</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(value = &quot;/home&quot;,method = RequestMethod.GET)</span><br><span class="line">    public String home()&#123;</span><br><span class="line">        System.out.println(&quot;跳转home.jsp页面,此请求地址[home]设置为匿名访问...&quot;);</span><br><span class="line">        return &quot;home&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 跳转登陆页面</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(value = &quot;/jumpLogin&quot;)</span><br><span class="line">    public String jumpLogin()&#123;</span><br><span class="line">        System.out.println(&quot;跳转login.jsp页面,此请求地址[jumpLogin]设置为匿名访问...&quot;);</span><br><span class="line">        return &quot;login&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 跳转注册页面</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(value = &quot;/jumpRegister&quot;)</span><br><span class="line">    public String jumpRegister()&#123;</span><br><span class="line">        System.out.println(&quot;跳转register.jsp页面,此请求地址[jumpRegister]设置为匿名访问...&quot;);</span><br><span class="line">        return &quot;register&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 跳转用户列表页面</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(value = &quot;/getUserList&quot;)</span><br><span class="line">    public String getUserList()&#123;</span><br><span class="line">        System.out.println(&quot;跳转user_list.jsp页面,此请求地址[getUserList]设置为认证访问...&quot;);</span><br><span class="line">        return &quot;user_list&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 跳转更新页面</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(value = &quot;/jumpEdit&quot;)</span><br><span class="line">    public String jumpEdit()&#123;</span><br><span class="line">        System.out.println(&quot;跳转edit.jsp页面,此请求地址[jumpEdit]设置为认证,并且判断此用户是否是访问这个请求的角色...&quot;);</span><br><span class="line">        return &quot;edit&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第4节-Shiro的其他配置"><a href="#第4节-Shiro的其他配置" class="headerlink" title="第4节 Shiro的其他配置"></a>第4节 Shiro的其他配置</h3><h4 id="4-1-注册功能实现"><a href="#4-1-注册功能实现" class="headerlink" title="4.1 注册功能实现"></a>4.1 注册功能实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Shiro用户注册</span><br><span class="line"> * @param username: 用户名</span><br><span class="line"> * @param password: 密码</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(value = &quot;/register&quot;)</span><br><span class="line">public String register(String username, String password, Model model)&#123;</span><br><span class="line">    System.out.println(&quot;用户注册...入参为:&quot;+username+&quot;=&quot;+password);</span><br><span class="line">    //判断前端发送过来的用户名和密码是否为空</span><br><span class="line">    if((username!=null &amp;&amp; username.length()&gt;0) &amp;&amp; (password!=null &amp;&amp; password.length()&gt;0))&#123;</span><br><span class="line">        //生成salt,我这里使用用户名作为盐,可以自己随意生成(比如UUDI或者随机数)</span><br><span class="line">        String salt=username;</span><br><span class="line">        /**</span><br><span class="line">         * 在进行注册前要将密码进行盐值加密(我们采用MD5盐值加密方式),Shiro官方提供了Md5Hash类帮我们实现</span><br><span class="line">         * 我们这里使用3个参数的构造方法</span><br><span class="line">         * 第一个参数: 被加密的对象</span><br><span class="line">         * 第二个参数： 加的盐</span><br><span class="line">         * 第三个参数: 加密(迭代)次数</span><br><span class="line">         */</span><br><span class="line">        String source=password;//给谁加密</span><br><span class="line">        Md5Hash md5Hash = new Md5Hash(source,salt,1024);</span><br><span class="line">        //获取进过加盐和循环迭代多次的密码</span><br><span class="line">        String targetPassword = md5Hash.toString();</span><br><span class="line">        //调用业务逻辑成,调用mapper层,将新用户信息保存到数据库中</span><br><span class="line">        SysUser sysUser = new SysUser();</span><br><span class="line">        sysUser.setUsername(username);</span><br><span class="line">        sysUser.setPassword(targetPassword);</span><br><span class="line">        sysUser.setSalt(salt);</span><br><span class="line">        sysUserService.addSysUser(sysUser);</span><br><span class="line">        //注册成功跳转到登录页</span><br><span class="line">        return &quot;redirect:/jumpLogin&quot;;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        //注册失败</span><br><span class="line">        String msg=&quot;注册失败,用户名或者密码为空&quot;;</span><br><span class="line">        model.addAttribute(&quot;msg&quot;,msg);</span><br><span class="line">        return &quot;register&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-登陆实现"><a href="#4-2-登陆实现" class="headerlink" title="4.2 登陆实现"></a>4.2 登陆实现</h4><h5 id="4-2-1-控制器编写"><a href="#4-2-1-控制器编写" class="headerlink" title="4.2.1 控制器编写"></a>4.2.1 控制器编写</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用户登录</span><br><span class="line"> * @param username: 用户名</span><br><span class="line"> * @param password: 密码</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(value = &quot;/userLogin&quot;)</span><br><span class="line">public String userLogin(String username,String password)&#123;</span><br><span class="line">    System.out.println(&quot;用户登录...入参为:&quot;+username+&quot;=&quot;+password);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户登录采用Shiro帮助我们进行认证和授权</span><br><span class="line">     */</span><br><span class="line">    //获取Shiro实体</span><br><span class="line">    Subject subject = SecurityUtils.getSubject();</span><br><span class="line">    //使用Shiro提供的API对象封装前端传送过来的请求数据(用户名和密码)</span><br><span class="line">    UsernamePasswordToken token = new UsernamePasswordToken(username, password);</span><br><span class="line">    //调用Shiro提供的方法进行验证</span><br><span class="line">    try &#123;</span><br><span class="line">        subject.login(token);</span><br><span class="line">    &#125;catch (UnknownAccountException uae)&#123;</span><br><span class="line">        System.out.println(&quot;用户名不存在:&quot;+uae.getMessage());</span><br><span class="line">    &#125;catch (IncorrectCredentialsException ice)&#123;</span><br><span class="line">        System.out.println(&quot;密码错误:&quot;+ice.getMessage());</span><br><span class="line">    &#125;catch (LockedAccountException lae)&#123;</span><br><span class="line">        System.out.println(&quot;用户被锁定:&quot;+lae.getMessage());</span><br><span class="line">    &#125;catch (AuthenticationException ae)&#123;</span><br><span class="line">        &lt;!--由自定义Realm抛出,在此捕获--&gt;</span><br><span class="line">        System.out.println(&quot;其他异常:&quot;+ae.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    //登陆成功跳转列表页(列表页需要认证才可以访问)</span><br><span class="line">    return &quot;redirect:/getUserList&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-自定义Realm实现"><a href="#4-2-2-自定义Realm实现" class="headerlink" title="4.2.2 自定义Realm实现"></a>4.2.2 自定义Realm实现</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author 枫桥夜泊1990</span><br><span class="line"> * @BLOG https://hd1611756908.github.io/</span><br><span class="line"> * @BSITE https://space.bilibili.com/514155929/</span><br><span class="line"> * @DATE 2020/8/9</span><br><span class="line"> * realm:查询数据库获取用户认证和授权的数据,将其返回给安全管理器</span><br><span class="line"> */</span><br><span class="line">public class SysUserRealm extends AuthorizingRealm &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SysUserService sysUserService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SysUsersRolesService sysUsersRolesService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SysRoleService sysRoleService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SysRolesPermissionsService sysRolesPermissionsService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SysPermissionService sysPermissionService;</span><br><span class="line">    /**</span><br><span class="line">     * 授权操作</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;</span><br><span class="line">        System.out.println(&quot;用户授权数据获取&quot;+principalCollection);</span><br><span class="line">        //获取用户名</span><br><span class="line">        String username = principalCollection.getPrimaryPrincipal().toString();</span><br><span class="line">        //通过用户名查询用户ID</span><br><span class="line">        SysUser sysUser = sysUserService.getSysUserByUsername(username);</span><br><span class="line">        //获取当前用户下的所有角色</span><br><span class="line">        List&lt;SysUsersRoles&gt; sysUsersRoles = sysUsersRolesService.getSysUsersRoles(sysUser.getUserId());</span><br><span class="line">        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();</span><br><span class="line">        //将当前用户下的所有角色名称封装进SimpleAuthorizationInfo对象中</span><br><span class="line">        Set&lt;String&gt; roleNames = new HashSet&lt;&gt;();</span><br><span class="line">        for (SysUsersRoles usersRole : sysUsersRoles) &#123;</span><br><span class="line">            //通过角色ID查询角色名称</span><br><span class="line">            SysRole sysRole = sysRoleService.getSysRole(usersRole.getRoleId());</span><br><span class="line">            roleNames.add(sysRole.getRoleName());</span><br><span class="line">            //通过角色查询当前用户的操作权限名称</span><br><span class="line">            List&lt;SysRolesPermissions&gt; rolesPermissions = sysRolesPermissionsService.getSysRolesPermissionsList(usersRole.getRoleId());</span><br><span class="line">            Set&lt;String&gt; permissionList = new HashSet&lt;&gt;();</span><br><span class="line">            for (SysRolesPermissions rolesPermission : rolesPermissions) &#123;</span><br><span class="line">                //通过permissionId查询名称</span><br><span class="line">                SysPermission permission = sysPermissionService.getSysPermission(rolesPermission.getPermissionId());</span><br><span class="line">                permissionList.add(permission.getPermissionName());</span><br><span class="line">            &#125;</span><br><span class="line">            info.addStringPermissions(permissionList);</span><br><span class="line">        &#125;</span><br><span class="line">        //将角色名称设置进SimpleAuthorizationInfo对象中</span><br><span class="line">        info.addRoles(roleNames);</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 认证操作</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;</span><br><span class="line">        System.out.println(&quot;用户认证数据获取&quot;+authenticationToken);</span><br><span class="line">        //获取用户名</span><br><span class="line">        String username = authenticationToken.getPrincipal().toString();</span><br><span class="line">        //使用用户名向数据库中查询数据</span><br><span class="line">        SysUser sysUser = sysUserService.getSysUserByUsername(username);</span><br><span class="line">        //如果用户为空抛出异常在控制器层进行捕获</span><br><span class="line">        if(sysUser==null)&#123;</span><br><span class="line">            throw new AuthenticationException(&quot;用户名或密码错误&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;===========&quot;+sysUser);</span><br><span class="line">        //将查询出来的用户信息,通过SimpleAuthenticationInfo对象传递给安全管理器</span><br><span class="line">        //将数据库中查询出来的盐进行转换</span><br><span class="line">        ByteSource bytes = ByteSource.Util.bytes(sysUser.getSalt());</span><br><span class="line">        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(sysUser.getUsername(),sysUser.getPassword(),bytes,getName());</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-3-密码加密技术-以及自定义Realm配置"><a href="#4-2-3-密码加密技术-以及自定义Realm配置" class="headerlink" title="4.2.3 密码加密技术/以及自定义Realm配置"></a>4.2.3 密码加密技术/以及自定义Realm配置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--注册安全管理器--&gt;</span><br><span class="line">&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class="line">    &lt;!--配置自定义realm,从数据库获取数据--&gt;</span><br><span class="line">    &lt;property name=&quot;realm&quot; ref=&quot;sysUserRealm&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--配置自定义realm--&gt;</span><br><span class="line">&lt;bean id=&quot;sysUserRealm&quot; class=&quot;com.qianfeng.shiro.SysUserRealm&quot;&gt;</span><br><span class="line">    &lt;!--设置密码加密方式(MD5盐值加密)--&gt;</span><br><span class="line">    &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--配置加密--&gt;</span><br><span class="line">&lt;bean id=&quot;credentialsMatcher&quot; class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt;</span><br><span class="line">    &lt;!--加密类型--&gt;</span><br><span class="line">    &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;MD5&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--迭代次数--&gt;</span><br><span class="line">    &lt;property name=&quot;hashIterations&quot; value=&quot;1024&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-多Realm实现"><a href="#4-3-多Realm实现" class="headerlink" title="4.3 多Realm实现"></a>4.3 多Realm实现</h4><ul>
<li><p>为什么要使用多Realm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果当前应用多了很多外来用户(外来用户可能是公司兼并,或者是其他应用合并过来的等,总之认证数据不在同一个表里).</span><br><span class="line">这时候一个Realm在实现起来比较不容易,可能两个表中,用户密码的加密方式不同,这时候一个Realm很难实现这样的策略,对于这种情况,Shiro提供了多Realm实现方式.</span><br></pre></td></tr></table></figure></li>
<li><p>设置方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shiro中提供了一个多Realm的管理类ModularRealmAuthenticator帮助Shiro框架进行多个Realm管理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--注册安全管理器--&gt;</span><br><span class="line">&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class="line">    &lt;!--在安全管理器中设置多Realm管理器,重点: 多Realm策略,authenticator必须配置在realms上面,否则认证不通过--&gt;</span><br><span class="line">    &lt;property name=&quot;authenticator&quot; ref=&quot;authenticator&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--配置多Realm--&gt;</span><br><span class="line">    &lt;property name=&quot;realms&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;ref bean=&quot;userRealm01&quot;&gt;&lt;/ref&gt;</span><br><span class="line">            &lt;ref bean=&quot;userRealm02&quot;&gt;&lt;/ref&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--配置多Realm管理器--&gt;</span><br><span class="line">&lt;bean id=&quot;authenticator&quot; class=&quot;org.apache.shiro.authc.pam.ModularRealmAuthenticator&quot;&gt;</span><br><span class="line">    &lt;!--设置多Realm管理器的策略--&gt;</span><br><span class="line">    &lt;property name=&quot;authenticationStrategy&quot;&gt;</span><br><span class="line">        &lt;!--默认策略--&gt;</span><br><span class="line">        &lt;bean class=&quot;org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--配置Realm01--&gt;</span><br><span class="line">&lt;bean id=&quot;userRealm01&quot; class=&quot;com.qianfeng.shiro.SysUserRealm&quot;&gt;</span><br><span class="line">    &lt;!--使用内部bean设置加密方式--&gt;</span><br><span class="line">    &lt;property name=&quot;credentialsMatcher&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;MD5&quot;&gt;&lt;/property&gt;</span><br><span class="line">            &lt;property name=&quot;hashIterations&quot; value=&quot;1024&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--配置Realm02--&gt;</span><br><span class="line">&lt;bean id=&quot;userRealm02&quot; class=&quot;com.qianfeng.shiro.SysUserRealm&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;credentialsMatcher&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;hashAlgorithmName&quot; value=&quot;SHA-1&quot;&gt;&lt;/property&gt;</span><br><span class="line">            &lt;property name=&quot;hashIterations&quot; value=&quot;1024&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>多Realm策略</p>
</li>
<li><ul>
<li><p>FirstSuccessfulStrategy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当有一个Realm认证成功就为成功,只返回第一个Realm身份验证 成功的认证信息,其他的忽略</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>AtLeastOneSuccessfulStrategy(默认)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只要有一个Realm验证成功即可,和FirstSuccessfulStrategy不同,返回所有Realm身份验证成功的认证信息</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>AllSuccessfulStrategy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所有Realm验证成功才算成功,且返回所有Realm身份验证成功的认证信息,如果有一个失败就失败</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="4-4-Shiro的缓存"><a href="#4-4-Shiro的缓存" class="headerlink" title="4.4 Shiro的缓存"></a>4.4 Shiro的缓存</h4><ul>
<li><p>开启缓存并配置缓存(在自定义Realm中定义)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--配置自定义realm--&gt;</span><br><span class="line">&lt;bean id=&quot;sysUserRealm&quot; class=&quot;com.qianfeng.shiro.SysUserRealm&quot;&gt;</span><br><span class="line">    &lt;!--设置密码加密方式(MD5盐值加密)--&gt;</span><br><span class="line">    &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--开启shiro缓存--&gt;</span><br><span class="line">    &lt;property name=&quot;cachingEnabled&quot; value=&quot;true&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--启用身份验证缓存,默认false--&gt;</span><br><span class="line">    &lt;property name=&quot;authenticationCachingEnabled&quot; value=&quot;true&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--启用授权缓存,默认false--&gt;</span><br><span class="line">    &lt;property name=&quot;authorizationCachingEnabled&quot; value=&quot;true&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--缓存 AuthenticationInfo 信息的缓存名称--&gt;</span><br><span class="line">    &lt;property name=&quot;authenticationCacheName&quot; value=&quot;authenticationCache&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--缓存 AuthorizationInfo 信息的缓存名称--&gt;</span><br><span class="line">    &lt;property name=&quot;authorizationCacheName&quot; value=&quot;authorizationCache&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--配置ehcache缓存--&gt;</span><br><span class="line">    &lt;property name=&quot;cacheManager&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-常见的JSP标签"><a href="#4-4-常见的JSP标签" class="headerlink" title="4.4 常见的JSP标签"></a>4.4 常见的JSP标签</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shiro为JSP页面提供了标签库类似于我们的JSTL,标签库地址为:</span><br><span class="line">&lt;%@taglib prefix=&quot;shiro&quot; uri=&quot;http://shiro.apache.org/tags&quot; %&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>guest 标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;shiro:guest&gt;</span><br><span class="line">    欢迎游客访问，&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/login.jsp&quot;&gt;登录&lt;/a&gt;</span><br><span class="line">&lt;/shiro:guest&gt;</span><br><span class="line"></span><br><span class="line">用户没有身份验证时显示相应信息，即游客访问信息</span><br></pre></td></tr></table></figure></li>
<li><p>authenticated 标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;shiro:authenticated&gt;</span><br><span class="line">    用户[&lt;shiro:principal/&gt;]已身份验证通过</span><br><span class="line">&lt;/shiro:authenticated&gt;</span><br><span class="line"></span><br><span class="line">用户已经身份验证通过，即 Subject.login 登录成功</span><br></pre></td></tr></table></figure></li>
<li><p>principal 标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;shiro:principal/&gt;</span><br><span class="line"></span><br><span class="line">显示用户身份信息</span><br></pre></td></tr></table></figure></li>
<li><p>hasRole 标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;</span><br><span class="line">    用户[&lt;shiro:principal/&gt;]拥有角色admin</span><br><span class="line">&lt;/shiro:hasRole&gt;</span><br><span class="line"></span><br><span class="line">如果当前 Subject 有角色admin,显示内部内容</span><br></pre></td></tr></table></figure></li>
<li><p>hasAnyRoles 标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;shiro:hasAnyRoles name=&quot;admin,user&quot;&gt;</span><br><span class="line">    用户[&lt;shiro:principal/&gt;]拥有角色admin或user&lt;br/&gt;</span><br><span class="line">&lt;/shiro:hasAnyRoles&gt;</span><br><span class="line"></span><br><span class="line">如果当前 Subject 有任意一个角色（或的关系）将显示内部内容</span><br></pre></td></tr></table></figure></li>
<li><p>hasPermission 标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;shiro:hasPermission name=&quot;user:create&quot;&gt;</span><br><span class="line">    用户[&lt;shiro:principal/&gt;]拥有权限user:create&lt;br/&gt;</span><br><span class="line">&lt;/shiro:hasPermission&gt;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-Shiro的会话管理"><a href="#4-5-Shiro的会话管理" class="headerlink" title="4.5 Shiro的会话管理"></a>4.5 Shiro的会话管理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、所谓会话，即用户访问应用时保持的连接关系,会话不结束,服务器可以一直识别当前用户</span><br><span class="line">2、如果关闭浏览器,此次会话结束,下次在访问服务器,服务器会认为是全新的一次访问.需要重新认证</span><br><span class="line">3、如果长时间保持连接,但是用户没有任何操作,那么会出现会话超时的问题,默认tomcat为30分钟</span><br></pre></td></tr></table></figure></li>
<li><p>Shiro多采用DefaultWebSessionManager进行会话管理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--会话管理--&gt;</span><br><span class="line">&lt;bean id=&quot;webSessionManager&quot; class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt;</span><br><span class="line">    &lt;!--会话超时时间,单位毫秒--&gt;</span><br><span class="line">    &lt;property name=&quot;globalSessionTimeout&quot; value=&quot;10000&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置完会话之后将其设置到安全管理器中--&gt;</span><br><span class="line">&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class="line">    &lt;!--配置自定义realm,从数据库获取数据--&gt;</span><br><span class="line">    &lt;property name=&quot;realm&quot; ref=&quot;sysUserRealm&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--会话管理--&gt;</span><br><span class="line">    &lt;property name=&quot;sessionManager&quot; ref=&quot;webSessionManager&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>重启服务登陆,查看会话过期时间是否生效</p>
</li>
</ul>
<h4 id="4-6-记住我功能实现"><a href="#4-6-记住我功能实现" class="headerlink" title="4.6 记住我功能实现"></a>4.6 记住我功能实现</h4><ul>
<li><p>新增记住我测试页面 rememberme.jsp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;记住我页面测试&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在控制器中添加方法(测试记住我)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  记住我页面测试</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(value = &quot;/testRememberMe&quot;)</span><br><span class="line">public String testRememberMe()&#123;</span><br><span class="line">    System.out.println(&quot;测试记住我...&quot;);</span><br><span class="line">    //跳转记住我页面</span><br><span class="line">    return &quot;rememberme&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在配置文件中配置记住我功能(在安全管理器中)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--注册安全管理器--&gt;</span><br><span class="line">&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class="line">    &lt;!--配置自定义realm,从数据库获取数据--&gt;</span><br><span class="line">    &lt;property name=&quot;realm&quot; ref=&quot;sysUserRealm&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--会话管理--&gt;</span><br><span class="line">    &lt;property name=&quot;sessionManager&quot; ref=&quot;webSessionManager&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--记住我--&gt;</span><br><span class="line">    &lt;property name=&quot;rememberMeManager&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;cookie&quot;&gt;</span><br><span class="line">                &lt;bean class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;</span><br><span class="line">                    &lt;!--自定义cookie名称--&gt;</span><br><span class="line">                    &lt;constructor-arg value=&quot;qianfeng&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">                    &lt;!--防止前端js使用document.cookie获取cookie--&gt;</span><br><span class="line">                    &lt;property name=&quot;httpOnly&quot; value=&quot;true&quot;&gt;&lt;/property&gt;</span><br><span class="line">                    &lt;!--过期时间,默认在浏览器关闭是过期 -1 有效期30天--&gt;</span><br><span class="line">                    &lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot;&gt;&lt;/property&gt;</span><br><span class="line">                &lt;/bean&gt;</span><br><span class="line">            &lt;/property&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>修改ShiroFilterFactoryBean定义的规则(添加记住我拦截规则)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;</span><br><span class="line">    &lt;!--配置安全管理器--&gt;</span><br><span class="line">    &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--如果访问的页面或者是请求地址需要认证才能访问,在没有访问的时候访问了,跳转此地址--&gt;</span><br><span class="line">    &lt;property name=&quot;loginUrl&quot; value=&quot;/jumpLogin&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--设置没有授权需要被跳转的地址--&gt;</span><br><span class="line">    &lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/jumpUnauthorized&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--设置拦截规则--&gt;</span><br><span class="line">    &lt;property name=&quot;filterChainDefinitions&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            # anon: shiro的核心过滤器,表示/这个请求,可以匿名访问</span><br><span class="line">            / = anon</span><br><span class="line">            /home = anon</span><br><span class="line">            /jumpLogin = anon</span><br><span class="line">            /jumpRegister = anon</span><br><span class="line">            /register = anon</span><br><span class="line">            /userLogin = anon</span><br><span class="line"></span><br><span class="line">            # authc: shiro的核心过滤器,表示getUserList必须认证(登陆)才能访问</span><br><span class="line">            /getUserList = authc</span><br><span class="line">            # roles: shiro的核心过滤器,表示jumpEdit必须拥有admin角色才能访问</span><br><span class="line">            /jumpEdit = authc,roles[admin]</span><br><span class="line">            # ** :通配符,表示除了上面配置的拦截,其余的所有请求都需要认证</span><br><span class="line">            #/** = authc  #测试记住我,将通配拦截取消</span><br><span class="line">            # user:shiro的核心过滤器,表示地址可以使用记住我登陆</span><br><span class="line">            /testRememberMe = user</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>控制器中修改登陆的规则(在登陆中调用Shiro记住我API方法)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 用户登录</span><br><span class="line"> * @param username: 用户名</span><br><span class="line"> * @param password: 密码</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(value = &quot;/userLogin&quot;)</span><br><span class="line">public String userLogin(String username,String password)&#123;</span><br><span class="line">    System.out.println(&quot;用户登录...入参为:&quot;+username+&quot;=&quot;+password);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用户登录采用Shiro帮助我们进行认证和授权</span><br><span class="line">     */</span><br><span class="line">    //获取Shiro实体</span><br><span class="line">    Subject subject = SecurityUtils.getSubject();</span><br><span class="line">    //使用Shiro提供的API对象封装前端传送过来的请求数据(用户名和密码)</span><br><span class="line">    UsernamePasswordToken token = new UsernamePasswordToken(username, password);</span><br><span class="line">    token.setRememberMe(true);//记住我</span><br><span class="line">    //调用Shiro提供的方法进行验证</span><br><span class="line">    try &#123;</span><br><span class="line">        subject.login(token);</span><br><span class="line">    &#125;catch (UnknownAccountException uae)&#123;</span><br><span class="line">        System.out.println(&quot;用户名不存在:&quot;+uae.getMessage());</span><br><span class="line">    &#125;catch (IncorrectCredentialsException ice)&#123;</span><br><span class="line">        System.out.println(&quot;密码错误:&quot;+ice.getMessage());</span><br><span class="line">    &#125;catch (LockedAccountException lae)&#123;</span><br><span class="line">        System.out.println(&quot;用户被锁定:&quot;+lae.getMessage());</span><br><span class="line">    &#125;catch (AuthenticationException ae)&#123;</span><br><span class="line">        System.out.println(&quot;其他异常:&quot;+ae.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    //登陆成功跳转列表页(列表页需要认证才可以访问)</span><br><span class="line">    return &quot;redirect:/getUserList&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试(打开浏览器调试模式)</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2021/08/08/SpringBoot/</url>
    <content><![CDATA[<h2 id="第一章-SpringBoot简介"><a href="#第一章-SpringBoot简介" class="headerlink" title="第一章 SpringBoot简介"></a>第一章 SpringBoot简介</h2><h3 id="第1节-SpringBoot是什么"><a href="#第1节-SpringBoot是什么" class="headerlink" title="第1节 SpringBoot是什么"></a>第1节 SpringBoot是什么</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.SpringBoot是一个可以快速创建可运行的、独立的、生产级的基于Spring的应用程序</span><br><span class="line">2.SpringBoot采用一种约定优于配置的设计理念,可以快速让用户创建出一个可运行的基于Spring的应用</span><br></pre></td></tr></table></figure>



<h3 id="第2节-SpringBoot的优势"><a href="#第2节-SpringBoot的优势" class="headerlink" title="第2节 SpringBoot的优势"></a>第2节 SpringBoot的优势</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.快速构建项目</span><br><span class="line">2.对主流的开发框架无需配置集成,会自动的集成到一起(约定优于配置)</span><br><span class="line">3.项目可独立运行，不需要外部servlet容器(不需要额外配置tomcat或者jetty容器)</span><br><span class="line">4.提供运行时的应用监控(健康检查机制)</span><br><span class="line">5.极大的提高了开发部署效率</span><br></pre></td></tr></table></figure>

<h3 id="第3节-SpringBoot的系统需求"><a href="#第3节-SpringBoot的系统需求" class="headerlink" title="第3节 SpringBoot的系统需求"></a>第3节 SpringBoot的系统需求</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前版本的系统需求:</span><br><span class="line">1、JDK8到JDK12(包含)版本</span><br><span class="line">2、Spring框架版本5.1.19.RELEASE或者更高</span><br><span class="line">3、项目构建工具</span><br><span class="line">    - 3.1 Maven版本 3.3+</span><br><span class="line">    - 3.2 Gradle版本 4.x (4.4 and later) and 5.x</span><br><span class="line">4、Servlet Containers</span><br><span class="line">    - 4.1 Tomcat 9.0</span><br><span class="line">    - 4.2 Jetty 9.4</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第二章-快速入门"><a href="#第二章-快速入门" class="headerlink" title="第二章 快速入门"></a>第二章 快速入门</h2><h3 id="第1节-SpringBoot的脚手架"><a href="#第1节-SpringBoot的脚手架" class="headerlink" title="第1节 SpringBoot的脚手架"></a>第1节 SpringBoot的脚手架</h3><ul>
<li>脚手架的概念</li>
</ul>
<blockquote>
<p>在我们软件开发中的脚手架的概念,类似于我们的maven工具一样,以一种预先定义好的方式生成特定环境,特定的项目目录结构,并且预先定义好了每一个目录文件的具体功能</p>
</blockquote>
<ul>
<li>官网脚手架地址</li>
</ul>
<blockquote>
<p><a href="https://start.spring.io/">https://start.spring.io/</a></p>
</blockquote>
<ul>
<li>阿里云脚手架地址</li>
</ul>
<blockquote>
<p><a href="https://start.aliyun.com/">https://start.aliyun.com</a></p>
</blockquote>
<h3 id="第2节-创建SpringBoot项目的方式"><a href="#第2节-创建SpringBoot项目的方式" class="headerlink" title="第2节 创建SpringBoot项目的方式"></a>第2节 创建SpringBoot项目的方式</h3><ul>
<li>使用官网提供的工具创建(Spring官网下载sts)</li>
<li>使用IDEA创建</li>
<li>使用脚手架在线创建</li>
</ul>
<h3 id="第3节-SpringBoot项目结构以及依赖"><a href="#第3节-SpringBoot项目结构以及依赖" class="headerlink" title="第3节 SpringBoot项目结构以及依赖"></a>第3节 SpringBoot项目结构以及依赖</h3><ul>
<li>SpringBoot的目录结构</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB76efccf07c4bbb553652222d2da541e8?method=download&shareKey=bc1260216cde3c5bd15bb2267451a99c"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB76efccf07c4bbb553652222d2da541e8?method=download&shareKey=bc1260216cde3c5bd15bb2267451a99c" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><p>SpringBoot的依赖样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;!--带有starter样式--&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第4节-快速入门代码编写"><a href="#第4节-快速入门代码编写" class="headerlink" title="第4节 快速入门代码编写"></a>第4节 快速入门代码编写</h3><ul>
<li>使用IDEA创建项目(2.1.14版本)</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB66d437702b43e291f90a3275a6aacc79?method=download&shareKey=3c6ccb36c4455c39c6127cb77dfd0314"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB66d437702b43e291f90a3275a6aacc79?method=download&shareKey=3c6ccb36c4455c39c6127cb77dfd0314" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li>勾选web依赖(首先创建一个web项目[相当于我们的SpringMVC项目])</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEBe198f55313100d747af43988a9c3aa0a?method=download&shareKey=f81488b987b73b481bf5c7af6c4eee6c"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBe198f55313100d747af43988a9c3aa0a?method=download&shareKey=f81488b987b73b481bf5c7af6c4eee6c" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><p>编写CRUD方法(API方式)</p>
</li>
<li><ul>
<li><p>编写代码需要的POJO类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer bookId;</span><br><span class="line">    private String bookName;</span><br><span class="line">    private Double price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>CRUD代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加图书(方式一)</span><br><span class="line">     * PostMapping: 是SpringBoot新增注解,由RequestMapping和RequestMethod.POST组合而成</span><br><span class="line">     */</span><br><span class="line">    //@RequestMapping(value = &quot;/addBook&quot;,method = RequestMethod.POST)</span><br><span class="line">    @PostMapping(value = &quot;/addBook1&quot;)</span><br><span class="line">    public Object addBook1(Book book)&#123;</span><br><span class="line">        System.out.println(&quot;添加图书1...入参为: &quot;+book);</span><br><span class="line">        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.put(&quot;code&quot;,200);</span><br><span class="line">        result.put(&quot;msg&quot;,&quot;OK&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加图书(方式二)</span><br><span class="line">     * 如果后台请求参数使用@RequestBody修饰那么前端发送数据需要设置请求头headers</span><br><span class="line">     * Content-Type: application/json</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(value = &quot;/addBook2&quot;)</span><br><span class="line">    public Object addBook2(@RequestBody Book book)&#123;</span><br><span class="line">        System.out.println(&quot;添加图书2...入参为: &quot;+book);</span><br><span class="line">        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.put(&quot;code&quot;,200);</span><br><span class="line">        result.put(&quot;msg&quot;,&quot;OK&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除图书(方式一)</span><br><span class="line">     */</span><br><span class="line">    @DeleteMapping(value = &quot;/deleteBook1&quot;)</span><br><span class="line">    public Object deleteBook1(Integer bookId)&#123;</span><br><span class="line">        System.out.println(&quot;删除图书1...入参为: &quot;+bookId);</span><br><span class="line">        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.put(&quot;code&quot;,200);</span><br><span class="line">        result.put(&quot;msg&quot;,&quot;OK&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 删除图书(方式二)</span><br><span class="line">     */</span><br><span class="line">    @DeleteMapping(value = &quot;/deleteBook2/&#123;bookId&#125;&quot;)</span><br><span class="line">    public Object deleteBook2(@PathVariable(&quot;bookId&quot;) Integer bookId)&#123;</span><br><span class="line">        System.out.println(&quot;删除图书2...入参为: &quot;+bookId);</span><br><span class="line">        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.put(&quot;code&quot;,200);</span><br><span class="line">        result.put(&quot;msg&quot;,&quot;OK&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 更新图书(方式一)</span><br><span class="line">     */</span><br><span class="line">    @PutMapping(value = &quot;/updateBook1&quot;)</span><br><span class="line">    public Object updateBook1(Book book)&#123;</span><br><span class="line">        System.out.println(&quot;修改图书1...入参为: &quot;+book);</span><br><span class="line">        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.put(&quot;code&quot;,200);</span><br><span class="line">        result.put(&quot;msg&quot;,&quot;OK&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 更新图书(方式二)</span><br><span class="line">     */</span><br><span class="line">    @PutMapping(value = &quot;/updateBook2&quot;)</span><br><span class="line">    public Object updateBook2(@RequestBody Book book)&#123;</span><br><span class="line">        System.out.println(&quot;修改图书2...入参为: &quot;+book);</span><br><span class="line">        Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        result.put(&quot;code&quot;,200);</span><br><span class="line">        result.put(&quot;msg&quot;,&quot;OK&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询图书(方式一)</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(value = &quot;/queryBooks1&quot;)</span><br><span class="line">    public Object queryBooks1(int pageNo,int pageSize)&#123;</span><br><span class="line">        System.out.println(&quot;查询图书1...入参为: pageNo:&quot;+pageNo+&quot; pageSize:&quot;+pageSize);</span><br><span class="line">        Book book1 = new Book(1001,&quot;三国演义&quot;,66.66);</span><br><span class="line">        Book book2 = new Book(1003,&quot;红楼梦&quot;,99.66);</span><br><span class="line">        Book book3 = new Book(1002,&quot;水浒传&quot;,22.66);</span><br><span class="line">        List&lt;Book&gt; books = new ArrayList&lt;&gt;();</span><br><span class="line">        books.add(book1);</span><br><span class="line">        books.add(book2);</span><br><span class="line">        books.add(book3);</span><br><span class="line">        return books;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询图书(方式二)</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(value = &quot;/queryBooks2/&#123;pageNo&#125;/&#123;pageSize&#125;&quot;)</span><br><span class="line">    public Object queryBooks2(@PathVariable(&quot;pageNo&quot;) int pageNo,@PathVariable(&quot;pageSize&quot;) int pageSize)&#123;</span><br><span class="line">        System.out.println(&quot;查询图书2...入参为: pageNo:&quot;+pageNo+&quot; pageSize:&quot;+pageSize);</span><br><span class="line">        Book book1 = new Book(1001,&quot;三国演义&quot;,66.66);</span><br><span class="line">        Book book2 = new Book(1003,&quot;红楼梦&quot;,99.66);</span><br><span class="line">        Book book3 = new Book(1002,&quot;水浒传&quot;,22.66);</span><br><span class="line">        List&lt;Book&gt; books = new ArrayList&lt;&gt;();</span><br><span class="line">        books.add(book1);</span><br><span class="line">        books.add(book2);</span><br><span class="line">        books.add(book3);</span><br><span class="line">        return books;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>文件上传/下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 单文件上传</span><br><span class="line"> */</span><br><span class="line">@PostMapping(value = &quot;/uploadFile&quot;)</span><br><span class="line">public Object uploadFile(@RequestParam(&quot;file&quot;)MultipartFile file) throws IOException &#123;</span><br><span class="line">    System.out.println(&quot;文件上传...文件名为: &quot;+file.getOriginalFilename());</span><br><span class="line">    //将文件保存到指定位置 比如保存到D盘</span><br><span class="line">    file.transferTo(new File(&quot;d:\\&quot;+file.getOriginalFilename()));</span><br><span class="line">    Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">    result.put(&quot;code&quot;,200);</span><br><span class="line">    result.put(&quot;msg&quot;,&quot;OK&quot;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 多文件文件上传</span><br><span class="line"> */</span><br><span class="line">@PostMapping(value = &quot;/uploadFiles&quot;)</span><br><span class="line">public Object uploadFiles(@RequestParam(&quot;file&quot;)MultipartFile[] files) throws IOException &#123;</span><br><span class="line">    for (MultipartFile file : files) &#123;</span><br><span class="line">        System.out.println(&quot;文件上传...文件名为: &quot;+file.getOriginalFilename());</span><br><span class="line">        //将文件保存到指定位置 比如保存到D盘</span><br><span class="line">        file.transferTo(new File(&quot;d:\\&quot;+file.getOriginalFilename()));</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String,Object&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">    result.put(&quot;code&quot;,200);</span><br><span class="line">    result.put(&quot;msg&quot;,&quot;OK&quot;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 文件下载</span><br><span class="line"> */</span><br><span class="line">@GetMapping(value = &quot;/downLoad&quot;)</span><br><span class="line">public ResponseEntity&lt;byte[]&gt; downLoad() throws IOException &#123;</span><br><span class="line">    System.out.println(&quot;文件下载...&quot;);</span><br><span class="line">    //获取下载文件的输入流</span><br><span class="line">    BufferedInputStream in = new BufferedInputStream(new FileInputStream(new File(&quot;d:\\logo-footer.png&quot;)));</span><br><span class="line">    //创建下载缓冲区</span><br><span class="line">    byte[] body = new byte[in.available()];</span><br><span class="line">    //将输入流数据读入缓冲区</span><br><span class="line">    in.read(body);</span><br><span class="line">    //创建响应头</span><br><span class="line">    HttpHeaders headers = new HttpHeaders();</span><br><span class="line">    //构建文件名称</span><br><span class="line">    String fileName=&quot;abc.png&quot;;</span><br><span class="line">    headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot;+fileName);</span><br><span class="line">    //创建响应状态码</span><br><span class="line">    HttpStatus ok = HttpStatus.OK;</span><br><span class="line">    ResponseEntity&lt;byte[]&gt; response = new ResponseEntity&lt;&gt;(body,headers,ok);</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>JSON数据交互</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private Integer userId;</span><br><span class="line">    private String userName;</span><br><span class="line">    private Date hireDate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * JSON数据返回时间格式处理</span><br><span class="line"> * 当前jackson返回时间格式不符合我们中国人的习惯可以修改成我们的习惯格式</span><br><span class="line"> * 当前jackson返回时间和我们国家的东八区区时查了八个小时所以需要将时区修改为东八区(GMT+8)</span><br><span class="line"> */</span><br><span class="line">@GetMapping(value = &quot;/queryUserJson&quot;)</span><br><span class="line">public List&lt;User&gt; queryUserJson()&#123;</span><br><span class="line">    List&lt;User&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    User u1 = new User(1001,&quot;user01&quot;,new Date());</span><br><span class="line">    User u2 = new User(1002,&quot;user02&quot;,new Date());</span><br><span class="line">    User u3 = new User(1003,&quot;user03&quot;,new Date());</span><br><span class="line">    list.add(u1);</span><br><span class="line">    list.add(u2);</span><br><span class="line">    list.add(u3);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">修改方式:</span><br><span class="line">1、可以在返回值类型的类中添加jackson注解</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Integer userId;</span><br><span class="line">    private String userName;</span><br><span class="line">    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;,timezone = &quot;GMT+8&quot;)</span><br><span class="line">    private Date hireDate;</span><br><span class="line">&#125;</span><br><span class="line">2、采用全局配置方式</span><br></pre></td></tr></table></figure>

<h3 id="第5节-SpringBoot的常用配置"><a href="#第5节-SpringBoot的常用配置" class="headerlink" title="第5节 SpringBoot的常用配置"></a>第5节 SpringBoot的常用配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 服务器端口号</span><br><span class="line">server.port=8080</span><br><span class="line"># 请求上下文地址</span><br><span class="line"># server.servlet.context-path=/book</span><br><span class="line"># 单个文件上传大小</span><br><span class="line">spring.servlet.multipart.max-file-size=10MB</span><br><span class="line"># 上传文件总大小</span><br><span class="line">spring.servlet.multipart.max-request-size=100MB</span><br><span class="line"># 修改jackson格式</span><br><span class="line">spring.jackson.date-format=yyyy-MM-dd HH:mm:ss</span><br><span class="line"># 设置时区</span><br><span class="line">spring.jackson.time-zone=GMT+8</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="第三章-启动方式"><a href="#第三章-启动方式" class="headerlink" title="第三章 启动方式"></a>第三章 启动方式</h2><h3 id="第1节-热部署"><a href="#第1节-热部署" class="headerlink" title="第1节 热部署"></a>第1节 热部署</h3><ul>
<li><p>添加maven依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;&lt;!--设置子项是否依赖，如果不设置为true热加载也不会成功--&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置maven插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;fork&gt;true&lt;/fork&gt;&lt;!-- 如果不配置fork热加载不会成功 --&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>IDEA设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、打开IDEA 在当前路径下: File-&gt;Settings-&gt;Build, Execution, Deployment-&gt;Compiler 勾选Build project automatically 然后确定</span><br><span class="line">2、继续在使用快捷键(Ctrl+Shift+Alt+/)打开面板，选择Registry勾选compiler.automake.allow.when.app.running</span><br></pre></td></tr></table></figure>

<h3 id="第2节-启动方式"><a href="#第2节-启动方式" class="headerlink" title="第2节 启动方式"></a>第2节 启动方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用自带的main方法启动</span><br><span class="line">2. 在当前项目的根目录下(pom文件所在目录)执行 mvn spring-boot:run 命令</span><br><span class="line">3. 执行 java -jar xxx.jar 命令</span><br><span class="line">4. 修改端口号 java -jar xxx.jar --server.port=9999</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第四章-配置文件"><a href="#第四章-配置文件" class="headerlink" title="第四章 配置文件"></a>第四章 配置文件</h2><h3 id="第1节-SpringBoot配置文件的两种格式"><a href="#第1节-SpringBoot配置文件的两种格式" class="headerlink" title="第1节 SpringBoot配置文件的两种格式"></a>第1节 SpringBoot配置文件的两种格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、application.properties</span><br><span class="line">2、application.yml</span><br><span class="line"></span><br><span class="line">上面这是SpringBoot支持的两种配置文件的格式,在开发中使用哪种都可以,最常见的是yml方式.</span><br></pre></td></tr></table></figure>

<h3 id="第2节-配置文件中自定义配置属性的获取"><a href="#第2节-配置文件中自定义配置属性的获取" class="headerlink" title="第2节 配置文件中自定义配置属性的获取"></a>第2节 配置文件中自定义配置属性的获取</h3><ul>
<li><p>@Value(“${名称}”) 获取单个属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在application.properties自定义配置文件</span><br><span class="line">    # 自定义配置</span><br><span class="line">    com.qianfeng.springboot=hello</span><br><span class="line">    name=Tom</span><br><span class="line">    age=18</span><br><span class="line">2. 在我们的Java类中获取</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;com.qianfeng.springboot&#125;&quot;)</span><br><span class="line">private String qianfeng;</span><br><span class="line">@Value(&quot;$&#123;name&#125;&quot;)</span><br><span class="line">private String name;</span><br><span class="line">@Value(&quot;$&#123;age&#125;&quot;)</span><br><span class="line">private Integer age;</span><br><span class="line">/**</span><br><span class="line"> * 测试配置文件获取</span><br><span class="line"> */</span><br><span class="line">@GetMapping(value = &quot;/getProperties&quot;)</span><br><span class="line">public String getProperties()&#123;</span><br><span class="line">    System.out.println(qianfeng);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    return &quot;ok&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@ConfigurationProperties 获取实体对象</p>
</li>
<li><ul>
<li><p>自定义配置(application.yml)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user:</span><br><span class="line">  userId: 1001</span><br><span class="line">  userName: Tom</span><br><span class="line">  hireDate: 2020-12-12 22:22:22</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>使用实体对象压入配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component  //加入IOC容器进行实例化</span><br><span class="line">@ConfigurationProperties(prefix = &quot;user&quot;) //指定配置前缀</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Integer userId;</span><br><span class="line">    private String userName;</span><br><span class="line">    @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) //时间格式</span><br><span class="line">    private Date hireDate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意:当使用ConfigurationProperties注解时会报一个警告,官网解释需添加一个依赖即可</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">	&lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private User user;</span><br><span class="line">/**</span><br><span class="line"> * 测试配置文件获取</span><br><span class="line"> */</span><br><span class="line">@GetMapping(value = &quot;/getProperties&quot;)</span><br><span class="line">public String getProperties()&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    return &quot;ok&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第3节-SpringBoot多环境配置"><a href="#第3节-SpringBoot多环境配置" class="headerlink" title="第3节 SpringBoot多环境配置"></a>第3节 SpringBoot多环境配置</h3></li>
</ul>
</li>
<li><p>多环境配置(方式一)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SpringBoot多环境管理必须要遵循SpringBoot官方配置文件命名规则 application-&#123;profile&#125;.properties或者application-&#123;profile&#125;.yml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eg: </span><br><span class="line">application-dev.yml  开发环境 </span><br><span class="line">application-test.yml 测试环境 </span><br><span class="line">application-pro.yml  生产环境</span><br></pre></td></tr></table></figure>

<blockquote>
<p>按照这个格式编写好的配置默认不会被SpringBoot执行,在运行时springboot还会默认执行application.yml文件,可以在appliaction.yml配置文件中设置Spring.profiles.active=dev 这样在项目运行时就会走application-dev.yml配置,但是这样还是需要频繁的修改配置,所以SpringBoot还提供了一个方式在不修改配置的情况下动态的进行配置文件修改</p>
</blockquote>
</li>
<li><p>多环境配置(方式二)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在同一个文件中进行多环境配置的时候使用 --- 三个横线方式进行分割,在yml文件中配置 </span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev</span><br><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  profiles: test</span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">---</span><br><span class="line">spring:</span><br><span class="line">  profiles: pro</span><br><span class="line">server:</span><br><span class="line">  port: 8082</span><br></pre></td></tr></table></figure></li>
<li><p>使用命令动态的选择环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、使用命令将项目打成jar包,然后使用java -jar xxx.jar 运行</span><br><span class="line">java -jar thymeleaf01-0.0.1-SNAPSHOT.jar --spring.profiles.active=pro</span><br><span class="line"></span><br><span class="line">2、使用maven命令运行(2.x版本)</span><br><span class="line">mvn spring-boot:run -Dspring-boot.run.profiles=test</span><br></pre></td></tr></table></figure></li>
<li><p>maven命令地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/html/#run-example-active-profiles</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第五章-异常处理"><a href="#第五章-异常处理" class="headerlink" title="第五章 异常处理"></a>第五章 异常处理</h2><h3 id="第1节-单个异常处理"><a href="#第1节-单个异常处理" class="headerlink" title="第1节 单个异常处理"></a>第1节 单个异常处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设置指定捕获当前类中的哪些异常,当前设置为Exception异常以及其子类都会被捕获到</span><br><span class="line">@ExceptionHandler(value= &#123;Exception.class&#125;)</span><br><span class="line">public Object testException(Exception e)&#123;</span><br><span class="line">	Map&lt;String,Object&gt; result = new HashMap();</span><br><span class="line">	result.put(&quot;code&quot;,200);</span><br><span class="line">	result.put(&quot;msg&quot;:e.getMessage());</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第2节-统一异常处理"><a href="#第2节-统一异常处理" class="headerlink" title="第2节 统一异常处理"></a>第2节 统一异常处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class CommonException &#123;</span><br><span class="line">    @ExceptionHandler(value = &#123;Exception.class&#125;)</span><br><span class="line">    public Object testException(Exception e)&#123;</span><br><span class="line">        Map&lt;String,Object&gt; result = new HashMap();</span><br><span class="line">    	result.put(&quot;code&quot;,200);</span><br><span class="line">    	result.put(&quot;msg&quot;:e.getMessage());</span><br><span class="line">    	return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>异常的优先级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先查找当前类里面的异常处理,如果不存在在去统一异常处理类中匹配</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第六章-日志设置"><a href="#第六章-日志设置" class="headerlink" title="第六章 日志设置"></a>第六章 日志设置</h2><h3 id="第1节-SpringBoot的日志"><a href="#第1节-SpringBoot的日志" class="headerlink" title="第1节 SpringBoot的日志"></a>第1节 SpringBoot的日志</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SpringBoot默认使用的是Slf4J+logback的日志</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">//日志的依赖一般都不需要加,因为很多其他依赖都带着此依赖,例如 web依赖</span><br></pre></td></tr></table></figure>

<h4 id="1-1-日志的配置"><a href="#1-1-日志的配置" class="headerlink" title="1.1 日志的配置"></a>1.1 日志的配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改日志级别</span><br><span class="line">logging.level.root=INFO</span><br><span class="line"># 日志输出路径(会在当前文件夹下生成一个名字为spring.log的日志文件)</span><br><span class="line">logging.path=C:\\log</span><br><span class="line"># 修改生成的文件名称(会在项目的当前路径下生成一个 xxx.log 日志文件)</span><br><span class="line"># logging.path和logging.file不能同时使用,如果同时使用,那么只有logging.file生效</span><br><span class="line">logging.file=abc.log</span><br></pre></td></tr></table></figure>

<h3 id="第2节-SpringBoot的统一日志处理"><a href="#第2节-SpringBoot的统一日志处理" class="headerlink" title="第2节 SpringBoot的统一日志处理"></a>第2节 SpringBoot的统一日志处理</h3><h4 id="2-1-使用AOP进行日志处理"><a href="#2-1-使用AOP进行日志处理" class="headerlink" title="2.1 使用AOP进行日志处理"></a>2.1 使用AOP进行日志处理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class LogAspect &#123;</span><br><span class="line">    private final static Logger LOGGER = LoggerFactory.getLogger(LogAspect.class);</span><br><span class="line">    @Pointcut(value = &quot;execution(* cn.ukoko.springbootaop.controller..*.*(..))&quot;)</span><br><span class="line">    public void log()&#123;&#125;</span><br><span class="line">    @Around(value = &quot;log()&quot;)</span><br><span class="line">    public Object methodAroud(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = attributes.getRequest();</span><br><span class="line">        //获取主机IP</span><br><span class="line">        LOGGER.info(&quot;IP :&#123;&#125;&quot;,request.getRemoteAddr());</span><br><span class="line">        //获取请求地址</span><br><span class="line">        LOGGER.info(&quot;URL:&#123;&#125;&quot;,request.getRequestURL().toString());</span><br><span class="line">        //获取请求方式</span><br><span class="line">        LOGGER.info(&quot;HTTP Method:&#123;&#125;&quot;,request.getMethod());</span><br><span class="line">        //获取类名和方法名</span><br><span class="line">        LOGGER.info(&quot;Class Method:&#123;&#125;.&#123;&#125;&quot;,joinPoint.getSignature().getDeclaringTypeName(),joinPoint.getSignature().getName());</span><br><span class="line">        Object proceed = joinPoint.proceed();</span><br><span class="line">        LOGGER.info(&quot;Result:&#123;&#125;&quot;,proceed);</span><br><span class="line">        return proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第七章-Spring5-x与Spring4-x版本的差异化"><a href="#第七章-Spring5-x与Spring4-x版本的差异化" class="headerlink" title="第七章 Spring5.x与Spring4.x版本的差异化"></a>第七章 Spring5.x与Spring4.x版本的差异化</h2><blockquote>
<p>Spring5.x版本相比较于4.x版本发生了很大的变化</p>
</blockquote>
<h3 id="第1节-注解的变化"><a href="#第1节-注解的变化" class="headerlink" title="第1节 注解的变化"></a>第1节 注解的变化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. @RestController          : 组合注解(@ResponseBody + @Controller)</span><br><span class="line">2. @SpringBootApplication   : 组合注解(多用于SpringBoot的启动注解)</span><br><span class="line">3. @ImportResource          : 如果一定要使用xml配置文件可以使用此注解加载</span><br><span class="line">4. @ConfigurationProperties : 获取以xxx作为前缀的数据</span><br><span class="line">5. @value                   : 获取以什么命名的数据</span><br></pre></td></tr></table></figure>

<h3 id="第2节-配置文件的变化"><a href="#第2节-配置文件的变化" class="headerlink" title="第2节 配置文件的变化"></a>第2节 配置文件的变化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传统的配置比如ssm框架采用的xml配置,而SpringBoot官方不建议使用xml配置,而是采用传统的API和注解的方式进行配置</span><br></pre></td></tr></table></figure>

<blockquote>
<p>举一个例子(整合一个不遵循SpringBoot约定优于配置的依赖[非start依赖])</p>
</blockquote>
<ul>
<li><p>添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.49&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.20&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>创建配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">applicaton.yml</span><br><span class="line"></span><br><span class="line">username1: root</span><br><span class="line">password1: root</span><br><span class="line">jdbcurl1: jdbc:mysql:///ssm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 如果maven的依赖满足start这样的类型,多半是不需要配置的,这样的类型的依赖可以和SpringBoot直接整合到一起</span><br><span class="line"> * 但是有一些框架或者工具没有提供start这样类型的依赖,在加入依赖之后不会自动整合到SpringBoot上面,这时候就需要我们配置</span><br><span class="line"> */</span><br><span class="line"> //@ImportResource(locations = &#123;&quot;classpath:bean.xml&quot;&#125;)</span><br><span class="line">@Configuration</span><br><span class="line">public class DruidConfiguration &#123;</span><br><span class="line">    </span><br><span class="line">    @Value(&quot;$&#123;username1&#125;&quot;) //在进行配置时候不要取有歧义的名字</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;password1&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line">    @Value(&quot;$&#123;jdbcurl1&#125;&quot;)</span><br><span class="line">    private String jdbcurl;</span><br><span class="line">    /**</span><br><span class="line">     * 配置Druid</span><br><span class="line">     */</span><br><span class="line">    //@Primary //自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常</span><br><span class="line">    @Bean //将方法的返回值加入到IOC容器中,和我们的xml配置中的bean标签功能相同,内部有name属性,设置为IOC容器中的对象取别名</span><br><span class="line">    public DataSource createDruid()&#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        dataSource.setUrl(jdbcurl);</span><br><span class="line">        System.out.println(&quot;------------&quot;+dataSource);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired //从IOC容器中获取对象</span><br><span class="line">private DataSource dataSource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(&quot;从ioc容器中获取对象:&quot;+dataSource);</span><br><span class="line">//获取数据库连接</span><br><span class="line">Connection connection = dataSource.getConnection();</span><br><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">String sql=&quot;SELECT * FROM user&quot;;</span><br><span class="line">ResultSet rs = statement.executeQuery(sql);</span><br><span class="line">while(rs.next())&#123;</span><br><span class="line">    int userId = rs.getInt(&quot;user_id&quot;);</span><br><span class="line">    System.out.println(&quot;userId=&quot;+userId);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第八章-CRUD练习-API版本"><a href="#第八章-CRUD练习-API版本" class="headerlink" title="第八章 CRUD练习(API版本)"></a>第八章 CRUD练习(API版本)</h2><ul>
<li><p>添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>基础配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Mapper: SpringBoot的Mapper层需要添加此注解</span><br><span class="line"></span><br><span class="line"># 数据库配置</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8&amp;useUnicode=true&amp;serverTimezone=GMT%2B8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line"></span><br><span class="line"># mybatis配置</span><br><span class="line">mybatis.mapper-locations=classpath:mapper/*Mapper.xml</span><br><span class="line">mybatis.type-aliases-package=com.ssm.testdemo.entity</span><br><span class="line">mybatis.config-location=classpath:mybatis-config.xml</span><br><span class="line"></span><br><span class="line"># 中文编码(处理请求)</span><br><span class="line">spring.http.encoding.charset=UTF-8</span><br><span class="line">spring.http.encoding.force=true</span><br><span class="line">spring.http.encoding.enabled=true</span><br><span class="line">server.tomcat.uri-encoding=UTF-8</span><br></pre></td></tr></table></figure></li>
<li><p>单元测试(2.1.x版本)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第九章-Thymeleaf模板"><a href="#第九章-Thymeleaf模板" class="headerlink" title="第九章 Thymeleaf模板"></a>第九章 Thymeleaf模板</h2><blockquote>
<p>Thymeleaf是一个web端的并且独立的Java模板引擎,他能够处理HTML、XML、JavaScript、CSS以及纯文本,Thymeleaf的理念是创建一种优雅和易维护的模板,为了实现这一点,它建立在自然模板之上,将逻辑注入到模板文件中,还不会影响到模板被用作设计原型。Thymeleaf一开始就设计了Web标准,SpringBoot官方推荐使用Thymeleaf 而不是JSP</p>
</blockquote>
<h3 id="第1节-快速入门"><a href="#第1节-快速入门" class="headerlink" title="第1节 快速入门"></a>第1节 快速入门</h3><ul>
<li><p>添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring: </span><br><span class="line">    thymeleaf: </span><br><span class="line">        mode: HTML </span><br><span class="line">        cache: false </span><br><span class="line">        encoding: utf-8</span><br></pre></td></tr></table></figure></li>
<li><p>创建页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在templates目录下创建index.html和result.html</span><br><span class="line"></span><br><span class="line">1、index.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!--第一个页面请求--&gt;</span><br><span class="line">    &lt;a href=&quot;/helloworld&quot;&gt;Hello World&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">2、result.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;结果页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!--结果页面--&gt;</span><br><span class="line">    &lt;h1&gt;结果页面&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>创建控制器(@Controller)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author 枫桥夜泊1990</span><br><span class="line"> * @BLOG https://hd1611756908.github.io/</span><br><span class="line"> * @BSITE https://space.bilibili.com/514155929/</span><br><span class="line"> * @DATE 2020/8/8</span><br><span class="line"> */</span><br><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 快速入门</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(value = &quot;/helloworld&quot;)</span><br><span class="line">    public String helloworl()&#123;</span><br><span class="line">        System.out.println(&quot;第一个thymeleaf请求...&quot;);</span><br><span class="line">        return &quot;result&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>刷新前端页面快捷键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl+F9</span><br></pre></td></tr></table></figure>

<h3 id="第2节-常见语法"><a href="#第2节-常见语法" class="headerlink" title="第2节 常见语法"></a>第2节 常见语法</h3></li>
<li><p>index.html</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;/HelloThymeleaf&quot;&gt;HelloThymeleaf&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>result.html</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;结果页&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--结果页面--&gt;</span><br><span class="line">&lt;h1&gt;结果页面&lt;/h1&gt;</span><br><span class="line">&lt;!--显示普通文本,从域对象中获取--&gt;</span><br><span class="line">&lt;p th:text=&quot;$&#123;username&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;!--显示带有样式的普通文本--&gt;</span><br><span class="line">&lt;p th:utext=&quot;$&#123;desc&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;!--显示对象,数据处理(thymeleaf提供了内置对象API可以操作数据,比如对前端显示时间的格式化)--&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p th:text=&quot;$&#123;user.userId&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p th:text=&quot;$&#123;user.userName&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p th:text=&quot;$&#123;user.createTime&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p th:text=&quot;$&#123;#dates.format(user.createTime,&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;!--内置域对象--&gt;</span><br><span class="line">&lt;p th:text=&quot;$&#123;#httpServletRequest.getAttribute(&#x27;password&#x27;)&#125;&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;!--数据遍历  list集合--&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;No.&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;UID&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;创建时间&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;偶数&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;奇数&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr th:each=&quot;x,y:$&#123;users&#125;&quot;&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;y.index+1&#125;&quot;/&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;x.userId&#125;&quot;/&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;x.userName&#125;&quot;/&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;x.createTime&#125;&quot;/&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;y.even&#125;&quot;/&gt;&lt;!--偶数--&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;y.odd&#125;&quot;/&gt;&lt;!--奇数--&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;!--数据遍历  map集合--&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;No.&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;UID&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;姓名&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;创建时间&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;偶数&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;奇数&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr th:each=&quot;x,y:$&#123;map&#125;&quot;&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;y.index+1&#125;&quot;/&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;x.value.userId&#125;&quot;/&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;x.value.userName&#125;&quot;/&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;x.value.createTime&#125;&quot;/&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;y.even&#125;&quot;/&gt;&lt;!--偶数--&gt;</span><br><span class="line">        &lt;td th:text=&quot;$&#123;y.odd&#125;&quot;/&gt;&lt;!--奇数--&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>控制器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(value = &quot;/HelloThymeleaf&quot;)</span><br><span class="line">public String HelloThymeleaf(Model model, HttpServletRequest request)&#123;</span><br><span class="line">    //显示普通文本,从域对象中获取</span><br><span class="line">    model.addAttribute(&quot;username&quot;,&quot;Tom&quot;);</span><br><span class="line">    //显示带有样式的普通文本</span><br><span class="line">    model.addAttribute(&quot;desc&quot;,&quot;&lt;span style=&#x27;color:red&#x27;&gt;你好,中国&lt;/span&gt;&quot;);</span><br><span class="line">    //显示对象,数据处理(thymeleaf提供了内置对象API可以操作数据,比如对前端显示时间的格式化)</span><br><span class="line">    User user = new User(1001,&quot;user01&quot;,new Date());</span><br><span class="line">    model.addAttribute(&quot;user&quot;,user);</span><br><span class="line">    //内置域对象</span><br><span class="line">    request.setAttribute(&quot;password&quot;,&quot;123456&quot;);</span><br><span class="line">    //数据遍历 list</span><br><span class="line">    User user1 = new User(1002,&quot;user02&quot;,new Date());</span><br><span class="line">    User user2 = new User(1003,&quot;user03&quot;,new Date());</span><br><span class="line">    User user3 = new User(1004,&quot;user04&quot;,new Date());</span><br><span class="line">    List&lt;User&gt; users = new ArrayList&lt;&gt;();</span><br><span class="line">    users.add(user1);</span><br><span class="line">    users.add(user2);</span><br><span class="line">    users.add(user3);</span><br><span class="line">    model.addAttribute(&quot;users&quot;,users);</span><br><span class="line">    //数据遍历 map</span><br><span class="line">    Map&lt;String,User&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;user01&quot;,user1);</span><br><span class="line">    map.put(&quot;user02&quot;,user2);</span><br><span class="line">    map.put(&quot;user03&quot;,user3);</span><br><span class="line">    model.addAttribute(&quot;map&quot;,map);</span><br><span class="line">    return &quot;result&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第3节-路径处理"><a href="#第3节-路径处理" class="headerlink" title="第3节 路径处理"></a>第3节 路径处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/js/main.js&#125;&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;a th:href=&quot;@&#123;/show&#125;&quot;&gt;访问controller方法&lt;/a&gt; </span><br><span class="line">&lt;a th:href=&quot;@&#123;/static_index.html&#125;&quot;&gt;访问静态页面&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第4节-条件语句"><a href="#第4节-条件语句" class="headerlink" title="第4节 条件语句"></a>第4节 条件语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">th:if=&quot;boolean&quot; th:if的表达式需为boolean值。如果为true，则标签显示，如果为false，则标签不显示</span><br><span class="line"></span><br><span class="line">th:unless=&quot;boolean&quot; th:unless和th:if相反，表达式也需为boolean值。如果为true，则标签不显示，如果为false，则标签显示</span><br><span class="line"></span><br><span class="line">&lt;span th:if=&quot;$&#123;stat&#125;&quot;&gt;偶&lt;/span&gt;</span><br><span class="line">&lt;span th:unless=&quot;$&#123;stat&#125;&quot;&gt;奇&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第5节-页面引入"><a href="#第5节-页面引入" class="headerlink" title="第5节 页面引入"></a>第5节 页面引入</h3></li>
<li><p>页面引入介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们常常需要在一个页面当中引入另一个页面，例如，公用的导航栏以及页脚页面。thymeleaf中提供了两种方式进行页面引入</span><br></pre></td></tr></table></figure></li>
<li><p>引入方式一[th:replace(替换全部)]</p>
</li>
<li><p>引入方式二[th:include(替换内容)]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、新建需要被引入的页面文件,路径为&quot;/templates/footer.html&quot;</span><br><span class="line"></span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;/&gt;</span><br><span class="line">&lt;footer th:fragment=&quot;companyInfo&quot;&gt; </span><br><span class="line">    &lt;p&gt;设为首页 ©2018 SpringBoot 使用&lt;span th:text=&quot;$&#123;name&#125;&quot;/&gt;前必读意见反馈京ICP证030173号 &lt;/p&gt;</span><br><span class="line">&lt;/footer&gt;</span><br><span class="line"></span><br><span class="line">2、在目标页面引入footer.html有两种方式</span><br><span class="line">    - 2.1 &lt;div th:include=&quot;footer :: companyInfo&quot; th:with=&quot;name=$&#123;username&#125;&quot;/&gt; 可以设置参数 </span><br><span class="line">    - 2.2 &lt;div th:replace=&quot;footer :: companyInfo&quot;/&gt; 设置参数无效,所以直接引入即可</span><br></pre></td></tr></table></figure>

<h3 id="第6节-使用thymeleaf实现CRUD"><a href="#第6节-使用thymeleaf实现CRUD" class="headerlink" title="第6节 使用thymeleaf实现CRUD"></a>第6节 使用thymeleaf实现CRUD</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求路径的参数设置</span><br><span class="line"></span><br><span class="line">&lt;a th:href=&quot;@&#123;/delteUser(userId=$&#123;x.userId&#125;)&#125;&quot;&gt;删除&lt;/a&gt;</span><br><span class="line">删除路径会构建成一个类似于 deleteUser?userId=1000</span><br><span class="line"></span><br><span class="line">&lt;a th:href=&quot;@&#123;/jumpUser/&#123;userId&#125;(userId=$&#123;x.userId&#125;)&#125;&quot;&gt;更新&lt;/a&gt;</span><br><span class="line">更新路径会构建成一个类似于 jumpUser/1000</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第十章-Shiro整合-注解与传统xml对比"><a href="#第十章-Shiro整合-注解与传统xml对比" class="headerlink" title="第十章 Shiro整合(注解与传统xml对比)"></a>第十章 Shiro整合(注解与传统xml对比)</h2><blockquote>
<p>Spring5.x版本在SpringBoot中官方推荐使用Java配置的方式来进行与第三方框架的集成<br>我们这里以springBoot和Shiro的整合方式来讲解Java的配置.</p>
</blockquote>
<ul>
<li><p>版本介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SpringBoot版本   : 2.1.14.RELEASE</span><br><span class="line">shiro-spring版本 : 1.5.0</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">//如果使用Shiro的注解功能需要添加springboot的aop依赖</span><br><span class="line">//同时在application.properties中配置spring.aop.proxy-target-class=true,有的版本不需要配置(当前的2.1.17.RELEASE不需要)</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>整合用到的核心注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean: 可以修饰方法和注解,功能和&lt;bean&gt;标签相同,将对象加入到IOC容器中</span><br><span class="line">@Configuration : 修饰类,被次注解修饰的类,会被Spring扫描到,被认定为是一个配置类</span><br></pre></td></tr></table></figure></li>
<li><p>集成Shiro配置代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author 枫桥夜泊1990</span><br><span class="line"> * @BLOG https://hd1611756908.github.io/</span><br><span class="line"> * @BSITE https://space.bilibili.com/514155929/</span><br><span class="line"> * @DATE 2020/8/12</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class ShiroConfig &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将Realm注入到IOC中</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public UserRealm createUserRealm(HashedCredentialsMatcher hashedCredentialsMatcher)&#123;</span><br><span class="line">        //创建Realm实例</span><br><span class="line">        UserRealm userRealm = new UserRealm();</span><br><span class="line">        //设置加密规则,HashedCredentialsMatcher对象通过给方法入参注入到此方法中</span><br><span class="line">        userRealm.setCredentialsMatcher(hashedCredentialsMatcher);</span><br><span class="line">        return userRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public HashedCredentialsMatcher createHashedCredentialsMatcher()&#123;</span><br><span class="line">        //创建加密对象</span><br><span class="line">        HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();</span><br><span class="line">        //加密方式</span><br><span class="line">        credentialsMatcher.setHashAlgorithmName(&quot;md5&quot;);</span><br><span class="line">        //迭代次数</span><br><span class="line">        credentialsMatcher.setHashIterations(1024);</span><br><span class="line">        return credentialsMatcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 安全管理器</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public SecurityManager createSecurityManager(UserRealm userRealm)&#123;</span><br><span class="line">        //创建web的安全管理器</span><br><span class="line">        DefaultWebSecurityManager  securityManager = new DefaultWebSecurityManager();</span><br><span class="line">        //配置realm</span><br><span class="line">        securityManager.setRealm(userRealm);</span><br><span class="line">        return securityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将ShiroFilter加入到IOC</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public ShiroFilterFactoryBean createShiroFilter(SecurityManager securityManager)&#123;</span><br><span class="line">        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();</span><br><span class="line">        shiroFilter.setSecurityManager(securityManager);</span><br><span class="line">        shiroFilter.setLoginUrl(&quot;/unauthentication&quot;);//未认证</span><br><span class="line">        shiroFilter.setUnauthorizedUrl(&quot;/unauthorized&quot;);//未授权控制器</span><br><span class="line">        Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(&quot;/login&quot;,&quot;anon&quot;);</span><br><span class="line">        map.put(&quot;/home1&quot;,&quot;authc,roles[admin]&quot;);</span><br><span class="line">        map.put(&quot;/home2&quot;,&quot;authc,roles[admin],perms[user:update]&quot;);</span><br><span class="line">        map.put(&quot;/**&quot;,&quot;authc&quot;);</span><br><span class="line">        //如果使用注解就不需要再这里配置拦截规则,可以注释掉</span><br><span class="line">        shiroFilter.setFilterChainDefinitionMap(map);</span><br><span class="line">        return shiroFilter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注解生效</span><br><span class="line">     * 如果使用Shiro注解,需要配置AuthorizationAttributeSourceAdvisor,否则注解不生效</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager)&#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();</span><br><span class="line">        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line">        return authorizationAttributeSourceAdvisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>控制器测试方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 登陆请求</span><br><span class="line">     */</span><br><span class="line">    @PostMapping(value = &quot;/login&quot;)</span><br><span class="line">    public String login(SysUsers sysUsers)&#123;</span><br><span class="line">        UsernamePasswordToken token = new UsernamePasswordToken(sysUsers.getUsername(),sysUsers.getPassword());</span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        try &#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">        &#125;catch (AuthenticationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(&quot;用户名错误&quot;);</span><br><span class="line">            //return &quot;账号或密码错误！&quot;;</span><br><span class="line">        &#125; catch (AuthorizationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new RuntimeException(&quot;密码错误&quot;);</span><br><span class="line">            //return &quot;没有权限&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 测试请求</span><br><span class="line">     */</span><br><span class="line">    @RequiresRoles(&#123;&quot;admin&quot;&#125;)</span><br><span class="line">    @GetMapping(value = &quot;/home1&quot;)</span><br><span class="line">    public String index()&#123;</span><br><span class="line">        System.out.println(&quot;我是home1,需要认证用户的角色为admin才能访问&quot;);</span><br><span class="line">        return &quot;我是home1...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 测试请求</span><br><span class="line">     */</span><br><span class="line">    @RequiresRoles(&#123;&quot;admin&quot;&#125;)</span><br><span class="line">    @RequiresPermissions(&#123;&quot;user:update&quot;&#125;)</span><br><span class="line">    @GetMapping(value = &quot;/home2&quot;)</span><br><span class="line">    public String index1()&#123;</span><br><span class="line">        System.out.println(&quot;我是home2,需要认证用户的角色是admin并且权限为user:update才可以访问&quot;);</span><br><span class="line">        return &quot;我是home2...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理未认证的请求</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/unauthentication&quot;)</span><br><span class="line">    public void unAuthorization()&#123;</span><br><span class="line">        System.out.println(&quot;当前请求未认证...&quot;);</span><br><span class="line">        throw new RuntimeException(&quot;当前请求未认证...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理未授权的请求</span><br><span class="line">     */</span><br><span class="line">    @GetMapping(&quot;/unauthorized&quot;)</span><br><span class="line">    public void unauthorized()&#123;</span><br><span class="line">        System.out.println(&quot;当前请求未授权...&quot;);</span><br><span class="line">        throw new RuntimeException(&quot;当前请求未授权...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>统一异常处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class ShiroExceptionHandler &#123;</span><br><span class="line">    </span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(value = &#123;AuthorizationException.class&#125;)</span><br><span class="line">    public Object processShiroAuthorizationException()&#123;</span><br><span class="line">        return &quot;授权失败...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(value = &#123;AuthenticationException.class&#125;)</span><br><span class="line">    public Object processShiroAuthenticationException()&#123;</span><br><span class="line">        return &quot;认证失败...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自定义的Realm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author 枫桥夜泊1990</span><br><span class="line"> * @BLOG https://hd1611756908.github.io/</span><br><span class="line"> * @BSITE https://space.bilibili.com/514155929/</span><br><span class="line"> * @DATE 2020/8/11</span><br><span class="line"> */</span><br><span class="line">public class UserRealm extends AuthorizingRealm &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SysUsersService sysUsersService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SysUsersRolesService sysUsersRolesService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SysRolesService sysRolesService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SysRolesPermissionsService sysRolesPermissionsService;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SysPermissionsService sysPermissionsService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取授权数据</span><br><span class="line">     * @param principalCollection</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123;</span><br><span class="line"></span><br><span class="line">        //获取用户名</span><br><span class="line">        String username = principalCollection.getPrimaryPrincipal().toString();</span><br><span class="line">        System.out.println(&quot;username:&quot;+username);</span><br><span class="line">        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();</span><br><span class="line">        //通过用户名查询当前用户的所有角色</span><br><span class="line">        SysUsers user = sysUsersService.getUserByUsername(username);</span><br><span class="line">        //根据用户ID查询角色信息</span><br><span class="line">        List&lt;SysUsersRoles&gt; usersRoles = sysUsersRolesService.getSysUsersRolesByUserId(user.getUserId());</span><br><span class="line">        //根据角色ID查询角色名称</span><br><span class="line">        Set&lt;String&gt; roleNames = new HashSet&lt;&gt;();</span><br><span class="line">        for (SysUsersRoles usersRole : usersRoles) &#123;</span><br><span class="line">            SysRoles roles = sysRolesService.getSysRolesByRoleId(usersRole.getRoleId());</span><br><span class="line">            roleNames.add(roles.getRoleName());</span><br><span class="line">            //通过角色ID查询权限列表</span><br><span class="line">            List&lt;SysRolesPermissions&gt; sysRolesPermissionss = sysRolesPermissionsService.getSysRolesPermissionsByRoleId(roles.getRoleId());</span><br><span class="line">            //根据权限ID查询权限名称</span><br><span class="line">            Set&lt;String &gt; permissionsNames = new HashSet&lt;&gt;();</span><br><span class="line">            for (SysRolesPermissions rolesPermissionss : sysRolesPermissionss) &#123;</span><br><span class="line">                SysPermissions permissions = sysPermissionsService.getSysPermissionsByPermissionsId(rolesPermissionss.getPermissionId());</span><br><span class="line">                if (null!=permissions)&#123;</span><br><span class="line">                    permissionsNames.add(permissions.getPermissionName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //将权限信息封装进info</span><br><span class="line">            info.addStringPermissions(permissionsNames);</span><br><span class="line">        &#125;</span><br><span class="line">        info.setRoles(roleNames);</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取认证数据</span><br><span class="line">     * @param authenticationToken</span><br><span class="line">     * @return</span><br><span class="line">     * @throws AuthenticationException</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">        //获取用户名</span><br><span class="line">        String username = authenticationToken.getPrincipal().toString();</span><br><span class="line">        System.out.println(&quot;realm: username:&quot;+username);</span><br><span class="line">        if(username==null || username.length()&lt;=0)&#123;</span><br><span class="line">            throw new UnknownAccountException(&quot;当前用户不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //通过用户名查询数据库</span><br><span class="line">        SysUsers user = sysUsersService.getUserByUsername(username);</span><br><span class="line"></span><br><span class="line">        if(user==null)&#123;</span><br><span class="line">            throw new UnknownAccountException(&quot;当前用户不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;=====&quot;+user);</span><br><span class="line">        //从数据库中获取数据，并且将查询出来的认证数据封装进alt</span><br><span class="line">        ByteSource salt = ByteSource.Util.bytes(user.getSalt());</span><br><span class="line">        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user.getUsername(),user.getPassword(),salt,getName());</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试(postman)</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2021/08/08/SpringMVC%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第一章-SpringMVC的简介"><a href="#第一章-SpringMVC的简介" class="headerlink" title="第一章 SpringMVC的简介"></a>第一章 SpringMVC的简介</h2><blockquote>
<p>Spring框架版本 4.3.29.RELEASE</p>
</blockquote>
<ul>
<li><p>SpringMVC是什么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Spring家族的一个部分</span><br><span class="line">2. 是JavaWeb三层架构中控制器层的解决方案</span><br><span class="line">3. 是基于MVC思想的框架</span><br><span class="line">    -- Model</span><br><span class="line">    -- View</span><br><span class="line">    -- Controller</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEBc1c23e98384bd0f94119ac24fd86733b?method=download&shareKey=4cf0b4b3873797b775c8d11259f42ac6"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBc1c23e98384bd0f94119ac24fd86733b?method=download&shareKey=4cf0b4b3873797b775c8d11259f42ac6" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li>SpringMVC知识点大纲</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB00f8938adbc3cfe250454e2142d9c50c?method=download&shareKey=2738306d15e9fd158e6b22e0232f9492"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB00f8938adbc3cfe250454e2142d9c50c?method=download&shareKey=2738306d15e9fd158e6b22e0232f9492" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><p>SpringMVC功能简述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 作为spring框架的一部分天生与spring框架集成</span><br><span class="line">2. 支持restful风格</span><br><span class="line">3. 灵活的请求URL/控制器/页面的映射</span><br><span class="line">4. 数据绑定在模型中，容易传递,前端可以很好的支持其他视图</span><br><span class="line">5. 简单的数据绑定,数据验证，可以绑定多种数据结构</span><br><span class="line">6. 强大的异常处理功能</span><br><span class="line">7. 静态资源的支持</span><br><span class="line">8. 文件上传/下载</span><br><span class="line">9. 国际化</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>SpringMVC常用组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 前端控制器: DispatcherServlet</span><br><span class="line">-- 视图解析器: ViewResolver</span><br><span class="line">-- 控制器/动作处理器: controller</span><br><span class="line">-- 国际化: LocalResolver</span><br><span class="line">-- 文件上传: MultipartResolver</span><br><span class="line">-- 异常处理器: HandlerExceptionResolver</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第二章-SpringMVC快速入门"><a href="#第二章-SpringMVC快速入门" class="headerlink" title="第二章 SpringMVC快速入门"></a>第二章 SpringMVC快速入门</h2><h3 id="第1节-编写步骤"><a href="#第1节-编写步骤" class="headerlink" title="第1节 编写步骤"></a>第1节 编写步骤</h3><ul>
<li><p>创建index.jsp/result.jsp页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.jsp</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/hello&quot;&gt;Hello SpringMVC&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">result.jsp</span><br><span class="line"></span><br><span class="line">result.jsp页面要放到springmvc配置文件指定的解析目录下</span><br></pre></td></tr></table></figure></li>
<li><p>创建SpringMVC的配置文件 spring-mvc.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置需要扫描的包 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;cn.ukoko&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置通用视图解析器 --&gt;</span><br><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">	&lt;!-- 配置前缀 --&gt;</span><br><span class="line">	&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;!-- 配置后缀 --&gt;</span><br><span class="line">	&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在web.xml配置文件中配置springmvc的核心servlet [DispatcherServlet]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">		&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">		&lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;</span><br><span class="line">	&lt;/init-param&gt;</span><br><span class="line">	&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">	&lt;!--SpringMVC官网强调请求地址拦截使用/,拦截除JSP之外的一切请求--&gt;</span><br><span class="line">	&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>编写处理核心业务逻辑代码的控制器[controller]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*加入到IOC容器中*/</span><br><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">	/*映射请求地址*/</span><br><span class="line">	@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">	public String helloWorld() &#123;</span><br><span class="line">		System.out.println(&quot;HelloWorld&quot;);</span><br><span class="line">		//返回到指定结果页面result.jsp</span><br><span class="line">		return &quot;result&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第2节-运行流程"><a href="#第2节-运行流程" class="headerlink" title="第2节 运行流程"></a>第2节 运行流程</h3><p><a href="https://note.youdao.com/yws/api/personal/file/WEB224df6e6ff66058aa3e3b0ffc7339184?method=download&shareKey=a3effdd9e10bd6977fadb480a825a653"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB224df6e6ff66058aa3e3b0ffc7339184?method=download&shareKey=a3effdd9e10bd6977fadb480a825a653" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简述运行流程</span><br><span class="line">1.客户端发起请求到DispatcherServlet</span><br><span class="line">2.由DispatcherServlet查找一个或多个HandlerMapping找到请求的handler(controller)</span><br><span class="line">3.DispatcherServlet将请求提交到handler(controller)</span><br><span class="line">4.Controller调用业务逻辑层处理后返回ModelAndView指定的视图</span><br><span class="line">5.视图将结果返回给客户端</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第3节-SpringMVC框架的另一种配置文件方式"><a href="#第3节-SpringMVC框架的另一种配置文件方式" class="headerlink" title="第3节 SpringMVC框架的另一种配置文件方式"></a>第3节 SpringMVC框架的另一种配置文件方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将配置文件放到WEB-INF目录下取名为 springDispatcherServlet-servlet.xml 不需要在web.xml中单独配置</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第4节-跨控制器页面跳转"><a href="#第4节-跨控制器页面跳转" class="headerlink" title="第4节 跨控制器页面跳转"></a>第4节 跨控制器页面跳转</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    跳过控制器,直接跳转视图</span><br><span class="line">    path: 设置请求地址</span><br><span class="line">    view-name: 跳转视图名称</span><br><span class="line">--&gt;</span><br><span class="line">&lt;mvc:view-controller path=&quot;/hello1&quot; view-name=&quot;hello1&quot;&gt;&lt;/mvc:view-controller&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--注意: 当使用view-controller 会让所有的注解失效,报404,所以需要添加注解驱动标签--&gt;</span><br><span class="line">&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第三章-SpringMVC数据绑定"><a href="#第三章-SpringMVC数据绑定" class="headerlink" title="第三章 SpringMVC数据绑定"></a>第三章 SpringMVC数据绑定</h2><h3 id="第1节-常用注解介绍"><a href="#第1节-常用注解介绍" class="headerlink" title="第1节 常用注解介绍"></a>第1节 常用注解介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Controller     : 将所标识的类加入到IOC容器中进行管理</span><br><span class="line">@RequestMapping : 配置前端请求的映射地址以及请求参数的设置</span><br><span class="line"> - method=RequestMethod.GET</span><br><span class="line"> - method=RequestMethod.POST</span><br><span class="line"> - params:限定请求参数</span><br><span class="line">    - params是一个数组</span><br><span class="line">    - params=&#123;&quot;name&quot;,&quot;no!=100&quot;,&quot;age=10&quot;&#125;  ： 表示请求参数包含name和no属性,并且no不能等于100,age一定等于10</span><br><span class="line">    - params=&#123;&quot;!name&quot;&#125; ： 表示请求参数不能有name参数</span><br><span class="line">@PathVariable   : 数据绑定</span><br><span class="line">@RequestParam   : 类似于servlet的request.getParameter(&quot;key&quot;);</span><br><span class="line"> - value        : 要从请求域中获取参数的key值</span><br><span class="line"> - required     : 参数是否必须</span><br><span class="line"> - defaultValue : 如果没有参数,那么走默认值</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第2节-GET请求数据绑定风格介绍"><a href="#第2节-GET请求数据绑定风格介绍" class="headerlink" title="第2节 GET请求数据绑定风格介绍"></a>第2节 GET请求数据绑定风格介绍</h3><h4 id="2-1-风格一"><a href="#2-1-风格一" class="headerlink" title="2.1 风格一"></a>2.1 风格一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用?拼接的方式  hello?name=lilei&amp;age=18</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 通过名称匹配</span><br><span class="line"> */</span><br><span class="line">@GetMapping(value = &quot;/hello&quot;)</span><br><span class="line">public String hello02(String name,int age)&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    return &quot;result&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-风格二"><a href="#2-2-风格二" class="headerlink" title="2.2 风格二"></a>2.2 风格二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello/lilei/18</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用占位符加PathVariable注解的方式</span><br><span class="line"> */</span><br><span class="line">@GetMapping(value = &quot;/hello/&#123;name&#125;/&#123;age&#125;&quot;)</span><br><span class="line">public String hello03(@PathVariable(&quot;name&quot;) String name,@PathVariable(&quot;age&quot;) int age)&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    return &quot;result&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第3节-其他数据类型对象绑定"><a href="#第3节-其他数据类型对象绑定" class="headerlink" title="第3节 其他数据类型对象绑定"></a>第3节 其他数据类型对象绑定</h3><h4 id="3-1-原生的JavaWeb的数据绑定"><a href="#3-1-原生的JavaWeb的数据绑定" class="headerlink" title="3.1 原生的JavaWeb的数据绑定"></a>3.1 原生的JavaWeb的数据绑定</h4><ul>
<li><p>前端页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;testJavaWeb&quot;&gt;原生的JavaWeb数据绑定测试&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>后台控制器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/testJavaWeb&quot;,method = RequestMethod.GET)</span><br><span class="line">public String testJavaWeb(HttpServletRequest request)&#123;</span><br><span class="line">    String name = request.getParameter(&quot;name&quot;);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    return &quot;result&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-基本数据类型-字符类型"><a href="#3-2-基本数据类型-字符类型" class="headerlink" title="3.2 基本数据类型/字符类型"></a>3.2 基本数据类型/字符类型</h4><ul>
<li><p>前端页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;testBase?name=Tom&amp;age=18&quot;&gt;基本数据类型/字符类型数据绑定测试&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>后台控制器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/testBase&quot;,method = RequestMethod.GET)</span><br><span class="line">public String testBase(String name,int age)&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">    return &quot;result&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-3-数组"><a href="#3-3-数组" class="headerlink" title="3.3 数组"></a>3.3 数组</h4><ul>
<li><p>前端页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;testArray?roleId=1001&amp;roleId=1002&quot;&gt;数组类型数据绑定测试&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>后台控制器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/testArray&quot;,method = RequestMethod.GET)</span><br><span class="line">public String testArray(int[] roleId)&#123;</span><br><span class="line">    System.out.println(roleId);</span><br><span class="line">    return &quot;result&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-4-自定义类型-嵌套类型"><a href="#3-4-自定义类型-嵌套类型" class="headerlink" title="3.4 自定义类型/嵌套类型"></a>3.4 自定义类型/嵌套类型</h4><ul>
<li><p>前端页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;testPOJO&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;bookName&quot;/&gt;</span><br><span class="line">    &lt;%--嵌套提交--%&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;author.authorName&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>模型对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private String bookName;</span><br><span class="line">    /*嵌套对象*/</span><br><span class="line">    private Author author;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Author &#123;</span><br><span class="line">    private String authorName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@DateTimeFormat(请求时间格式处理)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果前端input空间的type类型为date类型,控制器接收参数的类型为Date类型时需要使用注解</span><br><span class="line">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)进行转换</span><br></pre></td></tr></table></figure></li>
<li><p>后台控制器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/testPOJO&quot;,method = RequestMethod.POST)</span><br><span class="line">public String testPOJO(Book book)&#123;</span><br><span class="line">    System.out.println(book);</span><br><span class="line">    return &quot;result&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-5-SpringMVC中文乱码解决-web-xml"><a href="#3-5-SpringMVC中文乱码解决-web-xml" class="headerlink" title="3.5 SpringMVC中文乱码解决(web.xml)"></a>3.5 SpringMVC中文乱码解决(web.xml)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;UTF-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;true&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第4节-SpringMVC的数据类型转换器"><a href="#第4节-SpringMVC的数据类型转换器" class="headerlink" title="第4节 SpringMVC的数据类型转换器"></a>第4节 SpringMVC的数据类型转换器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过传统的JavaWeb数据获取方式获取到的请求数据类型都是String类型,也就是说从前端传过来的数据默认都会变成String类型那么我们的SpringMVC是怎么将String类型转自动转换成其他数据类型的呢?</span><br></pre></td></tr></table></figure>

<h4 id="4-1-SpringMVC内部提供的常见类型转换器"><a href="#4-1-SpringMVC内部提供的常见类型转换器" class="headerlink" title="4.1 SpringMVC内部提供的常见类型转换器"></a>4.1 SpringMVC内部提供的常见类型转换器</h4><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">StringToBooleanConverter</td>
<td align="left">String 到 boolean 类型转换</td>
</tr>
<tr>
<td align="left">StringToCharacterConverter</td>
<td align="left">String 到 Character 类型转换</td>
</tr>
<tr>
<td align="left">StringToEnumConverterFactory</td>
<td align="left">String 到 Enum 类型转换</td>
</tr>
<tr>
<td align="left">StringToNumberConverterFactory</td>
<td align="left">String 到 Number 类型转换</td>
</tr>
<tr>
<td align="left">StringToNumberConverterFactory</td>
<td align="left">Locale 到 String 类型转换</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
</tr>
</tbody></table>
<hr>
<blockquote>
<p>详细见Spring官网地址:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://docs.spring.io/spring-framework/docs/4.3.29.RELEASE/spring-framework-reference/htmlsingle/#core-convert</span><br><span class="line"></span><br><span class="line">第9.5节 Spring Type Conversion(Spring的类型转换)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring类型转换器介绍</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、类型转换是Spring3版本引入,默认是一种SPI(Service Provider Interface[服务发现机制])的机制帮助Spring进行类型转换.</span><br><span class="line">2、提供了常见的API在运行时执行类型转换(例如上面表格中的自带的类型转换以及自定义类型转换).</span><br><span class="line">3、在Spring容器中这个系统(类型转换)可以作为PropertyEditor的替换</span><br><span class="line">4、将String类型转换成其他类型</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-自定义类型转换器"><a href="#4-2-自定义类型转换器" class="headerlink" title="4.2 自定义类型转换器"></a>4.2 自定义类型转换器</h4><blockquote>
<p>常见的自定义类型转换器 API 介绍</p>
</blockquote>
<ul>
<li><p>Converter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line">public interface Converter&lt;S, T&gt; &#123;</span><br><span class="line">    T convert(S source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">简答类型转换接口,将S类型转换成T类型,进行简单类型的转换比如将String转成Integer</span><br></pre></td></tr></table></figure></li>
<li><p>ConverterFactory</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package org.springframework.core.convert.converter;</span><br><span class="line"></span><br><span class="line">public interface ConverterFactory&lt;S, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">层级类型转换接口, S类型是要被转换的参数类型,R类型是目标转换类型的基类型,T类型是R类型的子类,比如String转枚举类型.</span><br></pre></td></tr></table></figure></li>
<li><p>GenericConverter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复杂类型转换接口,当出现复杂类型的转换时,GenericConverter接口更灵活,支持多个源类型到目标类型的转换,并且在转换过程中提供了可以进行注解和泛型的驱动,比如数组Array到集合Collection的转换.</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>官方提示: 因为GenericConverter是一个复杂的SPI,当必须使用的时候在使用,否则最好是使用Converter or ConverterFactory 进行转换</p>
</blockquote>
<ul>
<li><p>ConversionService</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConversionService是一个在运行时执行转换逻辑的统一API接口</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>使用Converter接口实现自定义类型转换器(时间类型转换)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author 枫桥夜泊1990</span><br><span class="line"> * @BLOG https://hd1611756908.github.io/</span><br><span class="line"> * @BSITE https://space.bilibili.com/514155929/</span><br><span class="line"> * @DATE 2020/10/17</span><br><span class="line"> */</span><br><span class="line">public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Date convert(String source) &#123;</span><br><span class="line">        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd&quot;);</span><br><span class="line">        Date date =null;</span><br><span class="line">        try &#123;</span><br><span class="line">            date = sdf.parse(source);</span><br><span class="line">        &#125; catch (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将自定义Converter转换器加入到IOC容器中</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--设置类型转换器的服务--&gt;</span><br><span class="line">&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt;</span><br><span class="line">&lt;!--设置类型转换器--&gt;</span><br><span class="line">&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;converters&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;bean class=&quot;cn.ukoko.controller.StringToDateConverter&quot;&gt;&lt;/bean&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试类型转换器</p>
</blockquote>
<ul>
<li><p>前端页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;testConverter&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;createTime&quot;&gt;时间:&lt;/label&gt;</span><br><span class="line">    &lt;input id=&quot;createTime&quot; type=&quot;text&quot; name=&quot;createTime&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>控制器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/testConverter&quot;,method = RequestMethod.POST)</span><br><span class="line">public String testConverter(Date createTime)&#123;</span><br><span class="line">    System.out.println(&quot;createTime=&quot;+createTime);</span><br><span class="line">    return &quot;result&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第四章-SpringMVC的RESTFUL风格"><a href="#第四章-SpringMVC的RESTFUL风格" class="headerlink" title="第四章 SpringMVC的RESTFUL风格"></a>第四章 SpringMVC的RESTFUL风格</h2><h3 id="第1节-restful风格概念"><a href="#第1节-restful风格概念" class="headerlink" title="第1节 restful风格概念"></a>第1节 restful风格概念</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Representational State Transfer :（资源）表现层状态转换</span><br><span class="line">是目前最流行的一种互联网软件设计架构思想</span><br><span class="line"></span><br><span class="line">资源(Resources)：网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的 URI。要获取这个资源，访问它的URI就可以，因此 URI 即为每一个资源的独一无二的标识符。</span><br><span class="line"></span><br><span class="line">表现层(Representation) 把资源具体呈现出来的形式，叫做它的表现层(Representation)。比如，文本可以用 txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式。</span><br><span class="line"></span><br><span class="line">状态转化(State Transfer): 每发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生“状态转化”(State Transfer)。而这种转化是建立在表现层之上的，所以就是“表现层状态转化”。具体说，就是HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第2节-restful风格格式"><a href="#第2节-restful风格格式" class="headerlink" title="第2节 restful风格格式"></a>第2节 restful风格格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/book/1  HTTP  GET   ：得到 id = 1 的 book </span><br><span class="line">/book/1  HTTP DELETE：删除 id = 1的 book </span><br><span class="line">/book/1  HTTP PUT   ：更新id = 1的 book </span><br><span class="line">/book    HTTP POST  ：新增 book</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第3节-restful配置方式"><a href="#第3节-restful配置方式" class="headerlink" title="第3节 restful配置方式"></a>第3节 restful配置方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HiddenHttpMethodFilter：浏览器 form 表单只支持 GET 与 POST请求，而DELETE、PUT 等 method并不支持，Spring3.0添加了一个过滤器，可以将这些请求转换为标准的http方法，使得支持 GET、POST、PUT 与 DELETE 请求.</span><br><span class="line">web.xml中配置</span><br><span class="line"></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">	&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">	&lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">	&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第4节-restfult风格使用"><a href="#第4节-restfult风格使用" class="headerlink" title="第4节 restfult风格使用"></a>第4节 restfult风格使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;delete&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;!-- 用于状态转换 --&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;DELETE&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;删除&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;update&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;!-- 用于状态转换 --&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;更新&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>bug处理 405错误 JSPs only permit GET POST or HEAD</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在进行资源状态转换时</span><br><span class="line">POST --&gt; DELETE</span><br><span class="line">POST --&gt; PUT </span><br><span class="line"></span><br><span class="line">由于tomcat8的问题造成的405错误</span><br><span class="line"></span><br><span class="line">修复方式: </span><br><span class="line">方式一: 换tomcat为7或者9</span><br><span class="line">方式二: 在jsp页面中在设置 &lt;% isErrorPage=&quot;true&quot;%&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第五章-SpringMVC的模型数据"><a href="#第五章-SpringMVC的模型数据" class="headerlink" title="第五章 SpringMVC的模型数据"></a>第五章 SpringMVC的模型数据</h2><h3 id="第1节-JavaWeb原生方式模型数据传递"><a href="#第1节-JavaWeb原生方式模型数据传递" class="headerlink" title="第1节 JavaWeb原生方式模型数据传递"></a>第1节 JavaWeb原生方式模型数据传递</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RequestMapping(value = &quot;/testJavaWebModel&quot;)</span><br><span class="line">public String testJavaWebModel(HttpServletRequest request)&#123;</span><br><span class="line">    //将数据使用原生方式放在request域中</span><br><span class="line">    request.setAttribute(&quot;userName&quot;,&quot;李雷&quot;);</span><br><span class="line">    return &quot;result&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第2节-SpringMVC的模型数据传递"><a href="#第2节-SpringMVC的模型数据传递" class="headerlink" title="第2节 SpringMVC的模型数据传递"></a>第2节 SpringMVC的模型数据传递</h3><ul>
<li><p>使用ModelAndView对象传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/testModelAndView&quot;)</span><br><span class="line">public ModelAndView testModelAndView()&#123;</span><br><span class="line">    ModelAndView mv = new ModelAndView();</span><br><span class="line">    //指定视图名称</span><br><span class="line">    mv.setViewName(&quot;result&quot;);</span><br><span class="line">    /*将数据保存到域对象中*/</span><br><span class="line">    mv.addObject(&quot;userName&quot;,&quot;李雷&quot;);</span><br><span class="line">    return mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用Model对象传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/testModel&quot;)</span><br><span class="line">public String testModel(Model model)&#123;</span><br><span class="line">    /*向域对象中存数据*/</span><br><span class="line">    model.addAttribute(&quot;userName&quot;,&quot;李雷&quot;);</span><br><span class="line">    return &quot;result&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用ModelMap对象传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/testModelMap&quot;)</span><br><span class="line">public String testModelMap(ModelMap modelMap)&#123;</span><br><span class="line">    /*向域对象中存数据*/</span><br><span class="line">    modelMap.addAttribute(&quot;userName&quot;,&quot;李雷&quot;);</span><br><span class="line">    return &quot;result&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用Map对象传递</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/testMap&quot;)</span><br><span class="line">public String testMap(Map map)&#123;</span><br><span class="line">    /*向域对象中存数据*/</span><br><span class="line">    map.put(&quot;userName&quot;,&quot;李雷&quot;);</span><br><span class="line">    return &quot;result&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Model/ModelMap/Map关系</p>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB95d604098e01c7ecc90353c53904cdc8?method=download&shareKey=e7c840f9897d4ade00f46a987d7368bc"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB95d604098e01c7ecc90353c53904cdc8?method=download&shareKey=e7c840f9897d4ade00f46a987d7368bc" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<h2 id="第六章-SpringMVC的转发和重定向"><a href="#第六章-SpringMVC的转发和重定向" class="headerlink" title="第六章 SpringMVC的转发和重定向"></a>第六章 SpringMVC的转发和重定向</h2><ul>
<li><p>一句话解释转发和重定向的本质</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">转发是服务器行为，重定向是客户端行为</span><br></pre></td></tr></table></figure></li>
<li><p>SpringMVC 返回值处理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般情况下,控制器方法返回字符串类型的值会被当成逻辑视图名处理</span><br><span class="line">如果返回的字符串中带forward:或redirect:前缀时,SpringMVC会对他们进行特殊处理:将 forward: 和 redirect: 当成指示符,其后的字符串作为 URL 来处理</span><br><span class="line"></span><br><span class="line">redirect:ok：会完成一个到 ok的 @RequestMapping(&quot;/ok&quot;) 重定向的操作   redirect:/ok</span><br><span class="line">forward :ok：会完成一个到 ok的 @RequestMapping(&quot;/ok&quot;) 转发操作       forward:/ok</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第七章-SpringMVC文件上传-下载"><a href="#第七章-SpringMVC文件上传-下载" class="headerlink" title="第七章 SpringMVC文件上传/下载"></a>第七章 SpringMVC文件上传/下载</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. SpringMVC对文件上传提供了直接的支持</span><br><span class="line">2. 通过即插即用的MultipartResolver实现</span><br><span class="line">3. Spring用Jakarta Commons FileUpload技术实现一个MultipartResolver实现类 CommonsMultipartResovler</span><br><span class="line">4. SpringMVC默认不会开启上传功能,使用需要在上下文中配置MultipartResolver</span><br><span class="line">5. 编写表单设置enctype=&quot;multipart/form-data&quot;开启上传文件功能</span><br></pre></td></tr></table></figure>

<h3 id="第1节-文件上传"><a href="#第1节-文件上传" class="headerlink" title="第1节 文件上传"></a>第1节 文件上传</h3><ul>
<li><p>依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在SpringMVC配置文件中进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- id名字不能随便起 --&gt;</span><br><span class="line">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;maxUploadSize&quot; value=&quot;1048576&quot;/&gt;&lt;!--可以使用SpEL设置上传文件大小--&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>前端页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/uploadFile&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">	&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt;</span><br><span class="line">	&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>控制器实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value=&quot;/testUpload&quot;)</span><br><span class="line">public String testUpload(@RequestParam(&quot;file&quot;) MultipartFile[] multipartFiles) throws IllegalStateException, IOException &#123;</span><br><span class="line">	for (MultipartFile multipartFile : multipartFiles) &#123;</span><br><span class="line">		if(!multipartFile.isEmpty()) &#123;</span><br><span class="line">			multipartFile.transferTo(new File(&quot;文件保存的路径&quot;+multipartFile.getOriginalFilename()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return &quot;result&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第2节-文件下载"><a href="#第2节-文件下载" class="headerlink" title="第2节 文件下载"></a>第2节 文件下载</h3><ul>
<li><p>前端页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;$&#123;pageContext.request.contextPath &#125;/downloadFile&quot;&gt;downloadFile&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>后端控制器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value=&quot;/downloadFile&quot;,method=RequestMethod.GET)</span><br><span class="line">public ResponseEntity&lt;byte[]&gt; downloadFile() throws IOException&#123;</span><br><span class="line">	BufferedInputStream in = new BufferedInputStream(new FileInputStream(new File(&quot;C:\\Users\\Administrator\\Desktop\\abc.txt&quot;)));</span><br><span class="line">	byte[] body = new byte[in.available()];</span><br><span class="line">	in.read(body); //将输入流读到缓冲区</span><br><span class="line">	//文件名</span><br><span class="line">	String fileName=&quot;中国.txt&quot;;</span><br><span class="line">	//当文件名为中文时需要进行编码,否则会出现中文乱码</span><br><span class="line">	fileName=URLEncoder.encode(fileName, &quot;UTF-8&quot;);</span><br><span class="line">	HttpHeaders header = new HttpHeaders();</span><br><span class="line">	//inline: 直接显示</span><br><span class="line">	//header.add(&quot;Content-Disposition&quot;, &quot;inline;filename=&quot;+fileName);</span><br><span class="line">	//附件下载</span><br><span class="line">	header.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=f.txt&quot;);</span><br><span class="line">	ResponseEntity&lt;byte[]&gt; result = new ResponseEntity&lt;byte[]&gt;(body,header,HttpStatus.OK);</span><br><span class="line">	in.close();</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第八章-SpringMVC异常处理"><a href="#第八章-SpringMVC异常处理" class="headerlink" title="第八章 SpringMVC异常处理"></a>第八章 SpringMVC异常处理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. SpringMVC通过HandlerExceptionResolver进行异常处理</span><br><span class="line">2. DispaterServlet默认装配HandlerExceptionResolver异常处理器</span><br></pre></td></tr></table></figure>

<h3 id="第1节-单个异常处理"><a href="#第1节-单个异常处理" class="headerlink" title="第1节 单个异常处理"></a>第1节 单个异常处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设置指定捕获当前类中的哪些异常,当前设置为Exception异常以及其子类都会被捕获到</span><br><span class="line">@ExceptionHandler(value= &#123;Exception.class&#125;)</span><br><span class="line">public ModelAndView testException(Exception e)&#123;</span><br><span class="line">	System.out.println(&quot;error---&gt;&quot;+e.getMessage());</span><br><span class="line">	ModelAndView mv = new ModelAndView();</span><br><span class="line">	mv.addObject(&quot;myException&quot;, e);</span><br><span class="line">	mv.setViewName(&quot;error&quot;);</span><br><span class="line">	return mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第2节-统一异常处理"><a href="#第2节-统一异常处理" class="headerlink" title="第2节 统一异常处理"></a>第2节 统一异常处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建一个统一异常处理类</span><br><span class="line">2. 在类上添加@ControllerAdvice注解</span><br><span class="line">3. 定义异常方法，并添加@ExceptionHandler注解</span><br><span class="line">4. 方法的返回值为ModelAndView，将异常消息返回给异常页面展示</span><br><span class="line">5. 最后别忘记在SpringMVC的核心配置文件中配置注解驱动的标签&lt;mvc:annotation-driven/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>统一异常处理类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author 枫桥夜泊1990</span><br><span class="line"> * @BLOG https://hd1611756908.github.io/</span><br><span class="line"> * @BSITE https://space.bilibili.com/514155929/</span><br><span class="line"> * @DATE 2020/10/17</span><br><span class="line"> */</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class CommonException &#123;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(value = &#123;Exception.class&#125;)</span><br><span class="line">    public ModelAndView testException(Exception e)&#123;</span><br><span class="line">        ModelAndView mv = new ModelAndView();</span><br><span class="line">        mv.addObject(&quot;msg&quot;,e.getMessage());</span><br><span class="line">        mv.setViewName(&quot;error&quot;);</span><br><span class="line">        return mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>异常的优先级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先查找当前类里面的异常处理,如果不存在在去统一异常处理类中匹配</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第九章-SpringMVC静态资源处理"><a href="#第九章-SpringMVC静态资源处理" class="headerlink" title="第九章 SpringMVC静态资源处理"></a>第九章 SpringMVC静态资源处理</h2><h3 id="第1节-静态资源处理"><a href="#第1节-静态资源处理" class="headerlink" title="第1节 静态资源处理"></a>第1节 静态资源处理</h3><ul>
<li><p>哪些资源属于静态资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 项目中用到的jquery函数库</span><br><span class="line">2. 项目中自定义的js文件</span><br><span class="line">3. 项目中用到的自定义css文件</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>怎么解决静态资源导入问题(静态资源处于webapp下而不是WEB-INF下)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在SpringMVC的核心配置文件中添加如下标签</span><br><span class="line"></span><br><span class="line">&lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第2节-SpringMVC的拦截器"><a href="#第2节-SpringMVC的拦截器" class="headerlink" title="第2节 SpringMVC的拦截器"></a>第2节 SpringMVC的拦截器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SpringMVC提供了拦截器对请求进行拦截处理，我们可以通过自定义拦截器来实现特定功能</span><br><span class="line"></span><br><span class="line">实现一个自定义拦截器步骤:</span><br><span class="line">1. 实现HandlerInterceptor接口,重写里面的方法</span><br><span class="line">    1.1 perHandle</span><br><span class="line">        - 业务处理请求之前被调用</span><br><span class="line">        - 程序调用此拦截器之后还需要继续执行，那么返回true否则返回false</span><br><span class="line">    1.2 postHandle</span><br><span class="line">        - 业务处理器处理完请求之后,但是在DispatcherServlet向客户端返回响应前被调用，对用户请求进行处理</span><br><span class="line">    1.3 afterCompletion</span><br><span class="line">        - DispatcherServlet向客户端返回响应后被调用，可以进行一些资源清理的工作</span><br><span class="line"></span><br><span class="line">2. 在SpringMVC核心配置文件中注册自定义拦截器</span><br><span class="line">    2.1 全局拦截器注册</span><br><span class="line">        &lt;mvc:interceptors&gt;</span><br><span class="line">        	&lt;bean id=&quot;empInterctptor&quot; class=&quot;cn.ukoko.EmpInterctptor&quot;&gt;&lt;/bean&gt;</span><br><span class="line">        &lt;/mvc:interceptors&gt;</span><br><span class="line">    2.2 拦截指定的某一个请求</span><br><span class="line">        &lt;mvc:interceptors&gt;</span><br><span class="line">        	&lt;mvc:interceptor&gt;</span><br><span class="line">        		&lt;!-- 拦截emps地址的请求 --&gt;</span><br><span class="line">        		&lt;mvc:mapping path=&quot;/emps&quot;/&gt;</span><br><span class="line">        		&lt;bean class=&quot;cn.ukoko.EmpInterctptor&quot;&gt;&lt;/bean&gt;</span><br><span class="line">        	&lt;/mvc:interceptor&gt;</span><br><span class="line">        &lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第十章-SpringMVC的JSON数据交互"><a href="#第十章-SpringMVC的JSON数据交互" class="headerlink" title="第十章 SpringMVC的JSON数据交互"></a>第十章 SpringMVC的JSON数据交互</h2><h3 id="第1节-添加依赖"><a href="#第1节-添加依赖" class="headerlink" title="第1节 添加依赖"></a>第1节 添加依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.9.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.9.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.9.8&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第2节-ResponseBody-RequestBody"><a href="#第2节-ResponseBody-RequestBody" class="headerlink" title="第2节 @ResponseBody/@RequestBody"></a>第2节 @ResponseBody/@RequestBody</h3><ul>
<li><p>@ResponseBody</p>
</li>
<li><ul>
<li><p>@ResponseBody注解返回时间格式为long类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>@ResponseBody注解返回时间默认时区修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@JsonFormat(timezone = &quot;GMT+8&quot;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>@RequestBody</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么时候控制器中的方法入参使用@RequestBody注解?</span><br><span class="line"></span><br><span class="line">@requestBody注解常用来处理content-type不是默认的application/x-www-form-urlcoded,比如说：application/json或者是application/xml等。一般情况下来说常用其来处理application/json类型</span><br></pre></td></tr></table></figure></li>
<li><ul>
<li><p>前端页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取按钮对象</span><br><span class="line">$(&quot;#btn1&quot;).click(function()&#123;</span><br><span class="line">	</span><br><span class="line">	var book=&#123;&quot;bookId&quot;:1001,&quot;bookName&quot;:&quot;时间简史&quot;,&quot;authorName&quot;:&quot;霍金&quot;,&quot;price&quot;:12.12&#125;;</span><br><span class="line">	</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">		url:&quot;savebook&quot;,</span><br><span class="line">		type:&quot;post&quot;,</span><br><span class="line">		data:JSON.stringify(book),</span><br><span class="line">		contentType:&quot;application/json;charset=utf-8&quot;,</span><br><span class="line">		success:function(msg)&#123;</span><br><span class="line">			alert(msg);</span><br><span class="line">		&#125;,</span><br><span class="line">		dataType:&quot;json&quot;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>控制器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping(value=&quot;/savebook&quot;,method=RequestMethod.POST)</span><br><span class="line">public String savebook(@RequestBody Book book) &#123;</span><br><span class="line">	System.out.println(&quot;book:==: &quot;+book);</span><br><span class="line">	return &quot;200&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="第十一章-SpringMVC解决跨域调用"><a href="#第十一章-SpringMVC解决跨域调用" class="headerlink" title="第十一章 SpringMVC解决跨域调用"></a>第十一章 SpringMVC解决跨域调用</h2><h3 id="第1节-什么是跨域"><a href="#第1节-什么是跨域" class="headerlink" title="第1节 什么是跨域"></a>第1节 什么是跨域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">当前页面url</th>
<th align="left">被请求页面url</th>
<th align="left">是否跨域</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="http://www.test.com/">http://www.test.com/</a></td>
<td align="left"><a href="http://www.test.com/index.html">http://www.test.com/index.html</a></td>
<td align="left">否</td>
<td align="left">同源(协议、域名、端口号相同)</td>
</tr>
<tr>
<td align="left"><a href="http://www.test.com/">http://www.test.com/</a></td>
<td align="left"><a href="https://www.test.com/index.html">https://www.test.com/index.html</a></td>
<td align="left">跨域</td>
<td align="left">协议不同(http/https)</td>
</tr>
<tr>
<td align="left"><a href="http://www.test.com/">http://www.test.com/</a></td>
<td align="left"><a href="http://www.baidu.com/">http://www.baidu.com/</a></td>
<td align="left">跨域</td>
<td align="left">主域名不同(test/baidu)</td>
</tr>
<tr>
<td align="left"><a href="http://www.test.com/">http://www.test.com/</a></td>
<td align="left"><a href="http://blog.test.com/">http://blog.test.com/</a></td>
<td align="left">跨域</td>
<td align="left">子域名不同(www/blog)</td>
</tr>
<tr>
<td align="left"><a href="http://www.test.com:8080/">http://www.test.com:8080/</a></td>
<td align="left"><a href="http://www.test.com:7001/">http://www.test.com:7001/</a></td>
<td align="left">跨域</td>
<td align="left">端口号不同(8080/7001)</td>
</tr>
</tbody></table>
<hr>
<h3 id="第2节-Spring解决跨域的方式"><a href="#第2节-Spring解决跨域的方式" class="headerlink" title="第2节 Spring解决跨域的方式"></a>第2节 Spring解决跨域的方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SpringMVC的4.2版本提供了@CrossOrigin注解可以解决跨域问题</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第十二章-SpringMVC-Mock测试"><a href="#第十二章-SpringMVC-Mock测试" class="headerlink" title="第十二章 SpringMVC Mock测试"></a>第十二章 SpringMVC Mock测试</h2><h3 id="第1节-Mock介绍"><a href="#第1节-Mock介绍" class="headerlink" title="第1节 Mock介绍"></a>第1节 Mock介绍</h3><ul>
<li><p>什么是Mock测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mock测试就是在测试过程中,对于某些不容易构造或者不容易获取的对象,用一个虚拟的对象来创建以便测试的测试方法</span><br></pre></td></tr></table></figure></li>
<li><p>为什么要使用Mock测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用Mock进行测试,主要是用来模拟那些在应用中不容易构造(如HttpServletRequest必须在Servlet容器中才能构造出来)或者比较复杂的对象,从而使测试顺利进行的工具</span><br></pre></td></tr></table></figure></li>
<li><p>Mock测试用到的常用注解</p>
</li>
</ul>
<blockquote>
<p>WebAppConfiguratio</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用这个annotation会在跑单元测试的时候真实的启一个web服务,然后开始调用Controller的RestAPI,待单元测试跑完之后再将web服务停掉</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ContextConfiguration</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定Bean的配置文件信息,可以有多种方式,这个例子使用的是文件路径形式,如果有多个配置文件,可以将括号中的信息配置为一个字符串数组来表示</span><br></pre></td></tr></table></figure>

<blockquote>
<p>RunWith</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定运行的测试容器</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第2节-Mock测试环境的安装"><a href="#第2节-Mock测试环境的安装" class="headerlink" title="第2节 Mock测试环境的安装"></a>第2节 Mock测试环境的安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring MVC测试框架提供了两种方式,独立安装和集成Web环境测试(此种方式并不会集成真正的web环境,而是通过相应的Mock API进行模拟测试,无须启动服务器)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>添加依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;7.0&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">注意: 当前版本的spring框架需要3.0以上版本的servlet-api支持单元测试</span><br></pre></td></tr></table></figure></li>
<li><p>创建MockMvc对象</p>
</li>
</ul>
<blockquote>
<p>安装测试环境 方式一(独立安装方式)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 独立安装测试</span><br><span class="line"> * 依赖servlet-api</span><br><span class="line"> */</span><br><span class="line">public class BookControllerTest &#123;</span><br><span class="line">	</span><br><span class="line">	private MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">	@Before</span><br><span class="line">	public void setUp() &#123;</span><br><span class="line">	    //通过参数指定一组控制器，这样就不需要从上下文获取了</span><br><span class="line">		this.mockMvc = MockMvcBuilders.standaloneSetup(new BookController()).build();</span><br><span class="line">	&#125;</span><br><span class="line">	@Test</span><br><span class="line">	public void testMockMvc() throws Exception &#123;</span><br><span class="line">		System.out.println(mockMvc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装测试环境 方式二(集成Web环境方式)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 集成Web环境方式</span><br><span class="line"> */</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@ContextConfiguration(locations= &#123;&quot;classpath:spring-mvc.xml&quot;&#125;)</span><br><span class="line">//如果springmvc的配置文件在WEB-INF下使用下面这种写法</span><br><span class="line">@ContextConfiguration(locations = &#123;&quot;file:src/main/webapp/WEB-INF/springDispatcherServlet-servlet.xml&quot;&#125;)</span><br><span class="line">@WebAppConfiguration</span><br><span class="line">public class BookControllerTest2 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private WebApplicationContext wac;</span><br><span class="line"></span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setup() &#123;</span><br><span class="line">        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">	public void testMockMvc() throws Exception &#123;</span><br><span class="line">		System.out.println(mockMvc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第3节-Mock的使用"><a href="#第3节-Mock的使用" class="headerlink" title="第3节 Mock的使用"></a>第3节 Mock的使用</h3><h4 id="3-1-方法的测试-返回值是JSON或者是字符串-方法无入参"><a href="#3-1-方法的测试-返回值是JSON或者是字符串-方法无入参" class="headerlink" title="3.1 方法的测试(返回值是JSON或者是字符串,方法无入参)"></a>3.1 方法的测试(返回值是JSON或者是字符串,方法无入参)</h4><ul>
<li><p>模型数据实体类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private Integer userId;</span><br><span class="line">    private String userName;</span><br><span class="line">    private Date hireDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试的控制器方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping(value = &quot;/getUserJson&quot;,method = RequestMethod.GET)</span><br><span class="line">public User getUserJson()&#123;</span><br><span class="line">    User user = new User(1001, &quot;夜泊&quot;, new Date());</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单元测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getUserJson() throws Exception &#123;</span><br><span class="line">    ResultActions resultActions = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/getUserJson&quot;));</span><br><span class="line">    MvcResult mvcResult = resultActions.andReturn();</span><br><span class="line">    MockHttpServletResponse response = mvcResult.getResponse();</span><br><span class="line">    int status = response.getStatus();//响应状态码</span><br><span class="line">    String content = response.getContentAsString();//响应结果</span><br><span class="line">    System.out.println(&quot;响应状态码:&quot;+status);</span><br><span class="line">    System.out.println(&quot;响应内容:&quot;+content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-2-传统的-方式设置入参-GET请求"><a href="#3-2-传统的-方式设置入参-GET请求" class="headerlink" title="3.2 传统的(?)方式设置入参[GET请求]"></a>3.2 传统的(?)方式设置入参[GET请求]</h4><ul>
<li><p>测试的控制器方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping(value = &quot;/getUser&quot;,method = RequestMethod.GET)</span><br><span class="line">public User getUser(Integer userId,String userName)&#123;</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setUserId(userId);</span><br><span class="line">    user.setUserName(userName);</span><br><span class="line">    user.setHireDate(new Date());</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单元测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getUser() throws Exception &#123;</span><br><span class="line">    ResultActions resultActions = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/getUser?userId=&#123;xyz&#125;&amp;userName=&#123;userName&#125;&quot;, 100,&quot;韩梅梅&quot;));</span><br><span class="line">    MvcResult mvcResult = resultActions.andReturn();</span><br><span class="line">    MockHttpServletResponse response = mvcResult.getResponse();</span><br><span class="line">    int status = response.getStatus();//响应状态码</span><br><span class="line">    String content = response.getContentAsString();//响应结果</span><br><span class="line">    System.out.println(&quot;响应状态码:&quot;+status);</span><br><span class="line">    System.out.println(&quot;响应内容:&quot;+content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-3-使用占位符-占位形参-设置入参-GET请求"><a href="#3-3-使用占位符-占位形参-设置入参-GET请求" class="headerlink" title="3.3 使用占位符{占位形参}设置入参[GET请求]"></a>3.3 使用占位符{占位形参}设置入参[GET请求]</h4><ul>
<li><p>测试的控制器方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping(value = &quot;/getUser2/&#123;userId&#125;/&#123;userName&#125;&quot;,method = RequestMethod.GET)</span><br><span class="line">public User getUser2(@PathVariable(&quot;userId&quot;) Integer userId,@PathVariable(&quot;userName&quot;) String userName)&#123;</span><br><span class="line">    User user = new User();</span><br><span class="line">    user.setUserId(userId);</span><br><span class="line">    user.setUserName(userName);</span><br><span class="line">    user.setHireDate(new Date());</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单元测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getUser2() throws Exception &#123;</span><br><span class="line">    ResultActions resultActions = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/getUser2/1000/李雷&quot;));</span><br><span class="line">    MvcResult mvcResult = resultActions.andReturn();</span><br><span class="line">    MockHttpServletResponse response = mvcResult.getResponse();</span><br><span class="line">    int status = response.getStatus();//响应状态码</span><br><span class="line">    String content = response.getContentAsString();//响应结果</span><br><span class="line">    System.out.println(&quot;响应状态码:&quot;+status);</span><br><span class="line">    System.out.println(&quot;响应内容:&quot;+content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="3-4-JSON作为入参参数设置"><a href="#3-4-JSON作为入参参数设置" class="headerlink" title="3.4 JSON作为入参参数设置"></a>3.4 JSON作为入参参数设置</h4><ul>
<li><p>测试的控制器方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">@RequestMapping(value = &quot;/getUserForRequestJson&quot;,method = RequestMethod.POST)</span><br><span class="line">public String getUserForRequestJson(@RequestBody User user)&#123;</span><br><span class="line">    System.out.println(&quot;入参为: &quot;+user);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单元测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void getUserForRequestJson() throws Exception &#123;</span><br><span class="line">    String var=&quot;&#123;\&quot;userId\&quot;:1001,\&quot;userName\&quot;:\&quot;李雷\&quot;,\&quot;hireDate\&quot;:\&quot;2020-12-12 22:22:22\&quot;&#125;&quot;;</span><br><span class="line">    /**</span><br><span class="line">     * contentType： 设置传递参数的类型</span><br><span class="line">     * content: 设置传递的参数内容</span><br><span class="line">     */</span><br><span class="line">    ResultActions resultActions = mockMvc.perform(MockMvcRequestBuilders.post(&quot;/getUserForRequestJson&quot;).contentType(MediaType.APPLICATION_JSON_UTF8).content(var));</span><br><span class="line">    MvcResult mvcResult = resultActions.andReturn();</span><br><span class="line">    MockHttpServletResponse response = mvcResult.getResponse();</span><br><span class="line">    int status = response.getStatus();//响应状态码</span><br><span class="line">    String content = response.getContentAsString();//响应结果</span><br><span class="line">    System.out.println(&quot;响应状态码:&quot;+status);</span><br><span class="line">    System.out.println(&quot;响应内容:&quot;+content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-控制器方法返回值为视图的测试"><a href="#3-5-控制器方法返回值为视图的测试" class="headerlink" title="3.5 控制器方法返回值为视图的测试"></a>3.5 控制器方法返回值为视图的测试</h4></li>
<li><p>测试的控制器方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/testView&quot;,method = RequestMethod.GET)</span><br><span class="line">public String testView(Integer userId, Model model)&#123;</span><br><span class="line">    System.out.println(&quot;测试视图跳转... userId=&quot;+userId);</span><br><span class="line">    //向模型中存储数据</span><br><span class="line">    model.addAttribute(&quot;userId&quot;,userId);</span><br><span class="line">    //返回视图</span><br><span class="line">    return &quot;testview&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单元测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testView() throws Exception &#123;</span><br><span class="line">    ResultActions resultActions = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/testView?userId=&#123;userId&#125;&quot;, 10000));</span><br><span class="line">    //验证模型中是否存储此key的数据</span><br><span class="line">    resultActions.andExpect(MockMvcResultMatchers.model().attributeExists(&quot;userId&quot;));</span><br><span class="line">    //验证模型是否存在此视图</span><br><span class="line">    resultActions.andExpect(MockMvcResultMatchers.view().name(&quot;testview&quot;));</span><br><span class="line">    //验证请求状态</span><br><span class="line">    resultActions.andExpect(MockMvcResultMatchers.status().isOk());</span><br><span class="line">    // 给他打印出来</span><br><span class="line">    resultActions.andDo(MockMvcResultHandlers.print());</span><br><span class="line">    //返回结果</span><br><span class="line">    MvcResult result = resultActions.andReturn();</span><br><span class="line"></span><br><span class="line">    //上面的操作可以连接成串进行操作</span><br><span class="line">    //MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/testView?userId=&#123;userId&#125;&quot;, 10000)).andExpect(MockMvcResultMatchers.model().attributeExists(&quot;userId&quot;)).andExpect(MockMvcResultMatchers.view().name(&quot;testview&quot;)).andDo(MockMvcResultHandlers.print()).andReturn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">andExpect: 添加执行完成后的验证断言</span><br><span class="line">andDo    : 添加一个结果处理器</span><br><span class="line">andReturn: 执行完成后返回响应的结果</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第十三章-SpringMVC-运行流程"><a href="#第十三章-SpringMVC-运行流程" class="headerlink" title="第十三章 SpringMVC 运行流程"></a>第十三章 SpringMVC 运行流程</h2><p><a href="https://note.youdao.com/yws/api/personal/file/WEB9179844ab3ce487d98286744a55790b5?method=download&shareKey=421658470811067db460b3d092573581"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB9179844ab3ce487d98286744a55790b5?method=download&shareKey=421658470811067db460b3d092573581" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2021/08/08/Spring%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="第一章-Spring简介"><a href="#第一章-Spring简介" class="headerlink" title="第一章 Spring简介"></a>第一章 Spring简介</h2><h3 id="第1节-Spring的介绍"><a href="#第1节-Spring的介绍" class="headerlink" title="第1节 Spring的介绍"></a>第1节 Spring的介绍</h3><ul>
<li><p>Spring官网地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://spring.io</span><br></pre></td></tr></table></figure></li>
<li><p>Spring的介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。Spring是于2003年兴起的一个轻量级的Java 开发框架，由Rod Johnson创建。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第2节-Spring的架构"><a href="#第2节-Spring的架构" class="headerlink" title="第2节 Spring的架构"></a>第2节 Spring的架构</h3><p><a href="https://note.youdao.com/yws/api/personal/file/WEB725dfa3640aaa0f0b5779705b1e94e5e?method=download&shareKey=d6a6ef477b2d2e9168765d245d877a84"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB725dfa3640aaa0f0b5779705b1e94e5e?method=download&shareKey=d6a6ef477b2d2e9168765d245d877a84" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<h3 id="第3节-Spring的核心依赖介绍"><a href="#第3节-Spring的核心依赖介绍" class="headerlink" title="第3节 Spring的核心依赖介绍"></a>第3节 Spring的核心依赖介绍</h3><p><a href="https://note.youdao.com/yws/api/personal/file/WEB6fec53306f8fecf3994a0e0f6c33f7ac?method=download&shareKey=cabdb3bd559fbe042758dc1cf7242b9c"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB6fec53306f8fecf3994a0e0f6c33f7ac?method=download&shareKey=cabdb3bd559fbe042758dc1cf7242b9c" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring框架由约20个模块组成,这些模块分为核心容器,数据库操作,web,AOP,设置,消息处理,测试等。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Core Container</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">核心容器涉及到的模块</span><br><span class="line">    spring-core</span><br><span class="line">    spring-beans</span><br><span class="line">    spring-context</span><br><span class="line">    spring-context-support</span><br><span class="line">    spring-expression</span><br></pre></td></tr></table></figure></li>
<li><p>AOP and Instrumentation</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AOP(Aspect Oriented Programming)和设备</span><br><span class="line"></span><br><span class="line">AOP涉及到的模块:</span><br><span class="line">    spring-aop</span><br><span class="line">    spring-aspects</span><br><span class="line"></span><br><span class="line">设备涉及到的模块:</span><br><span class="line">    spring-instrument</span><br><span class="line">    spring-instrument-tomcat</span><br></pre></td></tr></table></figure></li>
<li><p>Messaging</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息涉及到的模块:</span><br><span class="line">    spring-messaging</span><br></pre></td></tr></table></figure></li>
<li><p>Data Access/Integration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库操作涉及到的模块:</span><br><span class="line">    spring-jdbc</span><br><span class="line">    spring-tx</span><br><span class="line">    spring-orm</span><br><span class="line">    spring-oxm</span><br><span class="line">    spring-jms</span><br></pre></td></tr></table></figure></li>
<li><p>Web</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web涉及到的模块:</span><br><span class="line">    spring-web</span><br><span class="line">    spring-webmvc</span><br><span class="line">    spring-websocket</span><br><span class="line">    spring-webmvc-portlet</span><br></pre></td></tr></table></figure></li>
<li><p>Test</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Test 涉及到的模块:</span><br><span class="line">    spring-test</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第二章-Spring的Core-Container-核心容器"><a href="#第二章-Spring的Core-Container-核心容器" class="headerlink" title="第二章 Spring的Core Container(核心容器)"></a>第二章 Spring的Core Container(核心容器)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.3.27.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">    &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第1节-核心容器-IOC-介绍"><a href="#第1节-核心容器-IOC-介绍" class="headerlink" title="第1节 核心容器(IOC)介绍"></a>第1节 核心容器(IOC)介绍</h3><ul>
<li><p>IOC的概念</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">控制反转(Inversion of Control，缩写为IoC),又称为依赖注入,是面向对象编程中的一种设计思想，可以用来降低计算机代码之间的耦合度</span><br></pre></td></tr></table></figure></li>
<li><p>依赖注入和控制反转的理解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">依赖注入: 在应用程序中的组件需要获取资源时,传统的方式是组件主动去创建需要的资源;反转控制的思想完全颠覆了应用程序组件获取资源的方式,反转了资源的获取方向,改由容器创建,并主动的将资源推送给需要的组件，开发人员不需要知道容器是如何创建资源对象的,只需要提供接收资源的方式即可.</span><br><span class="line"></span><br><span class="line">控制反转：IOC的另一种表述方式：即组件以一些预先定义好的方式(例如：setter方法)接受来自于容器的资源注入.</span><br></pre></td></tr></table></figure></li>
<li><p>IOC容器创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring提供了创建IOC容器的接口(ApplicationContext),要想创建一个IOC容器只需要实例化此接口的实现类即可.</span><br><span class="line"></span><br><span class="line">ApplicationContext接口的主要实现如下:</span><br><span class="line"> - ClassPathXmlApplicationContext：创建IOC容器的典型实现类之一,基于对应类路径下的XML格式的配置文件进行IOC容器的初始化</span><br><span class="line"> - ConfigurableApplicationContext:是ApplicationContext的子接口，里面包含了一些扩展方法,比如添加了启动,刷新,关闭IOC容器的能力</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建IOC实例的方式:</span><br><span class="line">ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class="line">bean.xml： 类路径下的xml配置文件，里面是一些需要IOC容器进行初始化的类的配置</span><br></pre></td></tr></table></figure>

<h3 id="第2节-使用IOC容器进行对象实例化"><a href="#第2节-使用IOC容器进行对象实例化" class="headerlink" title="第2节 使用IOC容器进行对象实例化"></a>第2节 使用IOC容器进行对象实例化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们有了IOC容器,IOC容器到底是干什么的,我们为什么要学习IOC容器,它能帮我们解决哪些问题?</span><br><span class="line"></span><br><span class="line">我们下面会进行IOC容器的使用,你会发现IOC容器其实就是帮助我们创建对象和管理对象的.具体是怎么创建,怎么管理的,下面我们一个个说。</span><br></pre></td></tr></table></figure>

<h4 id="2-1-bean标签方式"><a href="#2-1-bean标签方式" class="headerlink" title="2.1 bean标签方式"></a>2.1 bean标签方式</h4></li>
<li><p>bean的初始化(setter/getter)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user1&quot; class=&quot;com.sc.bean.User&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;id&quot; value=&quot;1001&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;lilei&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>bean的初始化(构造器方式)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user2&quot; class=&quot;com.sc.bean.User&quot;&gt;</span><br><span class="line">	&lt;constructor-arg value=&quot;3001&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">	&lt;constructor-arg value=&quot;Jim&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;user3&quot; class=&quot;com.sc.bean.User&quot;&gt;</span><br><span class="line">	&lt;constructor-arg index=&quot;0&quot; value=&quot;1001&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">	&lt;constructor-arg index=&quot;1&quot; value=&quot;hanmeimei&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;user4&quot; class=&quot;com.sc.bean.User&quot;&gt;</span><br><span class="line">	&lt;constructor-arg name=&quot;id&quot; value=&quot;2001&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">	&lt;constructor-arg name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>bean的初始化(p标签赋值)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user1&quot; class=&quot;com.sc.entity.User&quot; p:id=&quot;100&quot; p:name=&quot;lilei&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>bean的初始化(给属性赋null值)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不设置值或者是设置&lt;null&gt;标签</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;user2&quot; class=&quot;com.sc.entity.User&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;id&quot; value=&quot;1000&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot;&gt;</span><br><span class="line">    	&lt;null&gt;&lt;/null&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>bean的初始化(对象引用ref赋值)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user1&quot; class=&quot;com.sc.entity.User&quot; p:id=&quot;100&quot; p:name=&quot;lilei&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;order1&quot; class=&quot;com.sc.entity.Order&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;orderId&quot; value=&quot;12334434&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;orderName&quot; value=&quot;dingdan&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;user&quot; ref=&quot;user1&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>bean的初始化(内部bean赋值)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;order2&quot; class=&quot;com.sc.entity.Order&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;orderId&quot; value=&quot;12334434&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;orderName&quot; value=&quot;dingdan&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;user&quot;&gt;</span><br><span class="line">		&lt;bean class=&quot;com.sc.entity.User&quot;&gt;</span><br><span class="line">			&lt;property name=&quot;id&quot; value=&quot;2000&quot;&gt;&lt;/property&gt;</span><br><span class="line">			&lt;property name=&quot;name&quot; value=&quot;hanmeimei&quot;&gt;&lt;/property&gt;</span><br><span class="line">		&lt;/bean&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>bean的初始化(list赋值)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user3&quot; class=&quot;com.sc.entity.User&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;id&quot; value=&quot;66666&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;666666&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;orders&quot;&gt;</span><br><span class="line">		&lt;list&gt;</span><br><span class="line">			&lt;ref bean=&quot;order3&quot;/&gt;</span><br><span class="line">			&lt;ref bean=&quot;order4&quot;/&gt;</span><br><span class="line">			&lt;ref bean=&quot;order5&quot;/&gt;</span><br><span class="line">		&lt;/list&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>bean的初始化(set赋值)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user5&quot; class=&quot;com.sc.entity.User&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;id&quot; value=&quot;4000&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;400000&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;orderSet&quot;&gt;</span><br><span class="line">		&lt;set&gt;</span><br><span class="line">			&lt;ref bean=&quot;order3&quot;/&gt;</span><br><span class="line">			&lt;ref bean=&quot;order4&quot;/&gt;</span><br><span class="line">			&lt;ref bean=&quot;order5&quot;/&gt;</span><br><span class="line">		&lt;/set&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>bean的初始化(map赋值)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user4&quot; class=&quot;com.sc.entity.User&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;id&quot; value=&quot;4000&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;400000&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;map&quot;&gt;</span><br><span class="line">		&lt;map&gt;</span><br><span class="line">			&lt;entry key=&quot;key01&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt;</span><br><span class="line">			&lt;entry key=&quot;key02&quot; value=&quot;value2&quot;&gt;&lt;/entry&gt;</span><br><span class="line">			&lt;entry key=&quot;key03&quot; value=&quot;value3&quot;&gt;&lt;/entry&gt;</span><br><span class="line">		&lt;/map&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>util名称创建对象list(了解)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;util:list list-class=&quot;java.util.ArrayList&quot; id=&quot;utilList&quot;&gt;</span><br><span class="line">	&lt;ref bean=&quot;order3&quot;/&gt;</span><br><span class="line">	&lt;ref bean=&quot;order4&quot;/&gt;</span><br><span class="line">	&lt;ref bean=&quot;order5&quot;/&gt;</span><br><span class="line">	&lt;value&gt;23123&lt;/value&gt;</span><br><span class="line">&lt;/util:list&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>bean的初始化(Properties赋值)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user6&quot; class=&quot;com.sc.spring.User&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;id&quot; value=&quot;1000&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;lilei&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;properties&quot;&gt;</span><br><span class="line">		&lt;props&gt;</span><br><span class="line">			&lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;</span><br><span class="line">			&lt;prop key=&quot;password&quot;&gt;root&lt;/prop&gt;</span><br><span class="line">			&lt;prop key=&quot;url&quot;&gt;jdbc:mysql://localhost:3306/spring_repository&lt;/prop&gt;</span><br><span class="line">			&lt;prop key=&quot;driver&quot;&gt;com.mysql/jdbc.Driver&lt;/prop&gt;</span><br><span class="line">		&lt;/props&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>级联属性赋值</p>
</li>
<li><ul>
<li><p>Java类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserDao &#123;</span><br><span class="line"></span><br><span class="line">	private String daoMsg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">	private UserDao userDao;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>XML配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.sc.entity.UserDao&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.sc.entity.UserService&quot;&gt;</span><br><span class="line">	&lt;!-- 级联赋值首先是实例化赋值 --&gt;</span><br><span class="line">	&lt;property name=&quot;userDao&quot;  ref=&quot;userDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;!-- 然后在进行级联属性赋值 --&gt;</span><br><span class="line">	&lt;property name=&quot;userDao.daoMsg&quot; value=&quot;赋值成功&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-2-注解的方式"><a href="#2-2-注解的方式" class="headerlink" title="2.2 注解的方式"></a>2.2 注解的方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相对于XML方式而言，通过注解的方式配置bean更加简洁和优雅，而且和MVC组件化开发的理念十分契合，是开发中常用的使用方式.</span><br><span class="line">@Component</span><br><span class="line">public class User&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用注解标识要加入到IOC管理的类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①普通组件：@Component</span><br><span class="line">标识一个受Spring IOC容器管理的组件</span><br><span class="line">②持久化层组件：@Repository</span><br><span class="line">标识一个受Spring IOC容器管理的持久化层组件</span><br><span class="line">③业务逻辑层组件：@Service</span><br><span class="line">标识一个受Spring IOC容器管理的业务逻辑层组件</span><br><span class="line">④表述层控制器组件：@Controller</span><br><span class="line">标识一个受Spring IOC容器管理的表述层控制器组件</span><br><span class="line">⑤组件命名规则</span><br><span class="line">[1]默认情况：使用组件的简单类名首字母小写后得到的字符串作为bean的id</span><br><span class="line">[2]使用组件注解的value属性指定bean的id</span><br></pre></td></tr></table></figure></li>
<li><p>组件扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组件被上述注解标识后还需要通过Spring进行扫描才能够侦测到</span><br><span class="line"></span><br><span class="line">指定被扫描的package:</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.sc.entity&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>包含和排除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.sc.entity&quot;&gt;</span><br><span class="line">    &lt;!-- 包含哪个注解 可以设置多个 --&gt;</span><br><span class="line">	&lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;</span><br><span class="line">	&lt;!-- 排除哪个注解 可以设置多个 --&gt;</span><br><span class="line">	&lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第3节-静态工厂类-实例工厂类"><a href="#第3节-静态工厂类-实例工厂类" class="headerlink" title="第3节 静态工厂类/实例工厂类"></a>第3节 静态工厂类/实例工厂类</h3></li>
</ul>
<h4 id="3-1-静态工厂"><a href="#3-1-静态工厂" class="headerlink" title="3.1 静态工厂"></a>3.1 静态工厂</h4><ul>
<li><p>Java代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 静态工厂类</span><br><span class="line"> */</span><br><span class="line">public class StaticFactory &#123;</span><br><span class="line">	private static Map&lt;String, User&gt; map;</span><br><span class="line">	static &#123;</span><br><span class="line">		map = new HashMap&lt;&gt;();</span><br><span class="line">		map.put(&quot;key01&quot;, new User(100, &quot;user1&quot;));</span><br><span class="line">		map.put(&quot;key02&quot;, new User(102, &quot;user2&quot;));</span><br><span class="line">		map.put(&quot;key03&quot;, new User(103, &quot;user3&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">	public static User getUser(String key)&#123;</span><br><span class="line">		return map.get(key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>xml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- </span><br><span class="line">	class:静态工厂类的全类名</span><br><span class="line">	factory-method: 从静态工厂中获取的产品方法名</span><br><span class="line">	id: 从IOC容器中取出从静态方法中生产出来的产品对象</span><br><span class="line">	constructor-arg: 方法的入参</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.sc.entity.StaticFactory&quot; factory-method=&quot;getUser&quot;&gt;</span><br><span class="line">	&lt;constructor-arg value=&quot;key01&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-实例工厂"><a href="#3-2-实例工厂" class="headerlink" title="3.2 实例工厂"></a>3.2 实例工厂</h4></li>
<li><p>Java代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  实例工厂类</span><br><span class="line"> */</span><br><span class="line">public class InstanceFactory &#123;</span><br><span class="line"></span><br><span class="line">	private Map&lt;String, User&gt; map;</span><br><span class="line">	&#123;</span><br><span class="line">		map = new HashMap&lt;&gt;();</span><br><span class="line">		map.put(&quot;key01&quot;, new User(100, &quot;user1&quot;));</span><br><span class="line">		map.put(&quot;key02&quot;, new User(102, &quot;user2&quot;));</span><br><span class="line">		map.put(&quot;key03&quot;, new User(103, &quot;user3&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">	public User getUser(String key)&#123;</span><br><span class="line">		return map.get(key);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>xml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 首先创建实例工厂 --&gt;</span><br><span class="line">&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.sc.entity.InstanceFactory&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;user2&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getUser&quot;&gt;</span><br><span class="line">	&lt;constructor-arg value=&quot;key02&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第4节-factoryBean接口"><a href="#第4节-factoryBean接口" class="headerlink" title="第4节 factoryBean接口"></a>第4节 factoryBean接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring中有两种类型的bean，一种是普通bean，另一种是工厂bean，即FactoryBean。工厂bean跟普通bean不同，其返回的对象不是指定类的一个实例，其返回的是该工厂bean的getObject方法所返回的对象</span><br></pre></td></tr></table></figure></li>
<li><p>Java代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FactoryUser implements FactoryBean&lt;User&gt;&#123;</span><br><span class="line">	private String name;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public User getObject() throws Exception &#123;</span><br><span class="line">		return new User(1001,name);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		return User.class;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public boolean isSingleton() &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>XML配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.sc.spring.FactoryUser&quot;&gt;</span><br><span class="line">	&lt;!-- 设置工厂类的参数 --&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;李雷&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第5节-bean配置的继承"><a href="#第5节-bean配置的继承" class="headerlink" title="第5节 bean配置的继承"></a>第5节 bean配置的继承</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring允许继承bean的配置，被继承的bean称为父bean。继承这个父bean的bean称为子bean。子bean从父bean中继承配置，包括bean的属性配置.子bean也可以覆盖从父bean继承过来的配置</span><br></pre></td></tr></table></figure></li>
<li><p>Java代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">	private Integer id;</span><br><span class="line">	private String name;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student extends User &#123;</span><br><span class="line">	private String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>XML配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.sc.spring.User&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;lilei&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;student&quot; parent=&quot;user&quot; class=&quot;com.sc.spring.Student&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第6节-bean之间的依赖"><a href="#第6节-bean之间的依赖" class="headerlink" title="第6节 bean之间的依赖"></a>第6节 bean之间的依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有的时候创建一个bean的时候需要保证另外一个bean也被创建，这时我们称前面的bean对后面的bean有依赖。例如：要求创建Employee对象的时候必须创建Department。这里需要注意的是依赖关系不等于引用关系，Employee即使依赖Department也可以不引用它</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;emp&quot; class=&quot;com.sc.spring.Employee&quot; depends-on=&quot;dept&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;id&quot; value=&quot;2001&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;emp2&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;dept&quot; class=&quot;com.sc.spring.Department&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;IT事业部&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第7节-bean的作用域"><a href="#第7节-bean的作用域" class="headerlink" title="第7节 bean的作用域"></a>第7节 bean的作用域</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Spring中，可以在bean元素的scope属性里设置bean的作用域，以决定这个bean是单实例的还是多实例的。默认情况下，Spring只为每个在IOC容器里声明的bean创建唯一一个实例，整个IOC容器范围内都能共享该实例：所有后续的getBean()调用和bean引用都将返回这个唯一的bean实例。该作用域被称为 singleton，它是所有bean的默认作用域</span><br></pre></td></tr></table></figure></li>
</ul>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton</td>
<td align="left">在IOC容器中仅存在一个bean实例，bean以单实例的方式存在</td>
</tr>
<tr>
<td align="left">prototype</td>
<td align="left">每次调用getBean()时都会返回新的实例</td>
</tr>
</tbody></table>
<ul>
<li><p>xml配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.sc.spring.User&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;id&quot; value=&quot;1001&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;lilei&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注解配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Scope(value=&quot;prototype&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class User&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class="line">User bean = (User) ioc.getBean(&quot;user&quot;);</span><br><span class="line">User bean2 = (User) ioc.getBean(&quot;user&quot;);</span><br><span class="line">System.out.println(bean.hashCode());</span><br><span class="line">System.out.println(bean2.hashCode());</span><br></pre></td></tr></table></figure>

<h3 id="第8节-bean的生命周期"><a href="#第8节-bean的生命周期" class="headerlink" title="第8节 bean的生命周期"></a>第8节 bean的生命周期</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring IOC容器可以管理bean的生命周期，Spring允许在bean生命周期内特定的时间点执行指定的任务</span><br><span class="line"></span><br><span class="line">在配置bean时，通过init-method和destroy-method属性为bean指定初始化和销毁方法</span><br></pre></td></tr></table></figure></li>
<li><p>Java代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">	public void init() &#123;</span><br><span class="line">		System.out.println(&quot;user被初始化了&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">		System.out.println(&quot;user被销毁了&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>XML配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;user&quot; class=&quot;com.sc.spring.User&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test01() &#123;</span><br><span class="line">	//ConfigurableApplicationContext: 带有关闭IOC容器的方法,如果不关闭IOC容器不会调用销毁方法</span><br><span class="line">	ConfigurableApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class="line">	User bean = (User) ioc.getBean(&quot;user&quot;);</span><br><span class="line">	System.out.println(bean);</span><br><span class="line">	ioc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第9节-bean的后置处理器"><a href="#第9节-bean的后置处理器" class="headerlink" title="第9节 bean的后置处理器"></a>第9节 bean的后置处理器</h3></li>
<li><p>后置处理器介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bean后置处理器允许在调用初始化方法前后对bean进行额外的处理;bean后置处理器对IOC容器里的所有bean实例逐一处理，而非单一实例。其典型应用是：检查bean属性的正确性或根据特定的标准更改bean的属性;bean后置处理器需要实现接口：org.springframework.beans.factory.config.BeanPostProcessor</span><br><span class="line"></span><br><span class="line">在初始化方法被调用前后，Spring将把每个bean实例分别传递给上述接口的以下两个方法：</span><br><span class="line"> - postProcessBeforeInitialization(Object, String)</span><br><span class="line"> - postProcessAfterInitialization(Object, String)</span><br></pre></td></tr></table></figure></li>
<li><p>Java代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ABeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">	public ABeanPostProcessor() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		System.out.println(&quot;postProcessBeforeInitialization=&quot;+bean+&quot;beanName:&quot;+beanName);</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">		System.out.println(&quot;postProcessBeforeInitialization=&quot;+bean+&quot;beanName:&quot;+beanName);</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>XML配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;com.sc.spring.ABeanPostProcessor&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h3 id="第10节-外部资源导入配置"><a href="#第10节-外部资源导入配置" class="headerlink" title="第10节 外部资源导入配置"></a>第10节 外部资源导入配置</h3></li>
<li><p>直接配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///test&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>外部资源配置方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- classpath:表示属性文件位于类路径下 --&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;user&quot; value=&quot;$&#123;user&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">直接配置方式是将配置信息直接写在XML配置文件中,这样不好管理,所以我们将配置信息抽出放在一个properties文件中: db.properties</span><br><span class="line"></span><br><span class="line">user=root</span><br><span class="line">password=root</span><br><span class="line">url=jdbc:mysql://localhost:3306/hello</span><br><span class="line">driver=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第11节-自动装配"><a href="#第11节-自动装配" class="headerlink" title="第11节 自动装配"></a>第11节 自动装配</h3><h4 id="11-1-基于xml的自动装配"><a href="#11-1-基于xml的自动装配" class="headerlink" title="11.1 基于xml的自动装配"></a>11.1 基于xml的自动装配</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过设置 autowire 属性来进行自动装配</span><br><span class="line"></span><br><span class="line">1. byType : 通过类型进行匹配</span><br><span class="line">2. byName : 通过bean的id进行匹配</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Java代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserDao &#123;</span><br><span class="line"></span><br><span class="line">	private String msg=&quot;我是userDao&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">	private UserDao userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">	private UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>XML配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.sc.spring.UserDao&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!-- byName是通过id进行查找 --&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.sc.spring.UserService&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;</span><br><span class="line">	</span><br><span class="line">&lt;bean class=&quot;com.sc.spring.UserController&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="11-2-基于注解的自动装配"><a href="#11-2-基于注解的自动装配" class="headerlink" title="11.2 基于注解的自动装配"></a>11.2 基于注解的自动装配</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过以下注解进行自动装配</span><br><span class="line"></span><br><span class="line">1. @Autowired 注解 : 根据类型装配</span><br><span class="line">2. @Resource  注解 : 根据名称装配</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第三章-SpEL表达式"><a href="#第三章-SpEL表达式" class="headerlink" title="第三章 SpEL表达式"></a>第三章 SpEL表达式</h2><h3 id="第1节-SpEL表达式简介"><a href="#第1节-SpEL表达式简介" class="headerlink" title="第1节 SpEL表达式简介"></a>第1节 SpEL表达式简介</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring Expression Language,Spring表达式语言,简称SpEL.和JSP页面上的EL表达式一样,SpEL根据JavaBean风格的getXxx()、setXxx()方法定义的属性访问对象图,完全符合我们熟悉的操作习惯</span><br></pre></td></tr></table></figure>

<h3 id="第2节-SpEL基本语法"><a href="#第2节-SpEL基本语法" class="headerlink" title="第2节 SpEL基本语法"></a>第2节 SpEL基本语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SpEL语法格式#&#123;…&#125;，所有在大框号中的字符都将被认为是SpEL表达式</span><br></pre></td></tr></table></figure>

<h3 id="第3节-SpEL的使用"><a href="#第3节-SpEL的使用" class="headerlink" title="第3节 SpEL的使用"></a>第3节 SpEL的使用</h3><h4 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">整数:&lt;property name=&quot;count&quot; value=&quot;#&#123;5&#125;&quot;/&gt;</span><br><span class="line">小数:&lt;property name=&quot;frequency&quot; value=&quot;#&#123;89.7&#125;&quot;/&gt;</span><br><span class="line">科学计数法:&lt;property name=&quot;capacity&quot; value=&quot;#&#123;1e4&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-String数据类型"><a href="#3-2-String数据类型" class="headerlink" title="3.2 String数据类型"></a>3.2 String数据类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String类型的字面量可以使用单引号或者双引号作为字符串的定界符号</span><br><span class="line"></span><br><span class="line">&lt;property name=&quot;name&quot; value=&quot;#&#123;&#x27;sc&#x27;&#125;&quot;/&gt;</span><br><span class="line">或</span><br><span class="line">&lt;property name=&#x27;name&#x27; value=&#x27;#&#123;&quot;sc&quot;&#125;&#x27;/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-引用其他bean"><a href="#3-3-引用其他bean" class="headerlink" title="3.3 引用其他bean"></a>3.3 引用其他bean</h4><ul>
<li><p>Java代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Department &#123;</span><br><span class="line"></span><br><span class="line">	private Integer deptId;</span><br><span class="line">	private String deptName;</span><br><span class="line">	</span><br><span class="line">	public String getDeptName()&#123;</span><br><span class="line">	    return deptName;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static String getInfo()&#123;</span><br><span class="line">	    return deptName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Employee &#123;</span><br><span class="line"></span><br><span class="line">	private Integer empId;</span><br><span class="line">	private String empName;</span><br><span class="line"></span><br><span class="line">	private Department department;</span><br><span class="line">	</span><br><span class="line">	private String deptName;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>XML配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bean id=&quot;dept&quot; class=&quot;com.sc.entity.Department&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;emp1&quot; class=&quot;com.sc.entity.Employee&quot;&gt;</span><br><span class="line">	&lt;!-- 引用其他bean --&gt;</span><br><span class="line">	&lt;property name=&quot;department&quot; value=&quot;#&#123;dept&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-引用其他bean的属性"><a href="#3-4-引用其他bean的属性" class="headerlink" title="3.4 引用其他bean的属性"></a>3.4 引用其他bean的属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;emp2&quot; class=&quot;com.sc.entity.Employee&quot;&gt;</span><br><span class="line">	&lt;!-- 引用其他bean --&gt;</span><br><span class="line">	&lt;property name=&quot;department&quot; value=&quot;#&#123;dept&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;!-- 引入其他bean的属性值 --&gt;</span><br><span class="line">	&lt;property name=&quot;deptName&quot; value=&quot;#&#123;dept.deptName&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-调用非静态方法"><a href="#3-5-调用非静态方法" class="headerlink" title="3.5 调用非静态方法"></a>3.5 调用非静态方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bean id=&quot;dept&quot; class=&quot;com.sc.entity.Department&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;emp3&quot; class=&quot;com.sc.entity.Employee&quot;&gt;</span><br><span class="line">	&lt;!-- 调用非静态方法的给属性赋值 --&gt;</span><br><span class="line">	&lt;property name=&quot;deptName&quot; value=&quot;#&#123;dept.getDeptName(方法入参)&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-6-调用静态方法"><a href="#3-6-调用静态方法" class="headerlink" title="3.6 调用静态方法"></a>3.6 调用静态方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;emp4&quot; class=&quot;com.sc.entity.Employee&quot;&gt;</span><br><span class="line">	&lt;!-- </span><br><span class="line">		调用静态方法的给属性赋值</span><br><span class="line">		T(): 表示 Department是外部类非Spring定义的bean所以使用表达式T()</span><br><span class="line">		T表达式里面的类使用全类名进行表示</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;property name=&quot;deptName&quot; value=&quot;#&#123;T(com.sc.entity.Department).getInfo()&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-运算符"><a href="#3-7-运算符" class="headerlink" title="3.7 运算符"></a>3.7 运算符</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 算术运算符：+、-、*、/、%、^</span><br><span class="line">② 字符串连接：+</span><br><span class="line">③ 比较运算符：&lt;、&gt;、==、&lt;=、&gt;=、lt、gt、eq、le、ge</span><br><span class="line">④ 逻辑运算符：and, or, not, |</span><br><span class="line">⑤ 三目运算符：判断条件?判断结果为true时的取值:判断结果为false时的取值</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第四章-Spring的AOP"><a href="#第四章-Spring的AOP" class="headerlink" title="第四章 Spring的AOP"></a>第四章 Spring的AOP</h2><h4 id="第1节-AOP简介"><a href="#第1节-AOP简介" class="headerlink" title="第1节 AOP简介"></a>第1节 AOP简介</h4><ul>
<li><p>AOP的概念</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</span><br></pre></td></tr></table></figure></li>
<li><p>AOP的本质</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码重用的一种解决方案</span><br><span class="line"></span><br><span class="line">传统的解决代码重用的方式：</span><br><span class="line"></span><br><span class="line">1. 将重复的代码抽取成一个方法</span><br><span class="line">2. 将重复的代码抽取到一个基类中</span><br><span class="line">3. 动态代理的方式</span><br></pre></td></tr></table></figure>

<h4 id="第2节-动态代理"><a href="#第2节-动态代理" class="headerlink" title="第2节 动态代理"></a>第2节 动态代理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ProxyMathUtil &#123;</span><br><span class="line">	//目标代理对象</span><br><span class="line">	private Object target;</span><br><span class="line"></span><br><span class="line">	public ProxyMathUtil(Object target) &#123;</span><br><span class="line">		this.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public Object getProxy() &#123;</span><br><span class="line">		return Proxy.newProxyInstance(this.target.getClass().getClassLoader(),this.target.getClass().getInterfaces(),new InvocationHandler() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">				Object object = method.invoke(target, args);</span><br><span class="line">				return object;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第3节-AOP术语介绍"><a href="#第3节-AOP术语介绍" class="headerlink" title="第3节 AOP术语介绍"></a>第3节 AOP术语介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 横切关注点: 从每个方法中抽取出来的同一类非核心业务</span><br><span class="line">2. 切面 Aspect: 封装横切关注点信息的类</span><br><span class="line">3. 通知 Advice: 切面要完成的具体工作</span><br><span class="line">4. 目标 Target: 被通知的对象</span><br><span class="line">5. 代理 Proxy: 向目标对象应用通知之后创建的代理对象</span><br><span class="line">6. 连接点 Joinpoint: 横切关注点在程序代码中的具体体现对应程序执行的某个特定位置</span><br><span class="line">7. 切入点 pointcut： 查询具体连接点的表达式</span><br><span class="line">8. 切入点的格式: execution([权限修饰符][返回值类型][简单类名/全类名]方法名)</span><br><span class="line"></span><br><span class="line">切入点格式举例</span><br><span class="line">精确匹配: execution(public int com.sc.aop.MathCaculator.add(int,int))</span><br><span class="line">通配符匹配： execution(* *.*(..))</span><br></pre></td></tr></table></figure>

<h4 id="第4节-AOP实现方式"><a href="#第4节-AOP实现方式" class="headerlink" title="第4节 AOP实现方式"></a>第4节 AOP实现方式</h4></li>
</ul>
<h5 id="4-1-注解方式"><a href="#4-1-注解方式" class="headerlink" title="4.1 注解方式"></a>4.1 注解方式</h5><ul>
<li><p>注解方式实现步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建被代理的目标类,并加入到IOC容器中</span><br><span class="line">2. 创建切面类,并加入到IOC容器中，同时给切面类添加@Aspect注解，表明当前类是一个切面类</span><br><span class="line">3. 在切面类中声明通知方法</span><br><span class="line"> - 前置通知: @Before</span><br><span class="line"> - 返回通知: @AfterReturning</span><br><span class="line"> - 后置通知: @After</span><br><span class="line"> - 异常通知: @AfterThrowing</span><br><span class="line"> - 环绕通知: @Around</span><br></pre></td></tr></table></figure></li>
<li><p>代码实现</p>
</li>
<li><ul>
<li><p>创建目标接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface MathCalculator &#123;</span><br><span class="line"></span><br><span class="line">	int add(int x,int y);</span><br><span class="line">	</span><br><span class="line">	int sub(int x,int y);</span><br><span class="line">	</span><br><span class="line">	int mul(int x,int y);</span><br><span class="line">	</span><br><span class="line">	int div(int x,int y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>创建目标接口实现类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MathCalculatorImpl implements MathCalculator &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int add(int x, int y) &#123;</span><br><span class="line">		return x+y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int sub(int x, int y) &#123;</span><br><span class="line">		</span><br><span class="line">		return x-y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int mul(int x, int y) &#123;</span><br><span class="line">		</span><br><span class="line">		return x*y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public int div(int x, int y) &#123;</span><br><span class="line">		</span><br><span class="line">		return x/y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>创建切面类/在切面类中定义通知方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class AopAspect &#123;</span><br><span class="line">	</span><br><span class="line">	//前置通知</span><br><span class="line">	@Before(&quot;execution(public int com.sc.aop.MathCaculator.*(..))&quot;)</span><br><span class="line">	public void methodStart(JoinPoint joinPoint) &#123;</span><br><span class="line">		System.out.println(&quot;前置通知&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//返回通知</span><br><span class="line">	@AfterReturning(pointcut=&quot;execution(public int com.sc.aop.MathCaculator.*(..))&quot;,returning=&quot;abc&quot;)</span><br><span class="line">	public void methodReturn(Object abc) &#123;</span><br><span class="line">		System.out.println(&quot;返回通知&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//异常通知</span><br><span class="line">	@AfterThrowing(pointcut=&quot;execution(public int com.sc.aop.MathCaculator.*(..))&quot;,throwing=&quot;e&quot;)</span><br><span class="line">	public void methodThrow(Exception e) &#123;</span><br><span class="line">		System.out.println(&quot;异常通知&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//后置通知</span><br><span class="line">	@After(&quot;execution(public int com.sc.aop.MathCaculator.*(..))&quot;)</span><br><span class="line">	public void methodAfter() &#123;</span><br><span class="line">		System.out.println(&quot;后置通知&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//环绕通知</span><br><span class="line">	@Around(&quot;execution(public int com.sc.aop.MathCaculator.*(..))&quot;)</span><br><span class="line">	public Object methodAround(ProceedingJoinPoint joinPoint) &#123;</span><br><span class="line">		Object r=0;</span><br><span class="line">		System.out.println(&quot;环绕--&gt;前置通知&quot;);</span><br><span class="line">		try &#123;</span><br><span class="line">			r = joinPoint.proceed();</span><br><span class="line">			System.out.println(&quot;环绕--&gt;返回通知&quot;);</span><br><span class="line">		&#125; catch (Throwable e) &#123;</span><br><span class="line">			System.out.println(&quot;环绕--&gt;异常通知&quot;);</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			System.out.println(&quot;环绕--&gt;后置通知&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>xml中开启AOP的注解功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 扫描需要被扫描的包,实例化对象 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;com.sc.aop&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启AOP注解功能 --&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>JoinPoint 方法入参获取方法信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取方法名</span><br><span class="line">String methodName = joinPoint.getSignature().getName();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>方法返回值获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//returning：设置返回值参数名</span><br><span class="line">@AfterReturning(pointcut=&quot;execution(public int com.sc.aop.MathCaculator.*(..))&quot;,returning=&quot;abc&quot;)</span><br><span class="line">public void methodReturn(Object abc) &#123;</span><br><span class="line">	System.out.println(&quot;返回通知&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>接收捕获到的异常对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//throwing：设置异常参数名</span><br><span class="line">@AfterThrowing(pointcut=&quot;execution(public int com.sc.aop.MathCaculator.*(..))&quot;,throwing=&quot;e&quot;)</span><br><span class="line">public void methodThrow(Exception e) &#123;</span><br><span class="line">	System.out.println(&quot;异常通知&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>统一声明切入点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Pointcut(&quot;execution(public int com.sc.aop.MathCaculator.*(..))&quot;)</span><br><span class="line">public void log()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//前置通知</span><br><span class="line">@Before(&quot;log()&quot;)</span><br><span class="line">public void methodStart(JoinPoint joinPoint) &#123;</span><br><span class="line">	System.out.println(&quot;前置通知&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>优先级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给切面类设置优先级,当一个方法被多个切面切的时候，判断先走哪个切面。设置order注解。</span><br><span class="line">@Order(10)</span><br><span class="line">越小优先级越高</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="4-2-XML配置方式"><a href="#4-2-XML配置方式" class="headerlink" title="4.2 XML配置方式"></a>4.2 XML配置方式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 将目标代理对象加入到IOC容器中 --&gt;</span><br><span class="line">&lt;bean class=&quot;com.sc.aop.MathCaculatorImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注册切面类 --&gt;</span><br><span class="line">&lt;bean id=&quot;myAspect&quot; class=&quot;com.sc.aop.AopAspect&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">	&lt;!-- 配置切入点 --&gt;</span><br><span class="line">	&lt;aop:pointcut expression=&quot;execution(* *.*(..))&quot; id=&quot;mypointcut&quot;/&gt;</span><br><span class="line">	&lt;!-- 配置切面 --&gt;</span><br><span class="line">	&lt;aop:aspect ref=&quot;myAspect&quot;&gt;</span><br><span class="line">		&lt;!-- 前置通知 --&gt;</span><br><span class="line">		&lt;aop:before method=&quot;methodStart&quot; pointcut-ref=&quot;mypointcut&quot;/&gt;</span><br><span class="line">		&lt;!-- 返回通知 --&gt;</span><br><span class="line">		&lt;aop:after-returning method=&quot;methodReturn&quot; pointcut-ref=&quot;mypointcut&quot; returning=&quot;abc&quot;/&gt;</span><br><span class="line">		&lt;!-- 异常通知 --&gt;</span><br><span class="line">		&lt;aop:after-throwing method=&quot;methodThrow&quot; pointcut-ref=&quot;mypointcut&quot; throwing=&quot;e&quot;/&gt;</span><br><span class="line">		&lt;!-- 后置通知 --&gt;</span><br><span class="line">		&lt;aop:after method=&quot;methodAfter&quot; pointcut-ref=&quot;mypointcut&quot;/&gt;</span><br><span class="line">		&lt;!-- 环绕通知 --&gt;</span><br><span class="line">		&lt;aop:around method=&quot;methodAround&quot; pointcut-ref=&quot;mypointcut&quot;/&gt;</span><br><span class="line">	&lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第五章-Spring的事务管理"><a href="#第五章-Spring的事务管理" class="headerlink" title="第五章 Spring的事务管理"></a>第五章 Spring的事务管理</h2><h3 id="第1节-事物介绍"><a href="#第1节-事物介绍" class="headerlink" title="第1节 事物介绍"></a>第1节 事物介绍</h3><ul>
<li><p>什么是事务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">事务是逻辑上的一组操作,这组操作要么全部成功，有一个失败就全部失败</span><br></pre></td></tr></table></figure></li>
<li><p>事务的特性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 原子性</span><br><span class="line">2. 一致性</span><br><span class="line">3. 隔离性</span><br><span class="line">4. 永久性</span><br></pre></td></tr></table></figure></li>
<li><p>事务的隔离级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 读已提交-&gt; READ_COMMITTED -&gt; 可避免脏读的发生</span><br><span class="line">2. 读未提交-&gt; READ_UNCOMMITTED -&gt; 最低级别，任何情况都无法保证</span><br><span class="line">3. 可重复读-&gt; REPEATABLE_READ -&gt; 可避免脏读、不可重复读的发生</span><br><span class="line">4. 串行化-&gt; SERIALIZABLE -&gt; 可避免脏读、不可重复读、幻读的发生</span><br></pre></td></tr></table></figure></li>
<li><p>没有隔离级别产生的问题</p>
</li>
<li><ul>
<li><p>脏读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个事物读取的数据是另一个事物还没有来得及提交的数据，会造成脏读的问题</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>幻读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">幻读是指，如果我正在对一个数据库表进行全部的修改某几个属性的值，同时还有其他事物向数据库表中添加数据，当修改完查询的时候发现出现了有的字段属性值没有修改成功，这时候就产生幻读问题.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>不可重复读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不可重复读是指在一个事务当中通过相同条件多次查询相同的数据，返回的结果集不相同。造成的原因是有其他事物正在不断的修改这些数据.</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>MYSQL的事务操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. mysql默认的隔离级别 : REPEATABLE_READ</span><br><span class="line">2. oracle默认的隔离级别 : READ_COMMITTED</span><br><span class="line">3. 查询当前mysql事务 : select @@tx_isolation;</span><br><span class="line">4. 修改当前mysql事务 : set tx_isolation=&#x27;REPEATABLE-READ&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="第2节-Spring的事务API介绍"><a href="#第2节-Spring的事务API介绍" class="headerlink" title="第2节 Spring的事务API介绍"></a>第2节 Spring的事务API介绍</h3></li>
<li><p>PlatformTransactionManager : 平台事务管理器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对ORM框架的事物进行管理</span><br><span class="line">1. JDBC/Mybatis : DataSourceTransactionManager</span><br><span class="line">2. hibernate ：Hibernate3TransactionManager/Hibernate4TransactionManager/Hibernate5TransactionManager</span><br></pre></td></tr></table></figure></li>
<li><p>TransactionDefinition: 事务定义信息(隔离级别,传播行为,超时,只读)</p>
</li>
<li><ul>
<li><p>隔离级别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISOLATION_DEFAULT -&gt; 使用数据库的隔离级别</span><br><span class="line">ISOLATION_READ_COMMITTED</span><br><span class="line">ISOLATION_READ_UNCOMMITTED</span><br><span class="line">ISOLATION_REPEATABLE_READ</span><br><span class="line">ISOLATION_SERIALIZABLE</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>传播行为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROPAGATION_REQUIRED -&gt; 支持当前事务如果不存在就重新创建一个</span><br><span class="line">PROPAGATION_SUPPORTS -&gt; 支持当前事务，如果不存在就不使用事务</span><br><span class="line">PROPAGATION_MANDATORY -&gt; 支持当前事务,如果不存在就抛出异常</span><br><span class="line">PROPAGATION_REQUIRES_NEW -&gt; 如果有事务存在,就挂起当前事务，创建一个新事务</span><br><span class="line">PROPAGATION_NOT_SUPPORTED -&gt; 以非事务方式运行,如果有事务存在就挂起当前事务</span><br><span class="line">PROPAGATION_NEVER -&gt; 以非事务方式运行,如果有事务就抛出异常</span><br><span class="line">PROPAGATION_NESTED -&gt; 如果当前事务存在就嵌套事务运行</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>超时时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TIMEOUT_DEFAULT</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>TransactionStatus： 事务具体运行状态</p>
</li>
</ul>
<h3 id="第3节-Spring的事务实现"><a href="#第3节-Spring的事务实现" class="headerlink" title="第3节 Spring的事务实现"></a>第3节 Spring的事务实现</h3><h4 id="3-1-环境准备"><a href="#3-1-环境准备" class="headerlink" title="3.1 环境准备"></a>3.1 环境准备</h4><ul>
<li><p>创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database spring default character set utf8;</span><br></pre></td></tr></table></figure></li>
<li><p>创建数据库表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE account(</span><br><span class="line">    `id` int  not null primary key auto_increment,</span><br><span class="line">    `name` varchar(10) not null comment &#x27;账户&#x27;,</span><br><span class="line">    `money` double default 0.0</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=UTF8 COMMENT = &#x27;账户表&#x27;;</span><br><span class="line"></span><br><span class="line">INSERT INTO account(name,money) VALUES(&quot;li4&quot;,1000),(&quot;z3&quot;,1000);</span><br></pre></td></tr></table></figure></li>
<li><p>创建Java工程添加jar包或者依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c3p0-0.9.1.2.jar</span><br><span class="line">com.springsource.net.sf.cglib-2.2.0.jar</span><br><span class="line">com.springsource.org.aopalliance-1.0.0.jar</span><br><span class="line">com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar</span><br><span class="line">commons-logging-1.2.jar</span><br><span class="line">mysql-connector-java-5.1.44.jar</span><br><span class="line">spring-aop-4.3.10.RELEASE.jar</span><br><span class="line">spring-aspects-4.3.10.RELEASE.jar</span><br><span class="line">spring-beans-4.3.10.RELEASE.jar</span><br><span class="line">spring-context-4.3.10.RELEASE.jar</span><br><span class="line">spring-context-support-4.3.10.RELEASE.jar</span><br><span class="line">spring-core-4.3.10.RELEASE.jar</span><br><span class="line">spring-expression-4.3.10.RELEASE.jar</span><br><span class="line">spring-jdbc-4.3.10.RELEASE.jar</span><br><span class="line">spring-orm-4.3.10.RELEASE.jar</span><br><span class="line">spring-oxm-4.3.10.RELEASE.jar</span><br><span class="line">spring-test-4.3.10.RELEASE.jar</span><br><span class="line">spring-tx-4.3.10.RELEASE.jar</span><br></pre></td></tr></table></figure></li>
<li><p>创建外部属性资源文件(数据库配置信息)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//db.properties</span><br><span class="line"></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br><span class="line">jdbc.url=jdbc:mysql://127.0.0.1:3306/spring?useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">jdbc.driverClass=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure></li>
<li><p>创建Dao层接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface AccountDao &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 转入金额</span><br><span class="line">	 * @param in </span><br><span class="line">	 * @param money</span><br><span class="line">	 */</span><br><span class="line">	void inMoney(String in,double money);</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 转出金额</span><br><span class="line">	 * @param out</span><br><span class="line">	 * @param money</span><br><span class="line">	 */</span><br><span class="line">	void outMoney(String out,double money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建Dao层接口实现类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void inMoney(String in, double money) &#123;</span><br><span class="line">		</span><br><span class="line">		String sql=&quot;UPDATE account set money=money-? WHERE name=?&quot;;</span><br><span class="line">		</span><br><span class="line">		this.getJdbcTemplate().update(sql, money, in);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void outMoney(String out, double money) &#123;</span><br><span class="line"></span><br><span class="line">		String sql=&quot;UPDATE account set money=money+? WHERE name=?&quot;;</span><br><span class="line">		</span><br><span class="line">		this.getJdbcTemplate().update(sql, money, out);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建service层接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface AccountService &#123;</span><br><span class="line">	/*转账*/</span><br><span class="line">	void transfer(String in,String out,double money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建service层接口实现类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AccountServiceImpl implements AccountService&#123;</span><br><span class="line"></span><br><span class="line">	private AccountDao accountDao;</span><br><span class="line">	</span><br><span class="line">	public void setAccountDao(AccountDao accountDao) &#123;</span><br><span class="line">		this.accountDao = accountDao;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void transfer(String in, String out, double money) &#123;</span><br><span class="line">		//转出</span><br><span class="line">		accountDao.outMoney(in, money);</span><br><span class="line">		//int i = 1/0;</span><br><span class="line">		//转入</span><br><span class="line">		accountDao.inMoney(out, money);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写spring的核心配置文件applicationContext.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 导入外部属性资源文件 --&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</span><br><span class="line">&lt;!-- 配置数据库连接池 --&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 注册AccountDao --&gt;</span><br><span class="line">&lt;bean id=&quot;accountDao&quot; class=&quot;com.sc.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 注册AccountService --&gt;</span><br><span class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.sc.service.AccountServiceImpl&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>测试环境是否搭建成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test() &#123;</span><br><span class="line">	</span><br><span class="line">	ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">	AccountService accountService = (AccountService) ioc.getBean(&quot;accountService&quot;);</span><br><span class="line">	//李四转账给张三500元</span><br><span class="line">	accountService.transfer(&quot;zs&quot;, &quot;ls&quot;, 500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-编程式事务实现"><a href="#3-2-编程式事务实现" class="headerlink" title="3.2 编程式事务实现"></a>3.2 编程式事务实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Spring为了简化我们的开发,提供了TransactionTemplate这样的一个事务管理模板，所以编程式事务管理采用此模板进行管理。</span><br><span class="line">2. 在AccountService中使用TransactionTemplate</span><br><span class="line">3. TransactionTemplate依赖DataSourceTransactionManager</span><br><span class="line">4. DataSourceTransactionManager依赖DataSource</span><br></pre></td></tr></table></figure></li>
<li><p>Java类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AccountServiceImpl implements AccountService&#123;</span><br><span class="line"></span><br><span class="line">	private AccountDao accountDao;</span><br><span class="line">	public void setAccountDao(AccountDao accountDao) &#123;</span><br><span class="line">		this.accountDao = accountDao;</span><br><span class="line">	&#125;</span><br><span class="line">	private TransactionTemplate transactionTemplate;</span><br><span class="line">	public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123;</span><br><span class="line">		this.transactionTemplate = transactionTemplate;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void transfer(String in, String out, double money) &#123;</span><br><span class="line">		</span><br><span class="line">		transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line">			</span><br><span class="line">			@Override</span><br><span class="line">			protected void doInTransactionWithoutResult(TransactionStatus status) &#123;</span><br><span class="line">				//转出</span><br><span class="line">				accountDao.outMoney(in, money);</span><br><span class="line">				int i = 1/0;</span><br><span class="line">				//转入</span><br><span class="line">				accountDao.inMoney(out, money);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>XML配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 导入外部属性资源文件 --&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</span><br><span class="line">&lt;!-- 配置数据库连接池 --&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 注册AccountDao --&gt;</span><br><span class="line">&lt;bean id=&quot;accountDao&quot; class=&quot;com.sc.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">	&lt;!-- 注入数据源,用于创建JdbcTemplate --&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 注册AccountService --&gt;</span><br><span class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.sc.service.AccountServiceImpl&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;!-- 设置事务管理模板 --&gt;</span><br><span class="line">	&lt;property name=&quot;transactionTemplate&quot; ref=&quot;transactionTemplate&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置平台事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 定义事务管理模板 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-声明式事物实现"><a href="#3-3-声明式事物实现" class="headerlink" title="3.3 声明式事物实现"></a>3.3 声明式事物实现</h4></li>
<li><p>方式一(AOP传统方式)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 配置平台事务管理器</span><br><span class="line">2. 配置事务代理(代理service层)</span><br><span class="line">    ① spring传统aop方式</span><br><span class="line">    ② TransactionProxyFactoryBean</span><br><span class="line">        * 配置目标对象</span><br><span class="line">        * 注入事务管理器</span><br><span class="line">        * 配置事务的一些属性:transactionAttributes（配置方式见源码）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML配置</span><br><span class="line"></span><br><span class="line">&lt;!-- 导入外部属性资源文件 --&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</span><br><span class="line">&lt;!-- 配置数据库连接池 --&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 注册AccountDao --&gt;</span><br><span class="line">&lt;bean id=&quot;accountDao&quot; class=&quot;com.sc.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">	&lt;!-- 注入数据源,用于创建JdbcTemplate --&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 注册AccountService --&gt;</span><br><span class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.sc.service.AccountServiceImpl&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置平台事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置业务层事务代理 --&gt;</span><br><span class="line">&lt;bean id=&quot;accountServiceProxy&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt;</span><br><span class="line">	&lt;!-- 配置目标代理对象 --&gt;</span><br><span class="line">	&lt;property name=&quot;target&quot; ref=&quot;accountService&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;!-- 注入平台事务管理器 --&gt;</span><br><span class="line">	&lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;&gt;&lt;/property&gt;</span><br><span class="line">	&lt;!-- 配置事务的属性 --&gt;</span><br><span class="line">	&lt;property name=&quot;transactionAttributes&quot;&gt;</span><br><span class="line">		&lt;props&gt;</span><br><span class="line">			&lt;!-- </span><br><span class="line">				key: 方法名 可以精确匹配,也可以使用*进行通配  save* 或者  *</span><br><span class="line">				PROPAGATION : 事务的传播行为</span><br><span class="line">				ISOLATION   : 事务的隔离级别</span><br><span class="line">				readOnly    : 只读</span><br><span class="line">				-Exception  : 发生哪些异常回滚事务</span><br><span class="line">				+Exception  : 发生哪些异常不回滚</span><br><span class="line">			 --&gt;</span><br><span class="line">			 &lt;!-- &lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED,readOnly,+Exception&lt;/prop&gt; --&gt;</span><br><span class="line">			&lt;prop key=&quot;transfer&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;</span><br><span class="line">		&lt;/props&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Test测试</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() &#123;</span><br><span class="line">	</span><br><span class="line">	ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">	//获取IOC容器中的代理增强类,不需要再获取AccountService类,因为他已经被accountServiceProxy代理。</span><br><span class="line">	AccountService accountService = (AccountService) ioc.getBean(&quot;accountServiceProxy&quot;);</span><br><span class="line">	//李四转账给张三500元</span><br><span class="line">	accountService.transfer(&quot;zs&quot;, &quot;ls&quot;, 500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方式二(AspectJ)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 导入aspectj的包/以及spring整合aspectj的包</span><br><span class="line">2. 配置平台事务管理器</span><br><span class="line">3. 配置事务的通知 tx:advice</span><br><span class="line">4. 配置AOP的切面</span><br><span class="line">    ① 配置切入点</span><br><span class="line">    ② 配置切面</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XML配置</span><br><span class="line"></span><br><span class="line">&lt;!-- 导入外部属性资源文件 --&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</span><br><span class="line">&lt;!-- 配置数据库连接池 --&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 注册AccountDao --&gt;</span><br><span class="line">&lt;bean id=&quot;accountDao&quot; class=&quot;com.sc.dao.AccountDaoImpl&quot;&gt;</span><br><span class="line">	&lt;!-- 注入数据源,用于创建JdbcTemplate --&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 注册AccountService --&gt;</span><br><span class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.sc.service.AccountServiceImpl&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置平台事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 配置事务的通知 --&gt;</span><br><span class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">	&lt;tx:attributes&gt;</span><br><span class="line">		&lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">	&lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line">&lt;!-- 配置事务的切面 --&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">	&lt;!-- </span><br><span class="line">		配置切点</span><br><span class="line">		expression: 表达式  +: 代表及其子类</span><br><span class="line">	 --&gt;</span><br><span class="line">	&lt;aop:pointcut expression=&quot;execution(* com.sc.service.AccountService+.*(..))&quot; id=&quot;mypointcut&quot;/&gt;</span><br><span class="line">	&lt;!-- 配置切面 --&gt;</span><br><span class="line">	&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;mypointcut&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>方式三(基于注解的事务管理)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置平台管理器</span><br><span class="line">开启基于注解的声明式事务管理</span><br><span class="line"> - &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</span><br><span class="line">在类上或者方法上添加@Transactional注解</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第六章-Spring的测试框架"><a href="#第六章-Spring的测试框架" class="headerlink" title="第六章 Spring的测试框架"></a>第六章 Spring的测试框架</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations= &#123;&quot;classpath:bean.xml&quot;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="第七章-Spring的多配置文件管理"><a href="#第七章-Spring的多配置文件管理" class="headerlink" title="第七章 Spring的多配置文件管理"></a>第七章 Spring的多配置文件管理</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Spring允许通过&lt;import&gt;将多个配置文件引入到一个文件中，进行配置文件的集成</span></span><br><span class="line"><span class="attr">import元素的resource属性支持Spring的标准的路径资源</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>ELK</title>
    <url>/2021/08/08/ELK%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第一章-ES简介"><a href="#第一章-ES简介" class="headerlink" title="第一章 ES简介"></a>第一章 ES简介</h2><h3 id="第1节-ES介绍"><a href="#第1节-ES介绍" class="headerlink" title="第1节 ES介绍"></a>第1节 ES介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、Elasticsearch是一个基于Lucene的搜索服务器</span><br><span class="line">2、提供了一个分布式的全文搜索引擎,基于restful web接口</span><br><span class="line">3、Elasticsearch是用Java语言开发的，基于Apache协议的开源项目，是目前最受欢迎的企业搜索引擎</span><br><span class="line">4、Elasticsearch广泛运用于云计算中，能够达到实时搜索，具有稳定，可靠，快速的特点</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第2节-ES版本"><a href="#第2节-ES版本" class="headerlink" title="第2节 ES版本"></a>第2节 ES版本</h3><ul>
<li><p>版本历史</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ES : 1.x ---&gt; 2.x ---&gt; 5.x ---&gt; 6.x ---&gt;7.x（目前）</span><br></pre></td></tr></table></figure></li>
<li><p>版本选择</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在版本选择一般选择5.x版本以上,我们本课程的学习使用6.x版本,低版本会随着官网的不断推动,在未来可能就不维护了,所以在选择的时候要尽量选择目前来说一个长期的稳定版本</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第二章-安装-v6-3-2"><a href="#第二章-安装-v6-3-2" class="headerlink" title="第二章 安装(v6.3.2)"></a>第二章 安装(v6.3.2)</h2><h3 id="第1节-window下单点安装ES"><a href="#第1节-window下单点安装ES" class="headerlink" title="第1节 window下单点安装ES"></a>第1节 window下单点安装ES</h3><ul>
<li><p>下载地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官网地址:</span><br><span class="line">https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.3.1.zip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">华为镜像站:</span><br><span class="line">https://mirrors.huaweicloud.com/elasticsearch/6.3.2/elasticsearch-6.3.2.zip</span><br></pre></td></tr></table></figure></li>
<li><p>安装步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、将下载的安装包解压到指定目录下(不能有中文)</span><br><span class="line">2、找到目录下的bin目录(比如: D:\soft\elasticsearch-6.3.2\bin)</span><br><span class="line">3、bin目录下有一个[elasticsearch.bat]脚本命令,直接鼠标双击即可,启动ES服务</span><br></pre></td></tr></table></figure></li>
<li><p>访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ES服务的默认端口号为 9200,在浏览器访问 http://localhost:9200/ 浏览器就会输出下面信息,安装成功</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;G7lh1eQ&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;4T38-ecWQ5O8OpIM3RibAw&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;6.3.2&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;zip&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;053779d&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2018-07-20T05:20:23.451332Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;7.3.1&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第2节-window下安装Head插件"><a href="#第2节-window下安装Head插件" class="headerlink" title="第2节 window下安装Head插件"></a>第2节 window下安装Head插件</h3><h4 id="2-1-Head插件介绍"><a href="#2-1-Head插件介绍" class="headerlink" title="2.1 Head插件介绍"></a>2.1 Head插件介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">是一款能连接ES,并提供对ES进行操作的可视化界面</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-Head插件下载地址"><a href="#2-2-Head插件下载地址" class="headerlink" title="2.2 Head插件下载地址"></a>2.2 Head插件下载地址</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/mobz/elasticsearch-head/archive/master.zip</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-安装步骤"><a href="#2-3-安装步骤" class="headerlink" title="2.3 安装步骤"></a>2.3 安装步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 电脑首先要安装node.js,因为安装Head插件需要使用npm命令</span><br><span class="line"></span><br><span class="line">注意: 由于npm命令使用的是国外的镜像库,所以可能会很慢或者发生失败的情况,可以有两种方式解决</span><br><span class="line">    方式一: 切换镜像地址</span><br><span class="line">        -- 查看当前npm的镜像地址: npm config get registry</span><br><span class="line">            -- 默认地址为: https://registry.npmjs.org/</span><br><span class="line">        -- 将默认镜像地址设置成淘宝的地址: npm config set registry https://registry.npm.taobao.org</span><br><span class="line">    方式二: 使用cnpm</span><br><span class="line">        -- 下载cnpm并且同时设置镜像源命令 npm install cnpm -g --registry=https://registry.npm.taobao.org</span><br><span class="line">        -- 使用cnpm -v查看</span><br><span class="line">        -- 以后使用cnpm 命令安装依赖</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">2. nodejs安装好之后,那么开始解压head插件压缩包</span><br><span class="line">3. 切换到解压文件目录下 D:\soft\elasticsearch-head-master,我的解压到了d盘soft目录下</span><br><span class="line">4. 使用cmd命令行工具切换到解压目录下,执行命令 npm install 安装</span><br><span class="line">5. 安装完成之后启动head插件 npm run start 这时候就会在在计算机9100端口号上启动服务</span><br><span class="line">6. 在浏览器访问,在浏览器中输入 http://localhost:9100/ 访问</span><br></pre></td></tr></table></figure>

<p><a href="https://note.youdao.com/yws/api/personal/file/WEB2d64f18a535bcc41fa2525377deef953?method=download&shareKey=01bc3a0de15bcb0beff502ae379e4f99"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB2d64f18a535bcc41fa2525377deef953?method=download&shareKey=01bc3a0de15bcb0beff502ae379e4f99" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<h4 id="2-4-Head插件和ES关联配置"><a href="#2-4-Head插件和ES关联配置" class="headerlink" title="2.4 Head插件和ES关联配置"></a>2.4 Head插件和ES关联配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为两个服务之间可能ip地址和端口号不同造成跨域的问题,所以需要配置可以跨域</span><br></pre></td></tr></table></figure>

<ul>
<li><p>修改ES的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、因为ES和Head插件之间是两个不同的服务,所以需要进行配置</span><br><span class="line">    - 1.1 修改ES的配置,找到我们的ES配置文件 elasticsearch-6.3.2\config\elasticsearch.yml</span><br><span class="line">    - 1.2 在文件的最后一行设置一个可以进行跨域访问的属性</span><br><span class="line">        http:</span><br><span class="line">            cors:</span><br><span class="line">                enabled: true</span><br><span class="line">                allow-origin: &quot;*&quot;</span><br><span class="line">    - 1.3 重启ES服务,重启Head服务</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第3节-window-ES-集群安装"><a href="#第3节-window-ES-集群安装" class="headerlink" title="第3节 window ES 集群安装"></a>第3节 window ES 集群安装</h3><h4 id="3-1-集群配置步骤"><a href="#3-1-集群配置步骤" class="headerlink" title="3.1 集群配置步骤"></a>3.1 集群配置步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 创建一个elasticsearch-cluster文件夹</span><br><span class="line">2. 解压我们的elasticsearch-6.3.2.zip压缩包到elasticsearch-cluster目录下</span><br><span class="line">3. 分别命名为 elasticsearch-node01,elasticsearch-node02,elasticsearch-node03</span><br><span class="line">4. 修改配置文件</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-配置文件编写"><a href="#3-2-配置文件编写" class="headerlink" title="3.2 配置文件编写"></a>3.2 配置文件编写</h4><ul>
<li><p>elasticsearch-node01节点配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 集群名称，保证唯一</span><br><span class="line">cluster.name: elasticsearch</span><br><span class="line"># 节点名称，每个节点不能相同</span><br><span class="line">node.name: node-01</span><br><span class="line"># 本机的ip地址</span><br><span class="line">network.host: 127.0.0.1</span><br><span class="line"># 服务端口号，在同一机器下端口号不能相同</span><br><span class="line">http.port: 9200</span><br><span class="line"># 集群间通信端口号，在同一机器下端口号不能相同</span><br><span class="line">transport.tcp.port: 9300</span><br><span class="line"># 设置集群自动发现机器ip集合</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;127.0.0.1:9300&quot;,&quot;127.0.0.1:9301&quot;,&quot;127.0.0.1:9302&quot;]</span><br><span class="line"># 跨域调用</span><br><span class="line">http:</span><br><span class="line">  cors:</span><br><span class="line">      enabled: true</span><br><span class="line">      allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>elasticsearch-node02节点配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 集群名称，保证唯一</span><br><span class="line">cluster.name: elasticsearch</span><br><span class="line"># 节点名称，每个节点不能相同</span><br><span class="line">node.name: node-02</span><br><span class="line"># 本机的ip地址</span><br><span class="line">network.host: 127.0.0.1</span><br><span class="line"># 服务端口号，在同一机器下端口号不能相同</span><br><span class="line">http.port: 9201</span><br><span class="line"># 集群间通信端口号，在同一机器下端口号不能相同</span><br><span class="line">transport.tcp.port: 9301</span><br><span class="line"># 设置集群自动发现机器ip集合</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;127.0.0.1:9300&quot;,&quot;127.0.0.1:9301&quot;,&quot;127.0.0.1:9302&quot;]</span><br><span class="line"># 跨域调用</span><br><span class="line">http:</span><br><span class="line">  cors:</span><br><span class="line">      enabled: true</span><br><span class="line">      allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>elasticsearch-node03节点配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 集群名称，保证唯一</span><br><span class="line">cluster.name: elasticsearch</span><br><span class="line"># 节点名称，每个节点不能相同</span><br><span class="line">node.name: node-03</span><br><span class="line"># 本机的ip地址</span><br><span class="line">network.host: 127.0.0.1</span><br><span class="line"># 服务端口号，在同一机器下端口号不能相同</span><br><span class="line">http.port: 9202</span><br><span class="line"># 集群间通信端口号，在同一机器下端口号不能相同</span><br><span class="line">transport.tcp.port: 9302</span><br><span class="line"># 设置集群自动发现机器ip集合</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;127.0.0.1:9300&quot;,&quot;127.0.0.1:9301&quot;,&quot;127.0.0.1:9302&quot;]</span><br><span class="line"># 跨域调用</span><br><span class="line">http:</span><br><span class="line">  cors:</span><br><span class="line">      enabled: true</span><br><span class="line">      allow-origin: &quot;*&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重启各个节点</span><br><span class="line"></span><br><span class="line">注意: 如果在重启各个节点时出现点击启动脚本闪退的问题,可能造成的原因是配置文件需要使用UTF-8编码的格式编写</span><br><span class="line">解决方式,使用notepad++修改当前配置文件的编码格式为utf-8</span><br><span class="line"></span><br><span class="line">重启Head服务</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEBa082370d84f533e37e4ea5b917d8d4ca?method=download&shareKey=96eaf03ba8681704ff296f21539d814a"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBa082370d84f533e37e4ea5b917d8d4ca?method=download&shareKey=96eaf03ba8681704ff296f21539d814a" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 图中黑色的粗框代表这分片</span><br><span class="line">2. 细的黑框代表着副本</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第三章-基础概念"><a href="#第三章-基础概念" class="headerlink" title="第三章 基础概念"></a>第三章 基础概念</h2><h3 id="第1节-索引"><a href="#第1节-索引" class="headerlink" title="第1节 索引"></a>第1节 索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">含有相同属性的文档集合,相当于我们MYSQL数据库中的数据库(DATABASE)</span><br></pre></td></tr></table></figure>

<h3 id="第2节-类型"><a href="#第2节-类型" class="headerlink" title="第2节 类型"></a>第2节 类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">索引可以定义一个或多个类型(ES6中已经逐步弃用,在更高的7版本中已经删除),文档必须属于一个类型,相当于我们MYSQL中的一个表(TABLE)</span><br></pre></td></tr></table></figure>

<h3 id="第3节-文档"><a href="#第3节-文档" class="headerlink" title="第3节 文档"></a>第3节 文档</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文档是可以被索引的基本数据单位,相当于MYSQL数据库表中的一行记录</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第4节-分片-副本-备份"><a href="#第4节-分片-副本-备份" class="headerlink" title="第4节 分片/副本(备份)"></a>第4节 分片/副本(备份)</h3><ul>
<li><p>分片(shard)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 每个索引有一个或多个分片</span><br><span class="line">2. 索引的数据被分配到各个分片上,相当于一桶水使用多个杯子去装,分片有助于横向扩展</span><br><span class="line">3. 如果将大量的数据保存到一个分片里面,那么分片越来越大数据越来越多,查找性能越来越差</span><br><span class="line">4. 默认情况下一个索引创建5个分片</span><br><span class="line">5. 分片会默认的分配到es集群的各个节点上,集群自动完成</span><br></pre></td></tr></table></figure></li>
<li><p>副本(replica)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 副本,可以理解为分片的备份</span><br><span class="line">2. 主分片和副本(备分片)不会出现在同一个节点上(防止单点故障)默认情况下一个索引创建5个分片一个备份(5个主分片+5个副本分片=10个分片)</span><br><span class="line">3. 如果只有一个es节点,那么replica就无法分配(因为主/副不能同在一个节点上),此时cluster status会变成Yellow</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第四章-基本用法"><a href="#第四章-基本用法" class="headerlink" title="第四章 基本用法"></a>第四章 基本用法</h2><h3 id="第1节-ES-的-RESTFul-API"><a href="#第1节-ES-的-RESTFul-API" class="headerlink" title="第1节 ES 的 RESTFul API"></a>第1节 ES 的 RESTFul API</h3><ul>
<li><p>API的基本格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://&lt;ip&gt;:&lt;port&gt;/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>常用的HTTP动作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET/POST/PUT/DELETE</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第2节-创建索引"><a href="#第2节-创建索引" class="headerlink" title="第2节 创建索引"></a>第2节 创建索引</h3><h4 id="2-1-使用Head插件创建索引"><a href="#2-1-使用Head插件创建索引" class="headerlink" title="2.1 使用Head插件创建索引"></a>2.1 使用Head插件创建索引</h4><ul>
<li><p>创建索引的步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 登陆Head页面</span><br><span class="line">2. 找到索引标签</span><br><span class="line">3. 新建索引</span><br><span class="line">4. 添加索引名称(英文,全部都是小写字母,不能用下划线开头)</span><br><span class="line">5. 索引创建成功之后回到概览页面就会在上面发现我们新建的索引</span><br></pre></td></tr></table></figure></li>
<li><p>Head页面展示</p>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB0c2cf6c12beac90cf956da8adddb81e1?method=download&shareKey=fc77913e32aa18f22010089bfe7f9888"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB0c2cf6c12beac90cf956da8adddb81e1?method=download&shareKey=fc77913e32aa18f22010089bfe7f9888" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<h4 id="2-2-结构化索引-非结构化索引"><a href="#2-2-结构化索引-非结构化索引" class="headerlink" title="2.2 结构化索引/非结构化索引"></a>2.2 结构化索引/非结构化索引</h4><ul>
<li>结构化和非结构化介绍</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入我们的Head界面,进入概览,点击索引名称下面的信息,点击索引信息,查看数据里面有一个mappings属性,内容为空,说明我们此索引为非结构化索引</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;state&quot;: &quot;open&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &#123;</span><br><span class="line">            &quot;creation_date&quot;: &quot;1597547149325&quot;,</span><br><span class="line">            &quot;number_of_shards&quot;: &quot;5&quot;,</span><br><span class="line">            &quot;number_of_replicas&quot;: &quot;1&quot;,</span><br><span class="line">            &quot;uuid&quot;: &quot;UvYCPtp0TZeCiPexCT517g&quot;,</span><br><span class="line">            &quot;version&quot;: &#123;</span><br><span class="line">                &quot;created&quot;: &quot;6030299&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;provided_name&quot;: &quot;book&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;: &#123;&#125;,</span><br><span class="line">    &quot;aliases&quot;: [],</span><br><span class="line">    &quot;primary_terms&quot;: &#123;</span><br><span class="line">        &quot;0&quot;: 1,</span><br><span class="line">        &quot;1&quot;: 1,</span><br><span class="line">        &quot;2&quot;: 1,</span><br><span class="line">        &quot;3&quot;: 1,</span><br><span class="line">        &quot;4&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;in_sync_allocations&quot;: &#123;</span><br><span class="line">        &quot;0&quot;: [</span><br><span class="line">            &quot;BHBNGrGCSiOl-wuKptvGtQ&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;1&quot;: [</span><br><span class="line">            &quot;yMyL9GsMR9SziVr9OK_Uxw&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;2&quot;: [</span><br><span class="line">            &quot;b8EGEtGlTySAqvlKPtW_EA&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;3&quot;: [</span><br><span class="line">            &quot;0azU6MwTSCqMdzVXyuPVrw&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;4&quot;: [</span><br><span class="line">            &quot;DY2oxeUuSNaxva5dgKTSAg&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>结构化和非结构化转化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、在当前的head页面中点击【复合查询】</span><br><span class="line">2、调用ES的API构建一个请求url</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我这里给book索引添加一个author类型,使用_mappings关键字(ES给索引、类型、文档等起名字时不能以下划线开头,因为ES中很多关键字都是以下划线开头的)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB0c166f9aba64029505e80c6bf21063d5?method=download&shareKey=4afba56edf5792ceb65836c108d060d1"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB0c166f9aba64029505e80c6bf21063d5?method=download&shareKey=4afba56edf5792ceb65836c108d060d1" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3、给上面的非结构化索引添加一些结构化的数据,让他变成结构化索引</span><br><span class="line"></span><br><span class="line">点击易读,点击验证json,防止自己写的json数据有问题,点击提交请求</span><br><span class="line"></span><br><span class="line">properties: 关键字,设置属性</span><br><span class="line">type: 关键字,设置属性类型</span><br><span class="line">&#123;</span><br><span class="line">    &quot;author&quot;: &#123;</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">            &quot;author_name&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;text&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4、添加成功标志</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;acknowledged&quot;: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5、在进入概览点击索引信息查看数据(mappings中就有了机构化数据)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;state&quot;: &quot;open&quot;,</span><br><span class="line">    &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &#123;</span><br><span class="line">            &quot;creation_date&quot;: &quot;1597547149325&quot;,</span><br><span class="line">            &quot;number_of_shards&quot;: &quot;5&quot;,</span><br><span class="line">            &quot;number_of_replicas&quot;: &quot;1&quot;,</span><br><span class="line">            &quot;uuid&quot;: &quot;UvYCPtp0TZeCiPexCT517g&quot;,</span><br><span class="line">            &quot;version&quot;: &#123;</span><br><span class="line">                &quot;created&quot;: &quot;6030299&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;provided_name&quot;: &quot;book&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot;: &#123;</span><br><span class="line">        &quot;author&quot;: &#123;</span><br><span class="line">            &quot;properties&quot;: &#123;</span><br><span class="line">                &quot;author_name&quot;: &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;text&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;aliases&quot;: [],</span><br><span class="line">    &quot;primary_terms&quot;: &#123;</span><br><span class="line">        &quot;0&quot;: 1,</span><br><span class="line">        &quot;1&quot;: 1,</span><br><span class="line">        &quot;2&quot;: 1,</span><br><span class="line">        &quot;3&quot;: 1,</span><br><span class="line">        &quot;4&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;in_sync_allocations&quot;: &#123;</span><br><span class="line">        &quot;0&quot;: [</span><br><span class="line">            &quot;BHBNGrGCSiOl-wuKptvGtQ&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;1&quot;: [</span><br><span class="line">            &quot;yMyL9GsMR9SziVr9OK_Uxw&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;2&quot;: [</span><br><span class="line">            &quot;b8EGEtGlTySAqvlKPtW_EA&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;3&quot;: [</span><br><span class="line">            &quot;0azU6MwTSCqMdzVXyuPVrw&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;4&quot;: [</span><br><span class="line">            &quot;DY2oxeUuSNaxva5dgKTSAg&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-3-使用postman创建索引"><a href="#2-3-使用postman创建索引" class="headerlink" title="2.3 使用postman创建索引"></a>2.3 使用postman创建索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Head在进行结构化数据创建的时候,验证json数据格式比较麻烦,我们可以使用postman进行结构化数据创建</span><br></pre></td></tr></table></figure>

<ul>
<li>使用postman创建索引</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB683927128dabde2d93183a9839113a19?method=download&shareKey=17d48375b6fb130cf6a2a8fae5ad78ae"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB683927128dabde2d93183a9839113a19?method=download&shareKey=17d48375b6fb130cf6a2a8fae5ad78ae" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><p>postman创建索引的请求数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;settings&quot;:&#123;</span><br><span class="line">		&quot;number_of_shards&quot;:5,</span><br><span class="line">		&quot;number_of_replicas&quot;:1</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;mappings&quot;:&#123;</span><br><span class="line">		&quot;man&quot;:&#123;</span><br><span class="line">			&quot;properties&quot;:&#123;</span><br><span class="line">				&quot;name&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;text&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;country&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;age&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;integer&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				&quot;date&quot;:&#123;</span><br><span class="line">					&quot;type&quot;:&quot;date&quot;,</span><br><span class="line">					&quot;format&quot;:&quot;yyyy-MM-dd HH:mm:ss || yyyy-MM-dd || epoch_millis&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------参数变量的简单介绍----------------------------------</span><br><span class="line"></span><br><span class="line">settings     : 设置当前索引的基本信息</span><br><span class="line">mappings     : 结构化索引配置</span><br><span class="line">format       : 时间格式</span><br><span class="line">epoch_millis : 时间戳(毫秒数)</span><br></pre></td></tr></table></figure></li>
<li><p>head页面查看创建结果</p>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEBee0114c334d559485567119c623a2dad?method=download&shareKey=a95876df2e512b7cc8c16e13987ee2f9"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBee0114c334d559485567119c623a2dad?method=download&shareKey=a95876df2e512b7cc8c16e13987ee2f9" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<h3 id="第3节-数据插入-postman"><a href="#第3节-数据插入-postman" class="headerlink" title="第3节 数据插入(postman)"></a>第3节 数据插入(postman)</h3><h4 id="3-1-指定id插入"><a href="#3-1-指定id插入" class="headerlink" title="3.1 指定id插入"></a>3.1 指定id插入</h4><ul>
<li><p>请求地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:9200/people/man/1</span><br></pre></td></tr></table></figure></li>
<li><p>请求图例</p>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEBe4650dca8d5e767b5c38e3aae96fcfb8?method=download&shareKey=24e1c1fb034f90e2864c177bf04adcc9"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBe4650dca8d5e767b5c38e3aae96fcfb8?method=download&shareKey=24e1c1fb034f90e2864c177bf04adcc9" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><p>添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;:&quot;枫桥夜泊1990&quot;,</span><br><span class="line">	&quot;country&quot;:&quot;中国&quot;,</span><br><span class="line">	&quot;age&quot;:30,</span><br><span class="line">	&quot;date&quot;:&quot;1990-05-28&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回结果数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;people&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;man&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;_version&quot;: 1,</span><br><span class="line">    &quot;result&quot;: &quot;created&quot;,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 2,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;_seq_no&quot;: 0,</span><br><span class="line">    &quot;_primary_term&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>head查看</p>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB17d3c1815c1f6335f58e6cc3ab639c95?method=download&shareKey=39b22c3ba6c84b8eca4bc2d1c9a91d9a"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB17d3c1815c1f6335f58e6cc3ab639c95?method=download&shareKey=39b22c3ba6c84b8eca4bc2d1c9a91d9a" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB1345141a8ddfc83fcc6041722d643f50?method=download&shareKey=90d6b0efc383fb4469e018856c88ce14"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB1345141a8ddfc83fcc6041722d643f50?method=download&shareKey=90d6b0efc383fb4469e018856c88ce14" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<h4 id="3-2-自动生成id插入"><a href="#3-2-自动生成id插入" class="headerlink" title="3.2 自动生成id插入"></a>3.2 自动生成id插入</h4><ul>
<li><p>请求地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:9200/people/man/</span><br></pre></td></tr></table></figure></li>
<li><p>请求图例</p>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB4e77001ccee3d6d92fa15f6845633e07?method=download&shareKey=40f9a78a2a99ca8736c0878788a265c9"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB4e77001ccee3d6d92fa15f6845633e07?method=download&shareKey=40f9a78a2a99ca8736c0878788a265c9" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li>head查看</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEBf58551398ea8893d0597e9dfe036af22?method=download&shareKey=9f4fb0be48d86ac1e3e9cd164ecc7c85"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBf58551398ea8893d0597e9dfe036af22?method=download&shareKey=9f4fb0be48d86ac1e3e9cd164ecc7c85" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<h3 id="第4节-数据修改-postman"><a href="#第4节-数据修改-postman" class="headerlink" title="第4节 数据修改(postman)"></a>第4节 数据修改(postman)</h3><h4 id="4-1-直接修改文档"><a href="#4-1-直接修改文档" class="headerlink" title="4.1 直接修改文档"></a>4.1 直接修改文档</h4><ul>
<li><p>请求地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:9200/people/man/1/_update</span><br></pre></td></tr></table></figure></li>
<li><p>请求参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;doc&quot;:&#123;</span><br><span class="line">		&quot;name&quot;:&quot;我是枫桥夜泊1990&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>请求图例</p>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEBd3858fb3757aa53933f2685438ac164a?method=download&shareKey=23f43294ac1bf8f1586e7477a4d8f0e8"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBd3858fb3757aa53933f2685438ac164a?method=download&shareKey=23f43294ac1bf8f1586e7477a4d8f0e8" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><p>响应数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;people&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;man&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;_version&quot;: 2,</span><br><span class="line">    &quot;result&quot;: &quot;updated&quot;,</span><br><span class="line">    &quot;_shards&quot;: &#123;</span><br><span class="line">        &quot;total&quot;: 2,</span><br><span class="line">        &quot;successful&quot;: 1,</span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;_seq_no&quot;: 2,</span><br><span class="line">    &quot;_primary_term&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>head查看</p>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEBe1473018a3c715b72bac6929720e407c?method=download&shareKey=5fcfca82d7e93c7e32359dc4b5c62c5f"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBe1473018a3c715b72bac6929720e407c?method=download&shareKey=5fcfca82d7e93c7e32359dc4b5c62c5f" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<h4 id="4-2-使用脚本修改文档-了解"><a href="#4-2-使用脚本修改文档-了解" class="headerlink" title="4.2 使用脚本修改文档(了解)"></a>4.2 使用脚本修改文档(了解)</h4><h5 id="4-2-1-Painless简介"><a href="#4-2-1-Painless简介" class="headerlink" title="4.2.1 Painless简介"></a>4.2.1 Painless简介</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Painless 是默认情况下 Elasticsearch 中提供的一种简单，安全的脚本语言</span><br><span class="line">2. 它专门设计用于 Elasticsearch，可以安全地使用内联和存储的脚本，默认情况下启用</span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-Painless使用"><a href="#4-2-2-Painless使用" class="headerlink" title="4.2.2 Painless使用"></a>4.2.2 Painless使用</h5><ul>
<li><p>请求地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:9200/people/man/1/_update</span><br></pre></td></tr></table></figure></li>
<li><p>请求参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	&quot;script&quot;:&#123;</span><br><span class="line">		&quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">		&quot;inline&quot;:&quot;ctx._source.age -=10&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式二:</span><br><span class="line">&#123;</span><br><span class="line">	&quot;script&quot;:&#123;</span><br><span class="line">		&quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">		&quot;inline&quot;:&quot;ctx._source.age = params.age&quot;,</span><br><span class="line">		&quot;params&quot;:&#123;</span><br><span class="line">			&quot;age&quot;:21</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>请求图例</p>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB34be6087739e611fe06d33aa45484568?method=download&shareKey=113ef04dd3a060c0cdd12c2c8c6d392a"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB34be6087739e611fe06d33aa45484568?method=download&shareKey=113ef04dd3a060c0cdd12c2c8c6d392a" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<h3 id="第5节-数据删除-postman"><a href="#第5节-数据删除-postman" class="headerlink" title="第5节 数据删除(postman)"></a>第5节 数据删除(postman)</h3><h4 id="5-1-删除文档-postman"><a href="#5-1-删除文档-postman" class="headerlink" title="5.1 删除文档(postman)"></a>5.1 删除文档(postman)</h4><ul>
<li><p>请求地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:9200/people/man/1</span><br></pre></td></tr></table></figure></li>
<li><p>请求图例</p>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB378449d8c1de24c0c4ed7e03f35520d0?method=download&shareKey=ff369fc87bb84391a867d031086cf521"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB378449d8c1de24c0c4ed7e03f35520d0?method=download&shareKey=ff369fc87bb84391a867d031086cf521" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<h4 id="5-2-删除索引-postman"><a href="#5-2-删除索引-postman" class="headerlink" title="5.2 删除索引(postman)"></a>5.2 删除索引(postman)</h4><ul>
<li><p>请求地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:9200/people</span><br></pre></td></tr></table></figure></li>
<li><p>请求图例</p>
</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEBe87de8b6f23249a84ec971e861a5c4a3?method=download&shareKey=51954b8d182827a566cf1d38bb8b03ed"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBe87de8b6f23249a84ec971e861a5c4a3?method=download&shareKey=51954b8d182827a566cf1d38bb8b03ed" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<h4 id="5-3-使用head删除索引"><a href="#5-3-使用head删除索引" class="headerlink" title="5.3 使用head删除索引"></a>5.3 使用head删除索引</h4><ul>
<li>图例演示</li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB29862abfb69a19f22949cd6b50687455?method=download&shareKey=aa61c766d5350a9efc8fbd1220c2b07c"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB29862abfb69a19f22949cd6b50687455?method=download&shareKey=aa61c766d5350a9efc8fbd1220c2b07c" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<h2 id="第五章-高级查询-Kibana"><a href="#第五章-高级查询-Kibana" class="headerlink" title="第五章 高级查询(Kibana)"></a>第五章 高级查询(Kibana)</h2><h3 id="第1节-Kibana安装"><a href="#第1节-Kibana安装" class="headerlink" title="第1节 Kibana安装"></a>第1节 Kibana安装</h3><h4 id="1-1-Kibana简介"><a href="#1-1-Kibana简介" class="headerlink" title="1.1 Kibana简介"></a>1.1 Kibana简介</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kibana是一个针对Elasticsearch的开源分析及可视化平台,用来搜索、查看交互存储在Elasticsearch索引中的数据.使用Kibana,可以通过各种图表进行高级数据分析及展示</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-Kibana下载"><a href="#1-2-Kibana下载" class="headerlink" title="1.2 Kibana下载"></a>1.2 Kibana下载</h4><ul>
<li><p>官网地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.elastic.co/cn/kibana</span><br></pre></td></tr></table></figure></li>
<li><p>华为云地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://mirrors.huaweicloud.com/kibana/6.3.2/kibana-6.3.2-windows-x86_64.zip</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="1-3-Kibana安装"><a href="#1-3-Kibana安装" class="headerlink" title="1.3 Kibana安装"></a>1.3 Kibana安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、将下载的kibana-6.3.2-windows-x86_64.zip压缩包解压到指定文件夹下</span><br><span class="line">2、在bin目录下D:\soft\kibana-6.3.2-windows-x86_64\bin找到kibana.bat</span><br><span class="line">3、双击运行即可</span><br><span class="line">4、浏览器访问 http://localhost:5601/进入 Dev Tools选项</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第2节-Kibana使用"><a href="#第2节-Kibana使用" class="headerlink" title="第2节 Kibana使用"></a>第2节 Kibana使用</h3><h4 id="2-1-基本操作"><a href="#2-1-基本操作" class="headerlink" title="2.1 基本操作"></a>2.1 基本操作</h4><h5 id="2-1-1-查看集群健康状态"><a href="#2-1-1-查看集群健康状态" class="headerlink" title="2.1.1 查看集群健康状态"></a>2.1.1 查看集群健康状态</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_cat/health?v</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1-2-查看节点状态"><a href="#2-1-2-查看节点状态" class="headerlink" title="2.1.2 查看节点状态"></a>2.1.2 查看节点状态</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_cat/nodes?v</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1-3-查看索引信息"><a href="#2-1-3-查看索引信息" class="headerlink" title="2.1.3 查看索引信息"></a>2.1.3 查看索引信息</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /_cat/indices?v</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1-4-创建索引"><a href="#2-1-4-创建索引" class="headerlink" title="2.1.4 创建索引"></a>2.1.4 创建索引</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 命令 PUT /book</span><br><span class="line"></span><br><span class="line">2. 返回结果</span><br><span class="line">&#123;</span><br><span class="line">  &quot;acknowledged&quot;: true,</span><br><span class="line">  &quot;shards_acknowledged&quot;: true,</span><br><span class="line">  &quot;index&quot;: &quot;book&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1-5-删除索引"><a href="#2-1-5-删除索引" class="headerlink" title="2.1.5 删除索引"></a>2.1.5 删除索引</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 命令  DELETE /book</span><br><span class="line">2. 返回结果</span><br><span class="line">&#123;</span><br><span class="line">  &quot;acknowledged&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1-6-向文档中添加数据"><a href="#2-1-6-向文档中添加数据" class="headerlink" title="2.1.6 向文档中添加数据"></a>2.1.6 向文档中添加数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT /book/doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;李雷&quot;,</span><br><span class="line">  &quot;age&quot;:18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1-7-查看文档类型"><a href="#2-1-7-查看文档类型" class="headerlink" title="2.1.7 查看文档类型"></a>2.1.7 查看文档类型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /book/doc/_mapping</span><br><span class="line"></span><br><span class="line">GET: 请求方式</span><br><span class="line">book: 索引(相当于MYSQL数据库的库名)</span><br><span class="line">doc : 类型(相当于数据库的表名)</span><br><span class="line">_mapping: ES的关键字查询文档类型</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1-8-查看索引中的文档-根据ID查询"><a href="#2-1-8-查看索引中的文档-根据ID查询" class="headerlink" title="2.1.8 查看索引中的文档(根据ID查询)"></a>2.1.8 查看索引中的文档(根据ID查询)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /book/doc/1</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1-9-更新索引中的文档"><a href="#2-1-9-更新索引中的文档" class="headerlink" title="2.1.9 更新索引中的文档"></a>2.1.9 更新索引中的文档</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /book/doc/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;:&#123;</span><br><span class="line">    &quot;name&quot;:&quot;韩梅梅&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST   : 请求方式</span><br><span class="line">book   : 索引名称</span><br><span class="line">doc    : 类型</span><br><span class="line">1      : 文档id</span><br><span class="line">_update: 关键字,用于更新</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1-10-删除索引中的文档"><a href="#2-1-10-删除索引中的文档" class="headerlink" title="2.1.10 删除索引中的文档"></a>2.1.10 删除索引中的文档</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE /book/doc/2</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-1-11-对索引中的文档进行批量操作"><a href="#2-1-11-对索引中的文档进行批量操作" class="headerlink" title="2.1.11 对索引中的文档进行批量操作"></a>2.1.11 对索引中的文档进行批量操作</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /book/doc/_bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;3&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;John Doe&quot; &#125;</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_id&quot;:&quot;4&quot;&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;: &quot;Jane Doe&quot; &#125;</span><br><span class="line"></span><br><span class="line">_bulk: 批量操作</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-高级查询"><a href="#2-2-高级查询" class="headerlink" title="2.2 高级查询"></a>2.2 高级查询</h4><h5 id="2-2-1-数据导入"><a href="#2-2-1-数据导入" class="headerlink" title="2.2.1 数据导入"></a>2.2.1 数据导入</h5><ul>
<li><p>数据地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/macrozheng/mall-learning/blob/master/document/json/accounts.json</span><br></pre></td></tr></table></figure></li>
<li><p>导入命令(批量)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /bank/account/_bulk</span><br><span class="line">//这里放上面的数据地址中的数据</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h5 id="2-2-2-高级查询"><a href="#2-2-2-高级查询" class="headerlink" title="2.2.2 高级查询"></a>2.2.2 高级查询</h5><hr>
<h6 id="2-2-2-1-简单搜索"><a href="#2-2-2-1-简单搜索" class="headerlink" title="2.2.2.1 简单搜索"></a>2.2.2.1 简单搜索</h6><ul>
<li><p>搜索全部(match_all)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分页搜索(from表示偏移量,从0开始,size表示每页显示的数量)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;from&quot;: 0,</span><br><span class="line">  &quot;size&quot;: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>搜索排序(sort)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;sort&quot;: &#123; &quot;balance&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用sort关键字 以balance字段排序,设置order属性的值为desc倒叙输出</span><br></pre></td></tr></table></figure></li>
<li><p>搜索并返回指定字段内容(_source)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">  &quot;_source&quot;: [&quot;account_number&quot;, &quot;balance&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_source: 将要查询出来的属性设置到_source数组中</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="2-2-2-2-条件搜索-match"><a href="#2-2-2-2-条件搜索-match" class="headerlink" title="2.2.2.2 条件搜索(match)"></a>2.2.2.2 条件搜索(match)</h6><ul>
<li><p>搜索出account_number为20的文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;account_number&quot;: 20</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>搜索address字段中包含mill的文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;address&quot;: &quot;mill&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_source&quot;: [</span><br><span class="line">    &quot;address&quot;,</span><br><span class="line">    &quot;account_number&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 对于数值类型match操作使用的是精确匹配，对于文本类型使用的是模糊匹配</p>
</blockquote>
</li>
</ul>
<hr>
<h6 id="2-2-2-3-短语匹配搜索-match-phrase"><a href="#2-2-2-3-短语匹配搜索-match-phrase" class="headerlink" title="2.2.2.3 短语匹配搜索(match_phrase)"></a>2.2.2.3 短语匹配搜索(match_phrase)</h6><ul>
<li><p>搜索address字段中同时包含mill和lane的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;address&quot;: &quot;mill lane&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="2-2-2-4-组合搜索-bool"><a href="#2-2-2-4-组合搜索-bool" class="headerlink" title="2.2.2.4 组合搜索(bool)"></a>2.2.2.4 组合搜索(bool)</h6><ul>
<li><p>同时满足(must)</p>
</li>
<li><ul>
<li><p>搜索address字段中同时包含mill和lane的文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;lane&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>满足其中任意一个(should)</p>
</li>
<li><ul>
<li><p>搜索address字段中包含mill或者lane的文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;lane&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>同时不满足(must_not)</p>
</li>
<li><ul>
<li><p>搜索address字段中不包含mill且不包含lane的文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;mill&quot; &#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;address&quot;: &quot;lane&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>满足其中一部分,并且不包含另一部分(组合must和must_not)</p>
</li>
<li><ul>
<li><p>搜索age字段等于40且state字段不包含ID的文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;age&quot;: &quot;40&quot; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;state&quot;: &quot;ID&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h6 id="2-2-2-5-过滤搜索-filter"><a href="#2-2-2-5-过滤搜索-filter" class="headerlink" title="2.2.2.5 过滤搜索(filter)"></a>2.2.2.5 过滤搜索(filter)</h6><ul>
<li><p>过滤出balance字段在20000~30000的文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;balance&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: 20000,</span><br><span class="line">            &quot;lte&quot;: 30000</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="2-2-2-6-搜索聚合-aggs"><a href="#2-2-2-6-搜索聚合-aggs" class="headerlink" title="2.2.2.6 搜索聚合(aggs)"></a>2.2.2.6 搜索聚合(aggs)</h6><ul>
<li><p>对state字段进行聚合,统计出相同state的文档数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;:&#123;</span><br><span class="line">    &quot;group_by_state&quot;:&#123;</span><br><span class="line">      &quot;terms&quot;:&#123;</span><br><span class="line">        &quot;field&quot;:&quot;state.keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aggs: 分组聚合关键字</span><br><span class="line">group_by_state: 聚合条件名字,自定义</span><br><span class="line">terms : 关键字,查询某个字段里含有多个关键词的文档</span><br><span class="line">keyword: state是一个关键字类型</span><br></pre></td></tr></table></figure></li>
<li><p>对balance取平均值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0, </span><br><span class="line">  &quot;aggs&quot;:&#123;</span><br><span class="line">    &quot;avg_balance&quot;:&#123;</span><br><span class="line">      &quot;avg&quot;:&#123;</span><br><span class="line">        &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对state字段进行聚合,统计出相同state的文档数量和balance平均值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /bank/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0, </span><br><span class="line">  &quot;aggs&quot;:&#123;</span><br><span class="line">    &quot;group_by_state&quot;:&#123;</span><br><span class="line">      &quot;terms&quot;:&#123;</span><br><span class="line">        &quot;field&quot;:&quot;state.keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;avg_balance&quot;:&#123;</span><br><span class="line">      &quot;avg&quot;:&#123;</span><br><span class="line">        &quot;field&quot;: &quot;balance&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>具体ES的聚合函数请参考官方文档这里不再讲解</p>
</blockquote>
<hr>
<h2 id="第六章-ES和SpringBoot整合-Spring-data版本使用"><a href="#第六章-ES和SpringBoot整合-Spring-data版本使用" class="headerlink" title="第六章 ES和SpringBoot整合(Spring-data版本使用)"></a>第六章 ES和SpringBoot整合(Spring-data版本使用)</h2><h3 id="第1节-分词器介绍"><a href="#第1节-分词器介绍" class="headerlink" title="第1节 分词器介绍"></a>第1节 分词器介绍</h3><h4 id="1-1-分词器的作用"><a href="#1-1-分词器的作用" class="headerlink" title="1.1 分词器的作用"></a>1.1 分词器的作用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将原始内容进行拆分,将一段话拆分成单词或者一个一个的字,或者语义单元</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="1-2-常见分词器"><a href="#1-2-常见分词器" class="headerlink" title="1.2 常见分词器"></a>1.2 常见分词器</h4><ul>
<li><p>standars</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ES默认分词器,将词汇单元转成小写,取出一些停用词和标点符号,支持中文,将中文拆分成单个的字</span><br></pre></td></tr></table></figure></li>
<li><p>IK分词器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个可以很好的支持中文,并且可以自定义的开源分词器</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第2节-standars分词器演示-kibana工具"><a href="#第2节-standars分词器演示-kibana工具" class="headerlink" title="第2节 standars分词器演示(kibana工具)"></a>第2节 standars分词器演示(kibana工具)</h3><h4 id="2-1-演示英文"><a href="#2-1-演示英文" class="headerlink" title="2.1 演示英文"></a>2.1 演示英文</h4><ul>
<li><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;Hello Java&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将Hello Java分成了两个词分别是hello和java,首字母都变成了小写</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;hello&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 0,</span><br><span class="line">      &quot;end_offset&quot;: 5,</span><br><span class="line">      &quot;type&quot;: &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;java&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 6,</span><br><span class="line">      &quot;end_offset&quot;: 10,</span><br><span class="line">      &quot;type&quot;: &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot;: 1</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-演示中文"><a href="#2-2-演示中文" class="headerlink" title="2.2 演示中文"></a>2.2 演示中文</h4></li>
<li><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;standard&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;我是中国人&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;我&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 0,</span><br><span class="line">      &quot;end_offset&quot;: 1,</span><br><span class="line">      &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;是&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 1,</span><br><span class="line">      &quot;end_offset&quot;: 2,</span><br><span class="line">      &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;中&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 2,</span><br><span class="line">      &quot;end_offset&quot;: 3,</span><br><span class="line">      &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;国&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 3,</span><br><span class="line">      &quot;end_offset&quot;: 4,</span><br><span class="line">      &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot;: 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;人&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 4,</span><br><span class="line">      &quot;end_offset&quot;: 5,</span><br><span class="line">      &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot;: 4</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第3节-ik分词器安装和使用"><a href="#第3节-ik分词器安装和使用" class="headerlink" title="第3节 ik分词器安装和使用"></a>第3节 ik分词器安装和使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">medcl/elasticsearch-analysis-ik分词器是当前对中文支持最好的分词器</span><br></pre></td></tr></table></figure>

<ul>
<li><p>IK分词器地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/medcl/elasticsearch-analysis-ik/archive/v6.3.2.zip</span><br><span class="line"></span><br><span class="line">下载的分词器一定要和当前安装的ES版本相同</span><br></pre></td></tr></table></figure></li>
<li><p>安装步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将下载的分词器压缩包复制到我们的es的安装目录D:\soft\elasticsearch-6.3.2\plugins插件目录下</span><br><span class="line">3. 将elasticsearch-analysis-ik解压</span><br><span class="line">4. 重启ES服务</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第4节-ik分词器演示-kibana工具"><a href="#第4节-ik分词器演示-kibana工具" class="headerlink" title="第4节 ik分词器演示(kibana工具)"></a>第4节 ik分词器演示(kibana工具)</h3><ul>
<li><p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_smart&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;我是中国人&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;:&quot;我是中国人&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>返回效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ik_smart分词器效果</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;我&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 0,</span><br><span class="line">      &quot;end_offset&quot;: 1,</span><br><span class="line">      &quot;type&quot;: &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;是&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 1,</span><br><span class="line">      &quot;end_offset&quot;: 2,</span><br><span class="line">      &quot;type&quot;: &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;中国人&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 2,</span><br><span class="line">      &quot;end_offset&quot;: 5,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line"></span><br><span class="line">ik_max_word分词器效果</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;我&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 0,</span><br><span class="line">      &quot;end_offset&quot;: 1,</span><br><span class="line">      &quot;type&quot;: &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;是&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 1,</span><br><span class="line">      &quot;end_offset&quot;: 2,</span><br><span class="line">      &quot;type&quot;: &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;中国人&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 2,</span><br><span class="line">      &quot;end_offset&quot;: 5,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;中国&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 2,</span><br><span class="line">      &quot;end_offset&quot;: 4,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot;: &quot;国人&quot;,</span><br><span class="line">      &quot;start_offset&quot;: 3,</span><br><span class="line">      &quot;end_offset&quot;: 5,</span><br><span class="line">      &quot;type&quot;: &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot;: 4</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第5节-ES和SpringBoot整合"><a href="#第5节-ES和SpringBoot整合" class="headerlink" title="第5节 ES和SpringBoot整合"></a>第5节 ES和SpringBoot整合</h3><h4 id="5-1-创建SpringBoot项目"><a href="#5-1-创建SpringBoot项目" class="headerlink" title="5.1 创建SpringBoot项目"></a>5.1 创建SpringBoot项目</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加依赖,依赖在springboot-data中</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://note.youdao.com/yws/api/personal/file/WEBf368ecdd8daad54090d49c410f198080?method=download&shareKey=b8d107a550419db9195541167c95628d"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEBf368ecdd8daad54090d49c410f198080?method=download&shareKey=b8d107a550419db9195541167c95628d" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<h4 id="5-2-配置"><a href="#5-2-配置" class="headerlink" title="5.2 配置"></a>5.2 配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置ES的节点地址</span><br><span class="line"># spring.data.elasticsearch.cluster-nodes=127.0.0.1:9300,127.0.0.1:9301,127.0.0.1:9302</span><br><span class="line">spring.data.elasticsearch.cluster-nodes=127.0.0.1:9300</span><br><span class="line"># es集群名称</span><br><span class="line">spring.data.elasticsearch.cluster-name=elasticsearch</span><br></pre></td></tr></table></figure>

<h4 id="5-3-常见的操作"><a href="#5-3-常见的操作" class="headerlink" title="5.3 常见的操作"></a>5.3 常见的操作</h4><h5 id="5-3-1-映射ES文档的实体类"><a href="#5-3-1-映射ES文档的实体类" class="headerlink" title="5.3.1 映射ES文档的实体类"></a>5.3.1 映射ES文档的实体类</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author 枫桥夜泊1990</span><br><span class="line"> * @BLOG https://hd1611756908.github.io/</span><br><span class="line"> * @BSITE https://space.bilibili.com/514155929/</span><br><span class="line"> * @DATE 2020/8/17</span><br><span class="line"> * Document: 设置文档</span><br><span class="line"> * indexName：设置索引</span><br><span class="line"> * type： 设置类型</span><br><span class="line"> * shards: 设置分片</span><br><span class="line"> * replicas: 设置副本</span><br><span class="line"> */</span><br><span class="line">@Document(indexName = &quot;bank&quot;,type = &quot;account&quot;,shards = 5,replicas = 1)</span><br><span class="line">public class EsAccount &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    private Long id;</span><br><span class="line">    @Field(type = FieldType.Long)</span><br><span class="line">    private Long account_number;</span><br><span class="line">    @Field(type = FieldType.Text) //是有IK分词器(一定要安装IK分词器)</span><br><span class="line">    private String firstname;</span><br><span class="line">    @Field(type = FieldType.Text)</span><br><span class="line">    private String address;</span><br><span class="line">    @Field(type = FieldType.Text)</span><br><span class="line">    private String gender;</span><br><span class="line">    @Field(type = FieldType.Text)</span><br><span class="line">    private String city;</span><br><span class="line">    @Field(type = FieldType.Long)</span><br><span class="line">    private Long balance;</span><br><span class="line">    @Field(type = FieldType.Text)</span><br><span class="line">    private String lastname;</span><br><span class="line">    @Field(type = FieldType.Text)</span><br><span class="line">    private String employer;</span><br><span class="line">    @Field(type = FieldType.Text)</span><br><span class="line">    private String state;</span><br><span class="line">    @Field(type = FieldType.Long)</span><br><span class="line">    private Long age;</span><br><span class="line">    @Field(type = FieldType.Text)</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-2-操作ES的接口"><a href="#5-3-2-操作ES的接口" class="headerlink" title="5.3.2 操作ES的接口"></a>5.3.2 操作ES的接口</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface EsAccountRepository extends ElasticsearchRepository&lt;EsAccount,Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据名称查询</span><br><span class="line">     * 方法名字不能随便乱起</span><br><span class="line">     */</span><br><span class="line">    List&lt;EsAccount&gt; findByLastname(String lastname);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据地址查询</span><br><span class="line">     * 方法名字不能随便乱起</span><br><span class="line">     */</span><br><span class="line">    List&lt;EsAccount&gt; findByAddress(String address);</span><br><span class="line">    /**</span><br><span class="line">     * 根据名称删除</span><br><span class="line">     * 方法名字不能随便乱起</span><br><span class="line">     */</span><br><span class="line">    void deleteByFirstname(String firstname);</span><br><span class="line">    /**</span><br><span class="line">     * 根据地址查询,并且分页</span><br><span class="line">     * 方法名字不能随便乱起</span><br><span class="line">     */</span><br><span class="line">    Page&lt;EsAccount&gt; findByAddress(String address, Pageable pageable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-3-单元测试操作"><a href="#5-3-3-单元测试操作" class="headerlink" title="5.3.3 单元测试操作"></a>5.3.3 单元测试操作</h5><ul>
<li><p>常见操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Author 枫桥夜泊1990</span><br><span class="line"> * @BLOG https://hd1611756908.github.io/</span><br><span class="line"> * @BSITE https://space.bilibili.com/514155929/</span><br><span class="line"> * @DATE 2020/8/17</span><br><span class="line"> */</span><br><span class="line">public class EsAccountRepositoryTest extends SpringbootEs01ApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private EsAccountRepository esAccountRepository;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 测试findAll</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void findAll1()&#123;</span><br><span class="line">        Iterable&lt;EsAccount&gt; esAccounts = esAccountRepository.findAll();</span><br><span class="line">        //esAccounts.forEach(System.out::println);</span><br><span class="line">        //esAccounts.forEach((x)-&gt;&#123;System.out.println(x);&#125;);</span><br><span class="line">        Iterator&lt;EsAccount&gt; iterator = esAccounts.iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 测试添加一条数据</span><br><span class="line">     * 更新数据,更新和添加主要判断是否有id</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void saveAccount()&#123;</span><br><span class="line">        EsAccount account = new EsAccount();</span><br><span class="line">        account.setAccount_number(4570L);</span><br><span class="line">        account.setAddress(&quot;北京&quot;);</span><br><span class="line">        account.setAge(18L);</span><br><span class="line">        account.setBalance(1000000L);</span><br><span class="line">        account.setCity(&quot;中国&quot;);</span><br><span class="line">        account.setEmail(&quot;123@.com&quot;);</span><br><span class="line">        account.setEmployer(&quot;李雷&quot;);</span><br><span class="line">        account.setFirstname(&quot;李&quot;);</span><br><span class="line">        account.setGender(&quot;男&quot;);</span><br><span class="line">        account.setId(4570L);</span><br><span class="line">        account.setLastname(&quot;李雷&quot;);</span><br><span class="line">        account.setState(&quot;NL&quot;);</span><br><span class="line">        esAccountRepository.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据ID查询account</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void findAccountById()&#123;</span><br><span class="line">        Optional&lt;EsAccount&gt; esAccount = esAccountRepository.findById(4570L);</span><br><span class="line">        System.out.println(esAccount.get());</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 根据ID删除</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void deleteAccount()&#123;</span><br><span class="line">        esAccountRepository.deleteById(4570L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 更新</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void updateAccount()&#123;</span><br><span class="line"></span><br><span class="line">        Optional&lt;EsAccount&gt; esAccount = esAccountRepository.findById(456L);</span><br><span class="line">        EsAccount account = esAccount.get();</span><br><span class="line">        account.setLastname(&quot;李雷super&quot;);</span><br><span class="line">        esAccountRepository.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据Lastname查询（模糊查询）</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void findByLastname()&#123;</span><br><span class="line">        List&lt;EsAccount&gt; accountList = esAccountRepository.findByLastname(&quot;李雷&quot;);</span><br><span class="line">        System.out.println(accountList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据地址查询（模糊查询）</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void findByAddress()&#123;</span><br><span class="line">        List&lt;EsAccount&gt; accounts = esAccountRepository.findByAddress(&quot;京&quot;);</span><br><span class="line">        System.out.println(accounts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 分页查询</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void findPage()&#123;</span><br><span class="line">        Pageable p = PageRequest.of(0, 5);</span><br><span class="line">        Page&lt;EsAccount&gt; accounts = esAccountRepository.findAll(p);</span><br><span class="line">        for (EsAccount account : accounts) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 排序分页查询</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void findPageMult()&#123;</span><br><span class="line">        Sort sort = Sort.by(Sort.Direction.DESC, &quot;account_number&quot;);</span><br><span class="line">        Pageable p = PageRequest.of(0, 5, sort);</span><br><span class="line">        Page&lt;EsAccount&gt; accounts = esAccountRepository.findByAddress(&quot;Place&quot;, p);</span><br><span class="line">        for (EsAccount account : accounts) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 复杂查询,采用search方法</span><br><span class="line">     * 构建条件查询 使用match语法</span><br><span class="line">     * 过滤查询</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testMatch01()&#123;</span><br><span class="line">        //单个条件</span><br><span class="line">        // QueryBuilder query = QueryBuilders.matchQuery(&quot;account_number&quot;, 20);</span><br><span class="line">        //多个条件</span><br><span class="line">        NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">        NativeSearchQueryBuilder queryBuilder = builder</span><br><span class="line">                            .withQuery(QueryBuilders.matchQuery(&quot;account_number&quot;, 20))</span><br><span class="line">                            .withQuery(QueryBuilders.matchQuery(&quot;firstname&quot;,&quot;Elinor&quot;));</span><br><span class="line">        NativeSearchQuery build = queryBuilder.build();</span><br><span class="line">        Iterable&lt;EsAccount&gt; accounts = esAccountRepository.search(build);</span><br><span class="line">        for (EsAccount account : accounts) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 复杂查询,采用search方法</span><br><span class="line">     * 构建条件查询 使用match语法</span><br><span class="line">     * 短语匹配搜索</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testMatchPhrase()&#123;</span><br><span class="line"></span><br><span class="line">        NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">        NativeSearchQueryBuilder queryBuilder = builder.withQuery(QueryBuilders.matchPhraseQuery(&quot;address&quot;, &quot;mill lane&quot;));</span><br><span class="line">        NativeSearchQuery searchQuery = queryBuilder.build();</span><br><span class="line">        Page&lt;EsAccount&gt; accountPage = esAccountRepository.search(searchQuery);</span><br><span class="line">        //accountPage.forEach(System.out::println);</span><br><span class="line">        //accountPage.forEach((x)-&gt;&#123;System.out.println(x);&#125;);</span><br><span class="line">        //获取迭代器</span><br><span class="line">        Iterator&lt;EsAccount&gt; iterator = accountPage.iterator();</span><br><span class="line">        while(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 组合搜索(bool)</span><br><span class="line">     * 同时满足(must)</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testMust()&#123;</span><br><span class="line"></span><br><span class="line">        NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">        builder.withQuery(QueryBuilders.boolQuery().must(QueryBuilders.matchQuery(&quot;address&quot;,&quot;mill&quot;)).must(QueryBuilders.matchQuery(&quot;address&quot;,&quot;lane&quot;)));</span><br><span class="line">        NativeSearchQuery query = builder.build();</span><br><span class="line">        Page&lt;EsAccount&gt; accounts = esAccountRepository.search(query);</span><br><span class="line">        for (EsAccount account : accounts) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 满足其中任意一个(should)</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testShould()&#123;</span><br><span class="line"></span><br><span class="line">        NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">        builder.withQuery(QueryBuilders.boolQuery().should(QueryBuilders.matchQuery(&quot;address&quot;,&quot;lane&quot;)).should(QueryBuilders.matchQuery(&quot;address&quot;,&quot;mill&quot;)));</span><br><span class="line">        NativeSearchQuery searchQuery = builder.build();</span><br><span class="line">        Page&lt;EsAccount&gt; accounts = esAccountRepository.search(searchQuery);</span><br><span class="line">        for (EsAccount account : accounts) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 同时不满足 must_not</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testMustNot()&#123;</span><br><span class="line"></span><br><span class="line">        NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">        builder.withQuery(QueryBuilders.boolQuery().mustNot(QueryBuilders.matchQuery(&quot;address&quot;,&quot;mill&quot;)).mustNot(QueryBuilders.matchQuery(&quot;address&quot;,&quot;lane&quot;)));</span><br><span class="line">        NativeSearchQuery query = builder.build();</span><br><span class="line">        Page&lt;EsAccount&gt; search = esAccountRepository.search(query);</span><br><span class="line">        for (EsAccount esAccount : search) &#123;</span><br><span class="line">            System.out.println(esAccount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 满足其中一部分,并且不包含另一部分(组合must和must_not)</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testMustAndNotMust()&#123;</span><br><span class="line"></span><br><span class="line">        NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">        builder.withQuery(QueryBuilders.boolQuery().mustNot(QueryBuilders.matchQuery(&quot;state&quot;,&quot;ID&quot;)).must(QueryBuilders.matchQuery(&quot;age&quot;,&quot;40&quot;)));</span><br><span class="line">        NativeSearchQuery query = builder.build();</span><br><span class="line">        Page&lt;EsAccount&gt; accounts = esAccountRepository.search(query);</span><br><span class="line">        for (EsAccount account : accounts) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 过滤搜索 filter</span><br><span class="line">     * 过滤出balance字段在20000~30000的文档</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testFilter()&#123;</span><br><span class="line">        NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">        builder.withFilter(QueryBuilders.boolQuery().filter(QueryBuilders.rangeQuery(&quot;balance&quot;).gte(20000).lte(30000)));</span><br><span class="line">        NativeSearchQuery query = builder.build();</span><br><span class="line">        Page&lt;EsAccount&gt; accounts = esAccountRepository.search(query);</span><br><span class="line">        for (EsAccount account : accounts) &#123;</span><br><span class="line">            System.out.println(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>分组聚合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Elasticsearch有一个功能叫做聚合(aggregations),它允许你在数据上生成复杂的分析统计。它很像SQL中的 GROUP BY 但是功能更强大.</span><br><span class="line"></span><br><span class="line">Elasticsearch的聚合中声明了两个概念如下:</span><br><span class="line">   -- Buckets(桶)：满足某个条件的文档集合。</span><br><span class="line">   -- Metrics(指标)：为某个桶中的文档计算得到的统计信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们可以把类似于数据库中的COUNT(*) 看成一个指标</span><br><span class="line">将 GROUP BY 看成一个桶</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private ElasticsearchTemplate elasticsearchTemplate;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分组聚合  ElasticsearchTemplate</span><br><span class="line"> * 单个分组聚合</span><br><span class="line"> * 对state字段进行聚合，统计出相同state的文档数量</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void group01()&#123;</span><br><span class="line"></span><br><span class="line">    NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">    //统计state字段相同数据出现的次数</span><br><span class="line">    TermsAggregationBuilder field = AggregationBuilders.terms(&quot;group_by_state&quot;).field(&quot;state.keyword&quot;);</span><br><span class="line"></span><br><span class="line">    //查询全部</span><br><span class="line">    builder.withQuery(QueryBuilders.matchAllQuery());</span><br><span class="line">    //添加聚合条件</span><br><span class="line">    builder.addAggregation(field);</span><br><span class="line">    //构建</span><br><span class="line">    NativeSearchQuery query = builder.build();</span><br><span class="line">    //查询,采用ElasticsearchTemplate</span><br><span class="line">    Aggregations aggregations = elasticsearchTemplate.query(query, new ResultsExtractor&lt;Aggregations&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Aggregations extract(SearchResponse response) &#123;</span><br><span class="line">            return response.getAggregations();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //转换成map集合</span><br><span class="line">    Map&lt;String, Aggregation&gt; aggregationMap = aggregations.asMap();</span><br><span class="line">    //获取响应的聚合子类group_by_state</span><br><span class="line">    StringTerms groupByState = (StringTerms) aggregationMap.get(&quot;group_by_state&quot;);</span><br><span class="line">    //获取所有的桶</span><br><span class="line">    List&lt;StringTerms.Bucket&gt; buckets = groupByState.getBuckets();</span><br><span class="line">    Iterator&lt;StringTerms.Bucket&gt; iterator = buckets.iterator();</span><br><span class="line">    while (iterator.hasNext())&#123;</span><br><span class="line">        StringTerms.Bucket bucket = iterator.next();</span><br><span class="line">        System.out.println(bucket.getKeyAsString());</span><br><span class="line">        System.out.println(bucket.getDocCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分组聚合  ElasticsearchTemplate</span><br><span class="line"> * 多个分组聚合</span><br><span class="line"> * 统计出相同state的文档数量，再统计出balance的平均值</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void group02()&#123;</span><br><span class="line"></span><br><span class="line">    NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder();</span><br><span class="line">    //统计state字段相同数据出现的次数</span><br><span class="line">    TermsAggregationBuilder field = AggregationBuilders.terms(&quot;group_by_state&quot;).field(&quot;state.keyword&quot;);</span><br><span class="line">    //统计出balance的平均值</span><br><span class="line">    AvgAggregationBuilder field2 = AggregationBuilders.avg(&quot;avg_balance&quot;).field(&quot;balance&quot;);</span><br><span class="line"></span><br><span class="line">    //查询全部</span><br><span class="line">    builder.withQuery(QueryBuilders.matchAllQuery());</span><br><span class="line">    //添加聚合条件</span><br><span class="line">    builder.addAggregation(field);</span><br><span class="line">    builder.addAggregation(field2);</span><br><span class="line">    //构建</span><br><span class="line">    NativeSearchQuery query = builder.build();</span><br><span class="line">    //查询,采用ElasticsearchTemplate</span><br><span class="line">    Aggregations aggregations = elasticsearchTemplate.query(query, new ResultsExtractor&lt;Aggregations&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Aggregations extract(SearchResponse response) &#123;</span><br><span class="line">            return response.getAggregations();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    //转换成map集合</span><br><span class="line">    Map&lt;String, Aggregation&gt; aggregationMap = aggregations.asMap();</span><br><span class="line">    //获取响应的聚合子类group_by_state</span><br><span class="line">    StringTerms groupByState = (StringTerms) aggregationMap.get(&quot;group_by_state&quot;);</span><br><span class="line">    //获取响应的聚合子类avg_balance</span><br><span class="line">    InternalAvg avgBalance = (InternalAvg) aggregationMap.get(&quot;avg_balance&quot;);</span><br><span class="line">    //获取所有的桶</span><br><span class="line">    List&lt;StringTerms.Bucket&gt; buckets = groupByState.getBuckets();</span><br><span class="line">    Iterator&lt;StringTerms.Bucket&gt; iterator = buckets.iterator();</span><br><span class="line">    while (iterator.hasNext())&#123;</span><br><span class="line">        StringTerms.Bucket bucket = iterator.next();</span><br><span class="line">        System.out.println(bucket.getKeyAsString());</span><br><span class="line">        System.out.println(bucket.getDocCount());</span><br><span class="line">    &#125;</span><br><span class="line">    //获取指标</span><br><span class="line">    double value = avgBalance.getValue();</span><br><span class="line">    System.out.println(&quot;===&quot;+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第七章-ES和MYSQL数据同步"><a href="#第七章-ES和MYSQL数据同步" class="headerlink" title="第七章 ES和MYSQL数据同步"></a>第七章 ES和MYSQL数据同步</h2><h3 id="第1节-logstash简介"><a href="#第1节-logstash简介" class="headerlink" title="第1节 logstash简介"></a>第1节 logstash简介</h3><p>Logstash是一款开源的数据收集引擎，具备实时管道处理能力。简单来说，logstash作为数据源与数据存储分析工具之间的桥梁，结合ElasticSearch以及Kibana，能够极大方便数据的处理与分析。通过200多个插件，logstash可以接受几乎各种各样的数据。包括日志、网络请求、关系型数据库、传感器或物联网等等</p>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB324520b8cc6527b409bc9eae1013cf89?method=download&shareKey=63c09a87e26f0185db22078768d8859b"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB324520b8cc6527b409bc9eae1013cf89?method=download&shareKey=63c09a87e26f0185db22078768d8859b" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<hr>
<h3 id="第2节-logstash下载-6-3-2"><a href="#第2节-logstash下载-6-3-2" class="headerlink" title="第2节 logstash下载(6.3.2)"></a>第2节 logstash下载(6.3.2)</h3><ul>
<li><p>官网地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.elastic.co/cn/downloads/logstash</span><br></pre></td></tr></table></figure></li>
<li><p>华为镜像站</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://mirrors.huaweicloud.com/logstash/</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第3节-logstash配置-简单配置-单表-多表"><a href="#第3节-logstash配置-简单配置-单表-多表" class="headerlink" title="第3节 logstash配置(简单配置-单表/多表)"></a>第3节 logstash配置(简单配置-单表/多表)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logstash工作时，主要设置3个部分的工作属性。</span><br><span class="line">input：设置数据来源</span><br><span class="line">filter：可以对数据进行一定的加工处理过滤，但是不建议做复杂的处理逻辑。这个步骤不是必须的</span><br><span class="line">output：设置输出目标</span><br></pre></td></tr></table></figure>

<ul>
<li><p>安装/配置步骤(使用单个表生成索引)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 将下载的logstash-6.3.2.zip文件解压到指定位置</span><br><span class="line">2. 创建一个配置文件名字自定义,我命名为 mysql.conf,将自定义配置文件放到指定位置(我放到了D:\soft\logstash-6.3.2\config文件夹下)</span><br><span class="line">3. 在mysql.conf中添加配置信息</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">	jdbc&#123;</span><br><span class="line">		# 数据库驱动地址</span><br><span class="line">		jdbc_driver_library =&gt; &quot;D:\\soft\\logstash-6.3.2\\lib\\mysql-connector-java-5.1.47.jar&quot; </span><br><span class="line">		# 数据库驱动类名</span><br><span class="line">		jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">		# 数据库连接地址</span><br><span class="line">		jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/gn_oa&quot;</span><br><span class="line">		# 数据库用户名</span><br><span class="line">		jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">		# 数据库密码</span><br><span class="line">		jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">		# 定时任务</span><br><span class="line">		schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">		# 生成索引的数据来源</span><br><span class="line">		statement =&gt; &quot;SELECT * FROM department&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line">	elasticsearch&#123;</span><br><span class="line">		# 集群地址</span><br><span class="line">		hosts =&gt; [&quot;127.0.0.1:9200&quot;,&quot;127.0.0.1:9201&quot;,&quot;127.0.0.1:9202&quot;]</span><br><span class="line">		# 索引名称</span><br><span class="line">		index =&gt; &quot;department&quot;</span><br><span class="line">		# 生成根据dept_id,生成ES的 _id</span><br><span class="line">		document_id =&gt; &quot;%&#123;dept_id&#125;&quot;</span><br><span class="line">		# 类型</span><br><span class="line">		document_type =&gt; &quot;dept_doc&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. 启动logstash服务,使用我们自定义的配置启动</span><br><span class="line">    -- 使用cmd命令行定位到当前logstash目录的bin目录下使用命令为: logstash -f ../config/mysql.conf 启动服务 </span><br><span class="line">5. 等待索引创建完成(这种方式为全量方式)</span><br></pre></td></tr></table></figure></li>
<li><p>安装/配置步骤(使用多张表生成索引)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">	# 第1张表</span><br><span class="line">	jdbc&#123;</span><br><span class="line">		# 设置当前jdbc的type</span><br><span class="line">		type =&gt; &quot;department&quot;</span><br><span class="line">		# 数据库驱动地址</span><br><span class="line">		jdbc_driver_library =&gt; &quot;D:\\soft\\logstash-6.3.2\\lib\\mysql-connector-java-5.1.47.jar&quot; </span><br><span class="line">		# 数据库驱动类名</span><br><span class="line">		jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">		# 数据库连接地址</span><br><span class="line">		jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/gn_oa&quot;</span><br><span class="line">		# 数据库用户名</span><br><span class="line">		jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">		# 数据库密码</span><br><span class="line">		jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">		# 定时任务</span><br><span class="line">		schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">		# 生成索引的数据来源</span><br><span class="line">		statement =&gt; &quot;SELECT * FROM department&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	# 第2张表</span><br><span class="line">	jdbc&#123;</span><br><span class="line">		# 设置当前jdbc的type</span><br><span class="line">		type =&gt; &quot;student&quot;</span><br><span class="line">		# 数据库驱动地址</span><br><span class="line">		jdbc_driver_library =&gt; &quot;D:\\soft\\logstash-6.3.2\\lib\\mysql-connector-java-5.1.47.jar&quot; </span><br><span class="line">		# 数据库驱动类名</span><br><span class="line">		jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">		# 数据库连接地址</span><br><span class="line">		jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/gn_oa&quot;</span><br><span class="line">		# 数据库用户名</span><br><span class="line">		jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">		# 数据库密码</span><br><span class="line">		jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">		# 定时任务</span><br><span class="line">		schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">		# 生成索引的数据来源</span><br><span class="line">		statement =&gt; &quot;SELECT * FROM student&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line"></span><br><span class="line">	# 根据jdbc中的type值指定输入的jdbc对应的输出为哪一个elasticsearch</span><br><span class="line">	</span><br><span class="line">	if[type]==&quot;department&quot;&#123;</span><br><span class="line"></span><br><span class="line">		elasticsearch&#123;</span><br><span class="line">			# 集群地址</span><br><span class="line">			hosts =&gt; [&quot;127.0.0.1:9200&quot;,&quot;127.0.0.1:9201&quot;,&quot;127.0.0.1:9202&quot;]</span><br><span class="line">			# 索引名称</span><br><span class="line">			index =&gt; &quot;department&quot;</span><br><span class="line">			# 生成根据dept_id,生成ES的 _id</span><br><span class="line">			document_id =&gt; &quot;%&#123;dept_id&#125;&quot;</span><br><span class="line">			# 类型</span><br><span class="line">			document_type =&gt; &quot;dept_doc&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if[type]==&quot;student&quot;&#123;</span><br><span class="line">		</span><br><span class="line">		elasticsearch&#123;</span><br><span class="line">			# 集群地址</span><br><span class="line">			hosts =&gt; [&quot;127.0.0.1:9200&quot;,&quot;127.0.0.1:9201&quot;,&quot;127.0.0.1:9202&quot;]</span><br><span class="line">			# 索引名称</span><br><span class="line">			index =&gt; &quot;student&quot;</span><br><span class="line">			# 生成根据student_id,生成ES的 _id</span><br><span class="line">			document_id =&gt; &quot;%&#123;student_id&#125;&quot;</span><br><span class="line">			# 类型</span><br><span class="line">			document_type =&gt; &quot;student_doc&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第4节-logstash配置-其他配置"><a href="#第4节-logstash配置-其他配置" class="headerlink" title="第4节 logstash配置(其他配置)"></a>第4节 logstash配置(其他配置)</h3><ul>
<li><p>官网配置地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.elastic.co/guide/en/logstash/6.3/plugins-inputs-jdbc.html</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-1-使用时间字段进行追踪-一般使用更新时间字段"><a href="#4-1-使用时间字段进行追踪-一般使用更新时间字段" class="headerlink" title="4.1 使用时间字段进行追踪(一般使用更新时间字段)"></a>4.1 使用时间字段进行追踪(一般使用更新时间字段)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在阿里巴巴嵩山版手册中强调,任何数据库表都必须有创建时间和更新时间字段,都是datetime类型,也就是保存时间为年月日时分秒</span><br><span class="line">input&#123;</span><br><span class="line">	# 第1张表</span><br><span class="line">	jdbc&#123;</span><br><span class="line">		# 设置当前jdbc的type</span><br><span class="line">		type =&gt; &quot;department&quot;</span><br><span class="line">		# 数据库驱动地址</span><br><span class="line">		jdbc_driver_library =&gt; &quot;D:\\soft\\logstash-6.3.2\\lib\\mysql-connector-java-5.1.47.jar&quot; </span><br><span class="line">		# 数据库驱动类名</span><br><span class="line">		jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">		# 数据库连接地址</span><br><span class="line">		jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/gn_oa&quot;</span><br><span class="line">		# 数据库用户名</span><br><span class="line">		jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">		# 数据库密码</span><br><span class="line">		jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">		# 定时任务,一分钟同步一次</span><br><span class="line">		schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">		# 如果sql语句使用sql_last_value属性要设置use_column_value为true,并且指定tracking_column属性,指定哪一列</span><br><span class="line">		use_column_value =&gt; true</span><br><span class="line">		# 指定sql_last_value参数使用哪一列</span><br><span class="line">		tracking_column =&gt; &quot;create_time&quot;</span><br><span class="line">		# 设置tracking_column属性名保存的状态</span><br><span class="line">		last_run_metadata_path =&gt; &quot;D:\\soft\\logstash-6.3.2\\a\\a.txt&quot;</span><br><span class="line">		# 是否保留前一次的运行状态,如果不保留下次重启服务器所以会被重新创建</span><br><span class="line">		clean_run =&gt; false</span><br><span class="line">		# 设置时间戳</span><br><span class="line">		tracking_column_type =&gt; &quot;timestamp&quot;</span><br><span class="line">		# 生成索引的数据来源</span><br><span class="line">		statement =&gt; &quot;SELECT * FROM department WHERE create_time &gt; :sql_last_value AND create_time &lt; now() ORDER BY create_time desc&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	# 第2张表</span><br><span class="line">	jdbc&#123;</span><br><span class="line">		# 设置当前jdbc的type</span><br><span class="line">		type =&gt; &quot;student&quot;</span><br><span class="line">		# 数据库驱动地址</span><br><span class="line">		jdbc_driver_library =&gt; &quot;D:\\soft\\logstash-6.3.2\\lib\\mysql-connector-java-5.1.47.jar&quot; </span><br><span class="line">		# 数据库驱动类名</span><br><span class="line">		jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">		# 数据库连接地址</span><br><span class="line">		jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/gn_oa&quot;</span><br><span class="line">		# 数据库用户名</span><br><span class="line">		jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">		# 数据库密码</span><br><span class="line">		jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">		# 定时任务,一分钟同步一次</span><br><span class="line">		schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">		# 如果sql语句使用sql_last_value属性要设置use_column_value为true</span><br><span class="line">		use_column_value =&gt; true</span><br><span class="line">		# 指定sql_last_value参数使用哪一列</span><br><span class="line">		tracking_column =&gt; &quot;create_time&quot;</span><br><span class="line">		# 设置tracking_column属性名保存的状态</span><br><span class="line">		last_run_metadata_path =&gt; &quot;D:\\soft\\logstash-6.3.2\\b\\b.txt&quot;</span><br><span class="line">		# 是否保留前一次的运行状态,如果不保留下次重启服务器所以会被重新创建</span><br><span class="line">		clean_run =&gt; false</span><br><span class="line">		# 设置时间戳</span><br><span class="line">		tracking_column_type =&gt; &quot;timestamp&quot;</span><br><span class="line">		# 生成索引的数据来源</span><br><span class="line">		statement =&gt; &quot;SELECT * FROM student WHERE create_time &gt; :sql_last_value AND create_time &lt; now() ORDER BY create_time desc&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line"></span><br><span class="line">	# 根据jdbc中的type值指定输入的jdbc对应的输出为哪一个elasticsearch</span><br><span class="line">	</span><br><span class="line">	if[type]==&quot;department&quot;&#123;</span><br><span class="line"></span><br><span class="line">		elasticsearch&#123;</span><br><span class="line">			# 集群地址</span><br><span class="line">			hosts =&gt; [&quot;127.0.0.1:9200&quot;,&quot;127.0.0.1:9201&quot;,&quot;127.0.0.1:9202&quot;]</span><br><span class="line">			# 索引名称</span><br><span class="line">			index =&gt; &quot;department&quot;</span><br><span class="line">			# 生成根据dept_id,生成ES的 _id</span><br><span class="line">			document_id =&gt; &quot;%&#123;dept_id&#125;&quot;</span><br><span class="line">			# 类型</span><br><span class="line">			document_type =&gt; &quot;dept_doc&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if[type]==&quot;student&quot;&#123;</span><br><span class="line">		</span><br><span class="line">		elasticsearch&#123;</span><br><span class="line">			# 集群地址</span><br><span class="line">			hosts =&gt; [&quot;127.0.0.1:9200&quot;,&quot;127.0.0.1:9201&quot;,&quot;127.0.0.1:9202&quot;]</span><br><span class="line">			# 索引名称</span><br><span class="line">			index =&gt; &quot;student&quot;</span><br><span class="line">			# 生成根据student_id,生成ES的 _id</span><br><span class="line">			document_id =&gt; &quot;%&#123;student_id&#125;&quot;</span><br><span class="line">			# 类型</span><br><span class="line">			document_type =&gt; &quot;student_doc&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-2-使用其他字段进行追踪-设置使用主键进行追踪"><a href="#4-2-使用其他字段进行追踪-设置使用主键进行追踪" class="headerlink" title="4.2 使用其他字段进行追踪(设置使用主键进行追踪)"></a>4.2 使用其他字段进行追踪(设置使用主键进行追踪)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在修改其他字段进行追踪时,一定不要忘记修改tracking_column_type类型,详情修改请参官网</span><br><span class="line">input&#123;</span><br><span class="line">	# 第1张表</span><br><span class="line">	jdbc&#123;</span><br><span class="line">		# 设置当前jdbc的type</span><br><span class="line">		type =&gt; &quot;department&quot;</span><br><span class="line">		# 数据库驱动地址</span><br><span class="line">		jdbc_driver_library =&gt; &quot;D:\\soft\\logstash-6.3.2\\lib\\mysql-connector-java-5.1.47.jar&quot; </span><br><span class="line">		# 数据库驱动类名</span><br><span class="line">		jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">		# 数据库连接地址</span><br><span class="line">		jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/gn_oa&quot;</span><br><span class="line">		# 数据库用户名</span><br><span class="line">		jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">		# 数据库密码</span><br><span class="line">		jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">		# 定时任务,一分钟同步一次</span><br><span class="line">		schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">		# 如果sql语句使用sql_last_value属性要设置use_column_value为true,并且指定tracking_column属性,指定哪一列</span><br><span class="line">		use_column_value =&gt; true</span><br><span class="line">		# 指定sql_last_value参数使用哪一列</span><br><span class="line">		tracking_column =&gt; &quot;dept_id&quot;</span><br><span class="line">		# 设置tracking_column属性名保存的状态</span><br><span class="line">		last_run_metadata_path =&gt; &quot;D:\\soft\\logstash-6.3.2\\a\\a.txt&quot;</span><br><span class="line">		# 是否保留前一次的运行状态,如果不保留下次重启服务器所以会被重新创建</span><br><span class="line">		clean_run =&gt; false</span><br><span class="line">		# 设置列的类型</span><br><span class="line">		tracking_column_type =&gt; &quot;numeric&quot;</span><br><span class="line">		# 生成索引的数据来源</span><br><span class="line">		statement =&gt; &quot;SELECT * FROM department WHERE dept_id &gt; :sql_last_value&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	# 第2张表</span><br><span class="line">	jdbc&#123;</span><br><span class="line">		# 设置当前jdbc的type</span><br><span class="line">		type =&gt; &quot;student&quot;</span><br><span class="line">		# 数据库驱动地址</span><br><span class="line">		jdbc_driver_library =&gt; &quot;D:\\soft\\logstash-6.3.2\\lib\\mysql-connector-java-5.1.47.jar&quot; </span><br><span class="line">		# 数据库驱动类名</span><br><span class="line">		jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">		# 数据库连接地址</span><br><span class="line">		jdbc_connection_string =&gt; &quot;jdbc:mysql://127.0.0.1:3306/gn_oa&quot;</span><br><span class="line">		# 数据库用户名</span><br><span class="line">		jdbc_user =&gt; &quot;root&quot;</span><br><span class="line">		# 数据库密码</span><br><span class="line">		jdbc_password =&gt; &quot;root&quot;</span><br><span class="line">		# 定时任务,一分钟同步一次</span><br><span class="line">		schedule =&gt; &quot;* * * * *&quot;</span><br><span class="line">		# 如果sql语句使用sql_last_value属性要设置use_column_value为true</span><br><span class="line">		use_column_value =&gt; true</span><br><span class="line">		# 指定sql_last_value参数使用哪一列</span><br><span class="line">		tracking_column =&gt; &quot;student_id&quot;</span><br><span class="line">		# 设置tracking_column属性名保存的状态</span><br><span class="line">		last_run_metadata_path =&gt; &quot;D:\\soft\\logstash-6.3.2\\b\\b.txt&quot;</span><br><span class="line">		# 是否保留前一次的运行状态,如果不保留下次重启服务器所以会被重新创建</span><br><span class="line">		clean_run =&gt; false</span><br><span class="line">		# 设置列的类型</span><br><span class="line">		tracking_column_type =&gt; &quot;numeric&quot;</span><br><span class="line">		# 生成索引的数据来源</span><br><span class="line">		statement =&gt; &quot;SELECT * FROM student WHERE student_id &gt; :sql_last_value&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line"></span><br><span class="line">	# 根据jdbc中的type值指定输入的jdbc对应的输出为哪一个elasticsearch</span><br><span class="line">	</span><br><span class="line">	if[type]==&quot;department&quot;&#123;</span><br><span class="line"></span><br><span class="line">		elasticsearch&#123;</span><br><span class="line">			# 集群地址</span><br><span class="line">			hosts =&gt; [&quot;127.0.0.1:9200&quot;,&quot;127.0.0.1:9201&quot;,&quot;127.0.0.1:9202&quot;]</span><br><span class="line">			# 索引名称</span><br><span class="line">			index =&gt; &quot;department&quot;</span><br><span class="line">			# 生成根据dept_id,生成ES的 _id</span><br><span class="line">			document_id =&gt; &quot;%&#123;dept_id&#125;&quot;</span><br><span class="line">			# 类型</span><br><span class="line">			document_type =&gt; &quot;dept_doc&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if[type]==&quot;student&quot;&#123;</span><br><span class="line">		</span><br><span class="line">		elasticsearch&#123;</span><br><span class="line">			# 集群地址</span><br><span class="line">			hosts =&gt; [&quot;127.0.0.1:9200&quot;,&quot;127.0.0.1:9201&quot;,&quot;127.0.0.1:9202&quot;]</span><br><span class="line">			# 索引名称</span><br><span class="line">			index =&gt; &quot;student&quot;</span><br><span class="line">			# 生成根据student_id,生成ES的 _id</span><br><span class="line">			document_id =&gt; &quot;%&#123;student_id&#125;&quot;</span><br><span class="line">			# 类型</span><br><span class="line">			document_type =&gt; &quot;student_doc&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>注意: 日常bug记录与采坑指南,如果出现下面的BUG并且在进行配置查找的时候,无论怎么校验都不能从自己的配置中找到错误,但是服务器还启动不起来,那么可以尝试在错误信息中查找关键信息,经过反复校验,如果设置了last_run_metadata_path服务器可以正常启动,如果配置中少了last_run_metadata_path 属性服务器启动失败,就会报如下错误,并且在下面的错误中,有相关信息,我的报错信息如下,关键信息last_run_metadata_path=&gt;”C:\Users\lenovo/.logstash_jdbc_last_run”,说明在上次发生错的时候logstash对我上次的错误信息进行的保存,造成服务器每次启动读取错误信息,造成的服务器启动失败,去指定位置删除即可.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2020-08-20T02:27:40,897][ERROR][logstash.pipeline        ] Error registering plugin &#123;:pipeline_id=&gt;&quot;main&quot;, :plugin=&gt;&quot;&lt;LogStash::Inputs::Jdbc jdbc_driver_library=&gt;\&quot;D:\\\\\\\\soft\\\\\\\\logstash-6.3.2\\\\\\\\lib\\\\\\\\mysql-connector-java-5.1.47.jar\&quot;, jdbc_driver_class=&gt;\&quot;com.mysql.jdbc.Driver\&quot;, jdbc_connection_string=&gt;\&quot;jdbc:mysql://127.0.0.1:3306/gn_oa\&quot;, jdbc_user=&gt;\&quot;root\&quot;, jdbc_password=&gt;&lt;password&gt;, schedule=&gt;\&quot;* * * * *\&quot;, statement=&gt;\&quot;SELECT * FROM department\&quot;, id=&gt;\&quot;02efb29127a061192768f52b1a09e6638672c521b53edda48b19f6b9880e90d6\&quot;, enable_metric=&gt;true, codec=&gt;&lt;LogStash::Codecs::Plain id=&gt;\&quot;plain_e50f7aa8-3c57-4f33-9000-86265d442ec7\&quot;, enable_metric=&gt;true, charset=&gt;\&quot;UTF-8\&quot;&gt;, jdbc_paging_enabled=&gt;false, jdbc_page_size=&gt;100000, jdbc_validate_connection=&gt;false, jdbc_validation_timeout=&gt;3600, jdbc_pool_timeout=&gt;5, sql_log_level=&gt;\&quot;info\&quot;, connection_retry_attempts=&gt;1, connection_retry_attempts_wait_time=&gt;0.5, last_run_metadata_path=&gt;\&quot;C:\\\\Users\\\\lenovo/.logstash_jdbc_last_run\&quot;, use_column_value=&gt;false, tracking_column_type=&gt;\&quot;numeric\&quot;, clean_run=&gt;false, record_last_run=&gt;true, lowercase_column_names=&gt;true&gt;&quot;, :error=&gt;&quot;can&#x27;t dup Fixnum&quot;, :thread=&gt;&quot;#&lt;Thread:0x703b95e6 run&gt;&quot;&#125;</span><br><span class="line">[2020-08-20T02:27:41,426][ERROR][logstash.pipeline        ] Pipeline aborted due to error &#123;:pipeline_id=&gt;&quot;main&quot;, :exception=&gt;#&lt;TypeError: can&#x27;t dup Fixnum&gt;, :backtrace=&gt;[&quot;org/jruby/RubyKernel.java:1882:in `dup&#x27;&quot;, &quot;uri:classloader:/META-INF/jruby.home/lib/ruby/stdlib/date/format.rb:838:in `_parse&#x27;&quot;, &quot;uri:classloader:/META-INF/jruby.home/lib/ruby/stdlib/date.rb:1830:in `parse&#x27;&quot;, &quot;D:/soft/logstash-6.3.2/vendor/bundle/jruby/2.3.0/gems/logstash-input-jdbc-4.3.9/lib/logstash/plugin_mixins/value_tracking.rb:87:in `set_value&#x27;&quot;, &quot;D:/soft/logstash-6.3.2/vendor/bundle/jruby/2.3.0/gems/logstash-input-jdbc-4.3.9/lib/logstash/plugin_mixins/value_tracking.rb:36:in `initialize&#x27;&quot;, &quot;D:/soft/logstash-6.3.2/vendor/bundle/jruby/2.3.0/gems/logstash-input-jdbc-4.3.9/lib/logstash/plugin_mixins/value_tracking.rb:29:in `build_last_value_tracker&#x27;&quot;, &quot;D:/soft/logstash-6.3.2/vendor/bundle/jruby/2.3.0/gems/logstash-input-jdbc-4.3.9/lib/logstash/inputs/jdbc.rb:216:in `register&#x27;&quot;, &quot;D:/soft/logstash-6.3.2/logstash-core/lib/logstash/pipeline.rb:340:in `register_plugin&#x27;&quot;, &quot;D:/soft/logstash-6.3.2/logstash-core/lib/logstash/pipeline.rb:351:in `block in register_plugins&#x27;&quot;, &quot;org/jruby/RubyArray.java:1734:in `each&#x27;&quot;, &quot;D:/soft/logstash-6.3.2/logstash-core/lib/logstash/pipeline.rb:351:in `register_plugins&#x27;&quot;, &quot;D:/soft/logstash-6.3.2/logstash-core/lib/logstash/pipeline.rb:498:in `start_inputs&#x27;&quot;, &quot;D:/soft/logstash-6.3.2/logstash-core/lib/logstash/pipeline.rb:392:in `start_workers&#x27;&quot;, &quot;D:/soft/logstash-6.3.2/logstash-core/lib/logstash/pipeline.rb:288:in `run&#x27;&quot;, &quot;D:/soft/logstash-6.3.2/logstash-core/lib/logstash/pipeline.rb:248:in `block in start&#x27;&quot;], :thread=&gt;&quot;#&lt;Thread:0x703b95e6 run&gt;&quot;&#125;</span><br><span class="line">[2020-08-20T02:27:41,467][ERROR][logstash.agent           ] Failed to execute action &#123;:id=&gt;:main, :action_type=&gt;LogStash::ConvergeResult::FailedAction, :message=&gt;&quot;Could not execute action: PipelineAction::Create&lt;main&gt;, action_result: false&quot;, :backtrace=&gt;nil&#125;</span><br></pre></td></tr></table></figure>

<p>坚持原创技术分享，您的支持将鼓励我继续创作！</p>
<p>打赏</p>
]]></content>
  </entry>
  <entry>
    <title>mybatis</title>
    <url>/2021/08/08/mybatis/</url>
    <content><![CDATA[<h2 id="第一章-mybatis简介"><a href="#第一章-mybatis简介" class="headerlink" title="第一章 mybatis简介"></a>第一章 mybatis简介</h2><h3 id="1-1-mybatis的历史"><a href="#1-1-mybatis的历史" class="headerlink" title="1.1 mybatis的历史"></a>1.1 mybatis的历史</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. mybatis在2010年前叫ibatis是apache内部的一个项目，名字来源于internet+ibatis 是一个基于Java的持久层框架</span><br><span class="line">2. 2010年以后从apache内部迁移到google code上，并且改名为mybatis</span><br><span class="line">3. 2013年迁移到github上</span><br></pre></td></tr></table></figure>



<h3 id="1-2-mybatis是什么"><a href="#1-2-mybatis是什么" class="headerlink" title="1.2 mybatis是什么"></a>1.2 mybatis是什么</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 是一款优秀的持久层框架</span><br><span class="line">2. 支持定制化sql，存储过程以及高级映射</span><br><span class="line">3. 可以避免几乎所有的JDBC代码手动设置参数以及获取结果集</span><br><span class="line">4. 可以使用简单的 XML 或注解来配置和映射原生信息</span><br><span class="line">5. 用接口将Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录</span><br></pre></td></tr></table></figure>

<h3 id="1-3-mybatis的优势"><a href="#1-3-mybatis的优势" class="headerlink" title="1.3 mybatis的优势"></a>1.3 mybatis的优势</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 相比于JDBC没有侵入性可以达到很好的解耦效果</span><br><span class="line">2. 相比于hibernate他有着高性能，可以满足当下绝大多数移动互联网时代的需求</span><br><span class="line">3. sql代码分类放置在不同的sql map中易维护</span><br></pre></td></tr></table></figure>

<h3 id="1-4-mybatis的核心文件编写"><a href="#1-4-mybatis的核心文件编写" class="headerlink" title="1.4 mybatis的核心文件编写"></a>1.4 mybatis的核心文件编写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. POJO映射数据库表的Java对象</span><br><span class="line">2. data access objects(DAOS)映射器接口类，用于操作数据库</span><br><span class="line">3. sql maps : SQL映射配置文件,用于注册DAOs接口,使其接口有操作数据库的能力</span><br><span class="line">4. mybatis配置文件,初始化一些基本的配置信息,用于生成SqlSessionFactory</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第二章-入门HelloWorld"><a href="#第二章-入门HelloWorld" class="headerlink" title="第二章 入门HelloWorld"></a>第二章 入门HelloWorld</h2><ul>
<li><p>数据库表创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建数据库</span><br><span class="line">CREATE DATABASE mybatis DEFAULT CHARACTER SET UTF8;</span><br><span class="line">//创建数据库表</span><br><span class="line">CREATE TABLE user(</span><br><span class="line">    `user_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">    `user_name` VARCHAR(100) NOT NULL COMMENT &#x27;用户名&#x27;,</span><br><span class="line">    `create_time` DATETIME DEFAULT NULL comment &#x27;创建时间&#x27;</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=UTF8 COMMENT=&quot;用户表&quot;;</span><br></pre></td></tr></table></figure></li>
<li><p>入门HelloWorld代码的编写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①创建项目,添加jar包</span><br><span class="line">    mybatis-3.4.6.jar</span><br><span class="line">    mysql-connector-java-5.1.7-bin.jar</span><br><span class="line">②根据官网的步骤一步步进行环境搭建.</span><br><span class="line">③使用junit测试进行接口的测试.</span><br></pre></td></tr></table></figure></li>
<li><ul>
<li>步骤</li>
</ul>
</li>
</ul>
<blockquote>
<p>第1步 创建映射数据库表的实体类</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 映射数据库表的接口类</span><br><span class="line"> * @author hu shuang</span><br><span class="line"> * @email hd1611756908@163.com</span><br><span class="line"> */</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">	//用户ID</span><br><span class="line">	private Integer userId;</span><br><span class="line">	//用户名</span><br><span class="line">	private String userName;</span><br><span class="line">	//创建时间</span><br><span class="line">	private Date createTime;</span><br><span class="line"></span><br><span class="line">	public User() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	public User(Integer userId, String userName, Date createTime) &#123;</span><br><span class="line">		this.userId = userId;</span><br><span class="line">		this.userName = userName;</span><br><span class="line">		this.createTime = createTime;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第2步 创建操作数据库表的接口类</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 操作数据库表的接口</span><br><span class="line"> * @author hu shuang</span><br><span class="line"> * @email hd1611756908@163.com</span><br><span class="line"> */</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * 添加用户</span><br><span class="line">	 */</span><br><span class="line">	void addUser(User user);</span><br><span class="line">	/*</span><br><span class="line">	 * 删除用户</span><br><span class="line">	 */</span><br><span class="line">	void deleteUser(Integer userId);</span><br><span class="line">	/*</span><br><span class="line">	 * 更新用户</span><br><span class="line">	 */</span><br><span class="line">	void updateUser(User user);</span><br><span class="line">	/*</span><br><span class="line">	 * 通过用户ID获取用户信息</span><br><span class="line">	 */</span><br><span class="line">	User getUser(Integer userId);</span><br><span class="line">	/*</span><br><span class="line">	 * 获取用户列表</span><br><span class="line">	 */</span><br><span class="line">	List&lt;User&gt; getUsers();</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * 根据名字模糊查询获取用户列表</span><br><span class="line">	 */</span><br><span class="line">	List&lt;User&gt; getUsersLikeByUserName(@Param(&quot;userName&quot;) String userName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第3步 创建注册操作数据库接口类的映射文件</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">操作数据库只能用SQL语句,但是mybatis提供了使用接口操作数据库,一般情况接口是没有操作数据库的能力的,但是 mybatis可以通过这个配置文件来注册接口，让接口有操作数据库的能力</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.im.mapper.UserMapper&quot;&gt;</span><br><span class="line">	&lt;!-- </span><br><span class="line">		此配置文件用来注册UserMapper这个接口以及此接口中定义的方法</span><br><span class="line">		namespace: 被注册接口的全类名</span><br><span class="line">		insert: 插入数据的标签,还有其他三个标签 查询select、更新update、删除delete</span><br><span class="line">		id: 接口里面定义的方法名字</span><br><span class="line">		parameterType: 方法的入参类型(全类名)</span><br><span class="line">		#&#123;xxx&#125;: 表达式  :  取方法的参数值</span><br><span class="line">				如果方法的入参是基本数据类型那么xxx为形参名</span><br><span class="line">				如果方法的入参为对象类型那么xxx为对象类型里面的属性名</span><br><span class="line">		resultType:方法的返回值类型</span><br><span class="line">		useGeneratedKeys: 让 myabtis 框架使用JDBC 通过 getGeneratedKeys 获取数据库主键.</span><br><span class="line">		keyProperty: 映射通过getGeneratedKeys获取的键值</span><br><span class="line">	 --&gt;</span><br><span class="line">	 &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.im.entity.User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;userId&quot;&gt;</span><br><span class="line">	 	INSERT INTO user(user_name,create_time) VALUES(#&#123;userName&#125;,#&#123;createTime&#125;)</span><br><span class="line">	 &lt;/insert&gt;</span><br><span class="line">	 </span><br><span class="line">	 &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;Integer&quot;&gt;</span><br><span class="line">	 	DELETE FROM user WHERE user_id=#&#123;userId&#125;</span><br><span class="line">	 &lt;/delete&gt;</span><br><span class="line">	 </span><br><span class="line">	 &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.im.entity.User&quot;&gt;</span><br><span class="line">	 	UPDATE user SET user_name=#&#123;userName&#125;,create_time=#&#123;createTime&#125; WHERE user_id=#&#123;userId&#125;</span><br><span class="line">	 &lt;/update&gt;</span><br><span class="line">	 </span><br><span class="line">	 &lt;select id=&quot;getUser&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.im.entity.User&quot;&gt;</span><br><span class="line">	 	SELECT user_id as userId,user_name as userName,create_time as createTime FROM user WHERE user_id=#&#123;userId&#125;</span><br><span class="line">	 &lt;/select&gt;</span><br><span class="line">	 </span><br><span class="line">	 &lt;select id=&quot;getUsers&quot; resultType=&quot;com.im.entity.User&quot;&gt;</span><br><span class="line">	 	SELECT user_id as userId,user_name as userName,create_time as createTime FROM user</span><br><span class="line">	 &lt;/select&gt;</span><br><span class="line">	 &lt;!-- </span><br><span class="line">	  	构建LIKE参数</span><br><span class="line">	  	方式一: CONCAT(&#x27;参数1&#x27;,&#x27;参数2&#x27;,&#x27;参数3&#x27;) </span><br><span class="line">	  	方式二: 在传参数时构建成 %李雷%</span><br><span class="line">	  	方式三: 使用bind标签创建元素,放到上下文中</span><br><span class="line">	  --&gt;</span><br><span class="line">	 &lt;select id=&quot;getUsersLikeByUserName&quot; resultType=&quot;com.sc.entity.User&quot;&gt;</span><br><span class="line">	  	SELECT user_id as userId,user_name as userName,create_time as createTime FROM user WHERE user_name like CONCAT(&#x27;%&#x27;,#&#123;userName&#125;,&#x27;%&#x27;)</span><br><span class="line">	 &lt;/select&gt;</span><br><span class="line">	 &lt;select id=&quot;getUsersLikeByUserName&quot; resultType=&quot;com.sc.entity.User&quot;&gt;</span><br><span class="line">	  	SELECT user_id as userId,user_name as userName,create_time as createTime FROM user WHERE user_name like #&#123;userName&#125;</span><br><span class="line">	 &lt;/select&gt;</span><br><span class="line">	 </span><br><span class="line">	 &lt;select id=&quot;getUsersLikeByUserName&quot; resultType=&quot;com.sc.entity.User&quot;&gt;</span><br><span class="line">	  	&lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + _parameter.userName + &#x27;%&#x27;&quot; /&gt;</span><br><span class="line">	  	SELECT user_id as userId,user_name as userName,create_time as createTime FROM user WHERE user_name like #&#123;pattern&#125;</span><br><span class="line">	 &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第4步 创建mybatis核心配置文件 mybatis-config.xml,用于生成mybatis核心对象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">      &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">      &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">      	&lt;!-- 数据库驱动 --&gt;</span><br><span class="line">        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">        &lt;!-- mysql数据库地址 --&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;/&gt;</span><br><span class="line">        &lt;!-- 数据库用户名 --&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;!-- 数据库密码 --&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">      &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">  &lt;/environments&gt;</span><br><span class="line">  &lt;mappers&gt;</span><br><span class="line">  	&lt;!-- 将注册接口的配置文件注册到mybatis的核心配置文件中,这是jar包版本,如果是maven项目，要放在resources文件夹下 --&gt;</span><br><span class="line">    &lt;mapper resource=&quot;com/im/mapper/UserMapper.xml&quot;/&gt;</span><br><span class="line">  &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第5步 通过单元测试类调用接口测试(mybatis原生API版调用)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserMapperTest1 &#123;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 添加用户</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testAddUser() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//创建statement</span><br><span class="line">		String statement = &quot;com.im.mapper.UserMapper.addUser&quot;;</span><br><span class="line">		//构建入参</span><br><span class="line">		User user = new User();</span><br><span class="line">		user.setUserName(&quot;Tom&quot;);</span><br><span class="line">		user.setCreateTime(new Date());</span><br><span class="line">		int row = session.insert(statement, user);</span><br><span class="line">		System.out.println(&quot;row:&quot;+row);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * 删除用户</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testDeleteUser() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//创建statement</span><br><span class="line">		String statement = &quot;com.im.mapper.UserMapper.deleteUser&quot;;</span><br><span class="line">		//调用mybatis的删除数据的API </span><br><span class="line">		int row = session.delete(statement, 1);</span><br><span class="line">		System.out.println(&quot;row:&quot;+row);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * 更新用户</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testUpdateUser() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//创建statement</span><br><span class="line">		String statement = &quot;com.im.mapper.UserMapper.updateUser&quot;;</span><br><span class="line">		//调用mybatis的更新数据的API </span><br><span class="line">		//构建更新入参</span><br><span class="line">		User user = new User(2, &quot;polly&quot;, new Date());</span><br><span class="line">		int row = session.update(statement, user);</span><br><span class="line">		System.out.println(&quot;row:&quot;+row);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * 根据ID获取用户</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testGetUser() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//创建statement</span><br><span class="line">		String statement = &quot;com.im.mapper.UserMapper.getUser&quot;;</span><br><span class="line">		//调用mybatis的查询单个数据的API </span><br><span class="line">		User user = session.selectOne(statement, 2);</span><br><span class="line">		System.out.println(&quot;user:&quot;+user);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * 获取用户列表</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testGetUsers() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//创建statement</span><br><span class="line">		String statement = &quot;com.im.mapper.UserMapper.getUsers&quot;;</span><br><span class="line">		//调用mybatis的查询列表数据的API </span><br><span class="line">		List&lt;User&gt; list = session.selectList(statement);</span><br><span class="line">		System.out.println(&quot;users:&quot;+list);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第6步 通过单元测试类调用接口测试(mybatis映射器版调用)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserMapperTest2 &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * 添加用户</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testAddUser() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//获取映射器类的对象实例</span><br><span class="line">		UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">		//构建入参</span><br><span class="line">		User user = new User();</span><br><span class="line">		user.setUserName(&quot;张三&quot;);</span><br><span class="line">		user.setCreateTime(new Date());</span><br><span class="line">		//调用添加用户方法</span><br><span class="line">		userMapper.addUser(user);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * 删除用户</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testDeleteUser() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//获取映射器类的对象实例</span><br><span class="line">		UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">		//调用删除方法</span><br><span class="line">		userMapper.deleteUser(2);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * 更新用户</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testUpdateUser() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//获取映射器类的对象实例</span><br><span class="line">		UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">		//构建更新入参</span><br><span class="line">		User user = new User(2, &quot;polly&quot;, new Date());</span><br><span class="line">		//调用更新方法</span><br><span class="line">		userMapper.updateUser(user);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * 根据ID获取用户</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testGetUser() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//获取映射器类的对象实例</span><br><span class="line">		UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">		//调用查询方法</span><br><span class="line">		User user = userMapper.getUser(3);</span><br><span class="line">		System.out.println(&quot;user:&quot;+user);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * 获取用户列表</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testGetUsers() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//获取映射器类的对象实例</span><br><span class="line">		UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">		//调用查询全部方法</span><br><span class="line">		List&lt;User&gt; users = userMapper.getUsers();</span><br><span class="line">		System.out.println(&quot;users:&quot;+users);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第三章-mybatis常用属性配置"><a href="#第三章-mybatis常用属性配置" class="headerlink" title="第三章 mybatis常用属性配置"></a>第三章 mybatis常用属性配置</h2><ul>
<li><p>properties:导入外部属性资源文件，解决数据库配置信息写到Java代码中的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt;</span><br><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">	&lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">		&lt;transactionManager type=&quot;JDBC&quot; /&gt;</span><br><span class="line">		&lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">			&lt;!-- 数据库驱动 --&gt;</span><br><span class="line">			&lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc_driver&#125;&quot; /&gt;</span><br><span class="line">			&lt;!-- mysql数据库地址 --&gt;</span><br><span class="line">			&lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc_url&#125;&quot; /&gt;</span><br><span class="line">			&lt;!-- 数据库用户名 --&gt;</span><br><span class="line">			&lt;property name=&quot;username&quot; value=&quot;$&#123;user&#125;&quot; /&gt;</span><br><span class="line">			&lt;!-- 数据库密码 --&gt;</span><br><span class="line">			&lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot; /&gt;</span><br><span class="line">		&lt;/dataSource&gt;</span><br><span class="line">	&lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>typeAliases: 解决别名的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在mybatis-config.xml配置文件中配置别名</span><br><span class="line"></span><br><span class="line">&lt;!-- 别名设置 --&gt;</span><br><span class="line">&lt;typeAliases&gt;</span><br><span class="line">	&lt;!-- 将全类名 com.im.entity.User 映射成别名 user --&gt;</span><br><span class="line">	&lt;!-- 单个设置 --&gt;</span><br><span class="line">	&lt;!-- &lt;typeAlias type=&quot;com.im.entity.User&quot; alias=&quot;user&quot;/&gt; --&gt;</span><br><span class="line">	&lt;!-- 多个设置，将放在com.im.entity包下的所有Javabean都设置别名 --&gt;</span><br><span class="line">	&lt;package name=&quot;com.im.entity&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB558b8aae7b33719d29689ea0648dca2e?method=download&shareKey=233b9c7c99b2612638c88c52061f043e"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB558b8aae7b33719d29689ea0648dca2e?method=download&shareKey=233b9c7c99b2612638c88c52061f043e" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><p>setting: mybatis的一些常用配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在mybatis-config.xml配置文件中配置一些mybatis的基本属性</span><br><span class="line"></span><br><span class="line">&lt;settings&gt;</span><br><span class="line">  &lt;!-- 二级缓存开启 默认开启 --&gt;</span><br><span class="line">  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  &lt;!-- 懒加载 默认值 false --&gt;</span><br><span class="line">  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  &lt;!-- 即时加载 默认是false (true in ≤3.4.1)在3.4.1版本以前默认值为true --&gt;</span><br><span class="line">  &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  &lt;!-- 数据库经典列名和Java经典列名的映射（默认值为false） --&gt;</span><br><span class="line">  &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mapUnderscoreToCamelCase:简单介绍一下此属性的使用,其他的属性会在后面一一介绍。</span><br><span class="line"></span><br><span class="line">在日常Java开发中我们的命名规则驼峰状比如: aaaBbbCcc</span><br><span class="line">而我们的数据库命名规则为: AAA_BBB_CCC，因为命名规则</span><br><span class="line">的不同，在进行Java POJO和数据库表关系映射时，通过反射</span><br><span class="line">就会出现名称对应不上出现属性找不到数据为空的问题,解决方式一般有两种</span><br><span class="line">- ①通过SQL的设置别名</span><br><span class="line">- ②设置mapUnderscoreToCamelCase属性为true </span><br><span class="line">    </span><br><span class="line">第一种方式我们上面已经用过，接下来我们使用mybatis提供的配置方式解决这个问题,但是一定要注意数据库的命名和Java的命名，一定要遵循自己的命名规范</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB7d9d44efa80e645e97bbd41d9105bc41?method=download&shareKey=9f119b142aabb8b438dd325416ea6936"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB7d9d44efa80e645e97bbd41d9105bc41?method=download&shareKey=9f119b142aabb8b438dd325416ea6936" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><p>mappers: 映射文件的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在mybatis-config.xml配置文件中配置</span><br><span class="line"></span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">	&lt;!-- 将注册接口的配置文件注册到mybatis的核心配置文件中，</span><br><span class="line">	     如果有多个映射文件,可以配置多个,还有其他方式会在后面介</span><br><span class="line">	     绍 --&gt;</span><br><span class="line">	&lt;mapper resource=&quot;com/im/mapper/UserMapper1.xml&quot; /&gt;</span><br><span class="line">	&lt;mapper resource=&quot;com/im/mapper/UserMapper2.xml&quot; /&gt;</span><br><span class="line">	&lt;mapper resource=&quot;com/im/mapper/UserMapper3.xml&quot; /&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第四章-映射枚举类型"><a href="#第四章-映射枚举类型" class="headerlink" title="第四章 映射枚举类型"></a>第四章 映射枚举类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">映射枚举的时候比较特殊,mybatis官方给我们提供了将枚举映射成字符串或者整数类型两种方式.看下面的实现方式.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>表设计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据库表的SQL语句</span><br><span class="line"></span><br><span class="line">CREATE TABLE student(</span><br><span class="line">    `stu_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">    `stu_name` VARCHAR(100) NOT NULL COMMENT &#x27;学生名&#x27;,</span><br><span class="line">    `gender1` INT NOT NULL COMMENT &#x27;性别整数类型&#x27;,</span><br><span class="line">    `gender2` VARCHAR(10) NOT NULL COMMENT &#x27;性别字符类型&#x27;</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=UTF8 COMMENT=&quot;学生表&quot;;</span><br></pre></td></tr></table></figure></li>
<li><p>映射数据库表的实体类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 性别的枚举类</span><br><span class="line"> * @author hu shuang</span><br><span class="line"> * @email hd1611756908@163.com</span><br><span class="line"> */</span><br><span class="line">public enum Gender &#123;</span><br><span class="line">	MAN(&quot;男&quot;), </span><br><span class="line">	WOMAN(&quot;女&quot;),</span><br><span class="line">	NEUTRAL(&quot;中性&quot;);</span><br><span class="line">	private String sex;</span><br><span class="line">	private Gender(String sex) &#123;</span><br><span class="line">		this.sex = sex;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getSex() &#123;</span><br><span class="line">		return sex;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setSex(String sex) &#123;</span><br><span class="line">		this.sex = sex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;------------------分隔线-----------------------&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 	映射数据库student表的类</span><br><span class="line"> *  @author hu shuang</span><br><span class="line"> *  @email hd1611756908@163.com</span><br><span class="line"> */</span><br><span class="line">public class Student &#123;</span><br><span class="line">	private Integer stuId;</span><br><span class="line">	private String stuName;</span><br><span class="line">	//性别映射数据库整数类型</span><br><span class="line">	private Gender gender1;</span><br><span class="line">	//性别映射数据库字符类型</span><br><span class="line">	private Gender gender2;</span><br><span class="line">	public Student() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>操作学生表的映射器接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  操作学生表的映射器接口</span><br><span class="line"> *	@author hu shuang</span><br><span class="line"> *  @email hd1611756908@163.com</span><br><span class="line"> */</span><br><span class="line">public interface StudentMapper &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * 添加一个学生</span><br><span class="line">	 */</span><br><span class="line">	void addStudent(Student student);</span><br><span class="line">	/*</span><br><span class="line">	 * 更新一个学生</span><br><span class="line">	 */</span><br><span class="line">	void updateStudent(Student student);</span><br><span class="line">	/*</span><br><span class="line">	 * 获取学生列表</span><br><span class="line">	 */</span><br><span class="line">	List&lt;Student&gt; getStudents();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注册接口的xml配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注册接口的xml配置文件</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=&quot;com.im.mapper.StudentMapper&quot;&gt;</span><br><span class="line">	&lt;!-- </span><br><span class="line">		1、Java枚举值映射到数据库表里面的整型字段时，映射的是枚举的数组下标值</span><br><span class="line">		   使用typeHandler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot;</span><br><span class="line">		2、Java枚举值映射到数据库表里面的varchar类型字段时,使用typeHandler=&quot;org.apache.ibatis.type.EnumTypeHandler&quot;</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;insert id=&quot;addStudent&quot; parameterType=&quot;student&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;stuId&quot;&gt;</span><br><span class="line">		INSERT INTO student(stu_name,gender1,gender2) VALUES(#&#123;stuName&#125;,</span><br><span class="line">		#&#123;gender1,typeHandler=org.apache.ibatis.type.EnumOrdinalTypeHandler&#125;,</span><br><span class="line">		#&#123;gender2,typeHandler=org.apache.ibatis.type.EnumTypeHandler&#125;)</span><br><span class="line">	&lt;/insert&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 查询带有枚举类型的数据时，返回值结果类型不能使用resultType属性设置，需要使用resultMap属性重新进行映射 --&gt;</span><br><span class="line">	&lt;resultMap type=&quot;student&quot; id=&quot;studentMap&quot;&gt;</span><br><span class="line">		&lt;id property=&quot;stuId&quot; column=&quot;stu_id&quot;/&gt;</span><br><span class="line">		&lt;result property=&quot;stuName&quot; column=&quot;stu_name&quot;/&gt;</span><br><span class="line">		&lt;!-- 映射下标 --&gt;</span><br><span class="line">		&lt;result property=&quot;gender1&quot; column=&quot;gender1&quot; typeHandler=&quot;org.apache.ibatis.type.EnumOrdinalTypeHandler&quot;/&gt;</span><br><span class="line">		&lt;!-- 映射字符串 --&gt;</span><br><span class="line">		&lt;result property=&quot;gender2&quot; column=&quot;gender2&quot; typeHandler=&quot;org.apache.ibatis.type.EnumTypeHandler&quot;/&gt;</span><br><span class="line">	&lt;/resultMap&gt;</span><br><span class="line">	&lt;select id=&quot;getStudents&quot; resultMap=&quot;studentMap&quot;&gt;</span><br><span class="line">		SELECT * FROM student</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;!-- 更新枚举类型 --&gt;</span><br><span class="line">	&lt;update id=&quot;updateStudent&quot; parameterType=&quot;student&quot;&gt;</span><br><span class="line">		UPDATE student SET stu_name=#&#123;stuName&#125;,gender1=#&#123;gender1,typeHandler=org.apache.ibatis.type.EnumOrdinalTypeHandler&#125;,gender2=#&#123;gender2,typeHandler=org.apache.ibatis.type.EnumTypeHandler&#125; WHERE stu_id=#&#123;stuId&#125;</span><br><span class="line">	&lt;/update&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>测试枚举类型的增改查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试枚举类型的增删改</span><br><span class="line"> * @author hu shuang</span><br><span class="line"> * @email  hd1611756908@163.com</span><br><span class="line"> */</span><br><span class="line">public class StudentMapperTest &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * 添加学生</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testAddStudent() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		</span><br><span class="line">		StudentMapper mapper = session.getMapper(StudentMapper.class);</span><br><span class="line">		Student student = new Student();</span><br><span class="line">		student.setStuName(&quot;韩梅梅&quot;);</span><br><span class="line">		student.setGender1(Gender.MAN);</span><br><span class="line">		student.setGender2(Gender.MAN);</span><br><span class="line">		mapper.addStudent(student);</span><br><span class="line">		</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	/*</span><br><span class="line">	 * 获取学生列表</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testGetStudents() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		</span><br><span class="line">		StudentMapper mapper = session.getMapper(StudentMapper.class);</span><br><span class="line">		List&lt;Student&gt; students = mapper.getStudents();</span><br><span class="line">		System.out.println(students);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * 更新学生信息</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testUpdateStudent() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		StudentMapper mapper = session.getMapper(StudentMapper.class);</span><br><span class="line">		Student student = new Student();</span><br><span class="line">		student.setStuId(1001);</span><br><span class="line">		student.setStuName(&quot;polly&quot;);</span><br><span class="line">		student.setGender1(Gender.WOMAN);</span><br><span class="line">		student.setGender2(Gender.WOMAN);</span><br><span class="line">		mapper.updateStudent(student);</span><br><span class="line">		</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第五章-SQL-map-注解-方式进行数据库操作"><a href="#第五章-SQL-map-注解-方式进行数据库操作" class="headerlink" title="第五章 SQL map(注解) 方式进行数据库操作"></a>第五章 SQL map(注解) 方式进行数据库操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注解方式操作数据库:</span><br><span class="line"></span><br><span class="line">1. 不需要注册接口的xml配置文件</span><br><span class="line">2. 直接将SQL写到操作数据库的接口里的每一个方法上</span><br><span class="line">3. 核心配置文件 mapper 直接配置类</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">	&lt;!-- 将注册接口的配置文件注册到mybatis的核心配置文件中 --&gt;</span><br><span class="line">	&lt;mapper class=&quot;com.im.mapper.UserMapper&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>操作数据库的接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 操作数据库表的接口</span><br><span class="line"> * @author hu shuang</span><br><span class="line"> * @email hd1611756908@163.com</span><br><span class="line"> */</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * 添加用户</span><br><span class="line">	 */</span><br><span class="line">	@Insert(&quot;INSERT INTO user(user_name,create_time) VALUES(#&#123;userName&#125;,#&#123;createTime&#125;)&quot;)</span><br><span class="line">	public void addUser(User user);</span><br><span class="line">	/*</span><br><span class="line">	 * 删除用户</span><br><span class="line">	 */</span><br><span class="line">	@Delete(&quot;DELETE FROM user WHERE user_id=#&#123;userId&#125;&quot;)</span><br><span class="line">	void deleteUser(Integer userId);</span><br><span class="line">	/*</span><br><span class="line">	 * 更新用户</span><br><span class="line">	 */</span><br><span class="line">	@Update(&quot;UPDATE user SET user_name=#&#123;userName&#125;,create_time=#&#123;createTime&#125; WHERE user_id=#&#123;userId&#125;&quot;)</span><br><span class="line">	void updateUser(User user);</span><br><span class="line">	/*</span><br><span class="line">	 * 通过用户ID获取用户信息</span><br><span class="line">	 */</span><br><span class="line">	@Select(&quot;SELECT * FROM user WHERE user_id=#&#123;userId&#125;&quot;)</span><br><span class="line">	User getUser(Integer userId);</span><br><span class="line">	/*</span><br><span class="line">	 * 获取用户列表</span><br><span class="line">	 */</span><br><span class="line">	@Select(&quot;SELECT * FROM user&quot;)</span><br><span class="line">	List&lt;User&gt; getUsers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单元测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserMapperTest &#123;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void testAddUser() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">		//构建入参</span><br><span class="line">		User user = new User();</span><br><span class="line">		user.setUserName(&quot;张三&quot;);</span><br><span class="line">		user.setCreateTime(new Date());</span><br><span class="line">		mapper.addUser(user);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void testDeleteUser() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">		mapper.deleteUser(2);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void testUpdateUser() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">		//构建入参</span><br><span class="line">		User user = new User();</span><br><span class="line">		user.setUserId(5);</span><br><span class="line">		user.setUserName(&quot;JIM&quot;);</span><br><span class="line">		user.setCreateTime(new Date());</span><br><span class="line">		mapper.updateUser(user);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void testGetUsers() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">		List&lt;User&gt; users = mapper.getUsers();</span><br><span class="line">		System.out.println(users);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第六章-mybatis的日志功能"><a href="#第六章-mybatis的日志功能" class="headerlink" title="第六章 mybatis的日志功能"></a>第六章 mybatis的日志功能</h2><h3 id="6-1-日志的介绍"><a href="#6-1-日志的介绍" class="headerlink" title="6.1 日志的介绍"></a>6.1 日志的介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis内置日志工厂提供日志功能，内置日志工厂将日志交给以下其中一种工具做代理:</span><br><span class="line"></span><br><span class="line">1. SLF4J</span><br><span class="line">2. Apache Commons Logging</span><br><span class="line">3. Log4j 2</span><br><span class="line">4. Log4j</span><br><span class="line">5. JDK logging</span><br><span class="line"></span><br><span class="line">mybatis 内置日志工厂基于运行时自省机制选择合适的日志工具。它会使用第一个查找得到的工具（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。</span><br></pre></td></tr></table></figure>

<h3 id="6-2-日志配置"><a href="#6-2-日志配置" class="headerlink" title="6.2 日志配置"></a>6.2 日志配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不少应用服务器（如 Tomcat 和 WebShpere）的类路径中已经包含 Commons Logging，所以在这种配置环境下的MyBatis会把它作为日志工具，记住这点非常重要。这将意味着，在诸如 WebSphere 的环境中，它提供了 Commons Logging的私有实现，你的Log4J配置将被忽略。MyBatis将你的Log4J配置忽略掉是相当令人郁闷的（事实上，正是因为在这种配置环境下，MyBatis 才会选择使用 Commons Logging而不是Log4J）。如果你的应用部署在一个类路径已经包含 Commons Logging 的环境中，而你又想使用其它日志工具，你可以通过在 MyBatis 配置文件mybatis-config.xml里面添加一项setting 来选择别的日志工具。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;settings&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logImpl 可选的值有：SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING，或者是实现了接口org.apache.ibatis.logging.Log的，且构造方法是以字符串为参数的类的完全限定名。</span><br><span class="line">(译者注：可以参考org.apache.ibatis.logging.slf4j.Slf4jImpl.java的实现)</span><br></pre></td></tr></table></figure>

<h3 id="6-3-日志的使用"><a href="#6-3-日志的使用" class="headerlink" title="6.3 日志的使用"></a>6.3 日志的使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1步: 添加jar包</span><br><span class="line"></span><br><span class="line">log4j-1.2.17.jar</span><br><span class="line">slf4j-api-1.7.25.jar</span><br><span class="line">slf4j-log4j12-1.7.25.jar</span><br><span class="line"></span><br><span class="line">第2步: 添加日志配置文件log4j.xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;</span><br><span class="line">&lt;log4j:configuration</span><br><span class="line">	xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt;</span><br><span class="line">	&lt;appender name=&quot;STDOUT&quot;</span><br><span class="line">		class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;</span><br><span class="line">		&lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt;</span><br><span class="line">		&lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">			&lt;param name=&quot;ConversionPattern&quot;</span><br><span class="line">				value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m  (%F:%L) \n&quot; /&gt;</span><br><span class="line">		&lt;/layout&gt;</span><br><span class="line">	&lt;/appender&gt;</span><br><span class="line">	&lt;logger name=&quot;java.sql&quot;&gt;</span><br><span class="line">		&lt;level value=&quot;debug&quot; /&gt;</span><br><span class="line">	&lt;/logger&gt;</span><br><span class="line">	&lt;logger name=&quot;org.apache.ibatis&quot;&gt;</span><br><span class="line">		&lt;level value=&quot;debug&quot; /&gt;</span><br><span class="line">	&lt;/logger&gt;</span><br><span class="line">	&lt;root&gt;</span><br><span class="line">		&lt;level value=&quot;debug&quot; /&gt;</span><br><span class="line">		&lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">	&lt;/root&gt;</span><br><span class="line">&lt;/log4j:configuration&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第七章-动态SQL"><a href="#第七章-动态SQL" class="headerlink" title="第七章 动态SQL"></a>第七章 动态SQL</h2><h3 id="7-1-动态SQL简介"><a href="#7-1-动态SQL简介" class="headerlink" title="7.1 动态SQL简介"></a>7.1 动态SQL简介</h3><ul>
<li><p>动态SQL优势</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis的强⼤特性之一就是动态sql,有过根据不同条件拼接SQL经历的同学应该知道当条件多的时候拼接SQL是一件很痛苦的事情，但是mybatis却很好的帮我们解决了拼接SQL的烦恼</span><br></pre></td></tr></table></figure></li>
<li><p>动态SQL所涉及到的标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. if</span><br><span class="line">2. choose(when,otherwise)(类似于我们Java中的switch语句)</span><br><span class="line">3. trim(where,set)</span><br><span class="line">4. foreach(多用于批量操作)</span><br></pre></td></tr></table></figure>

<h3 id="7-2-动态SQL使用"><a href="#7-2-动态SQL使用" class="headerlink" title="7.2 动态SQL使用"></a>7.2 动态SQL使用</h3></li>
</ul>
<h4 id="7-2-1-if语句-用于where子句之后作为条件判断"><a href="#7-2-1-if语句-用于where子句之后作为条件判断" class="headerlink" title="7.2.1 if语句(用于where子句之后作为条件判断)"></a>7.2.1 if语句(用于where子句之后作为条件判断)</h4><ul>
<li><p>使用常量(1=1)解决由于部分条件匹配而产生的多AND造成SQL语法错误的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- if可以作为条件判断 并且使用 1=1 来解决由于条件不匹配而产生的多AND造成SQL语法错误的问题 --&gt;</span><br><span class="line">&lt;select id=&quot;getBooks&quot; parameterType=&quot;book&quot; resultType=&quot;book&quot;&gt;</span><br><span class="line">	SELECT * FROM book WHERE 1=1</span><br><span class="line">	&lt;if test=&quot;bookName!=null&quot;&gt;AND book_name=#&#123;bookName&#125;&lt;/if&gt;</span><br><span class="line">	&lt;if test=&quot;author!=null and author.name!=null&quot;&gt;AND author_name=#&#123;author.name&#125;&lt;/if&gt;</span><br><span class="line">	&lt;if test=&quot;price!=null&quot;&gt;AND price=#&#123;price&#125;&lt;/if&gt; </span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB061a19c5a3b7c0baf087a7f31875166b?method=download&shareKey=7abb9dc3097d16ffccb6aa0933aa3366"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB061a19c5a3b7c0baf087a7f31875166b?method=download&shareKey=7abb9dc3097d16ffccb6aa0933aa3366" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<ul>
<li><p>使用</p>
<p>标签解决由于部分条件匹配而产生的多AND造成SQL语法错误的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- if可以作为条件判断 并且使用&lt;where&gt;标签来解决由于条件不匹配而产生的多AND造成SQL语法错误的问题 --&gt;</span><br><span class="line">&lt;select id=&quot;getBooks&quot; parameterType=&quot;book&quot; resultType=&quot;book&quot;&gt;</span><br><span class="line">	SELECT * FROM book</span><br><span class="line">	&lt;where&gt;</span><br><span class="line">		&lt;if test=&quot;bookName!=null&quot;&gt;AND book_name=#&#123;bookName&#125;&lt;/if&gt;</span><br><span class="line">		&lt;if test=&quot;author!=null and author.name!=null&quot;&gt;AND author_name=#&#123;author.name&#125;&lt;/if&gt;</span><br><span class="line">		&lt;if test=&quot;price!=null&quot;&gt;AND price=#&#123;price&#125;&lt;/if&gt; </span><br><span class="line">	&lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB97fa1dc4f8a1dcc94a08daae823d9e75?method=download&shareKey=9a4f41817d4838c0c28ee393539cb357"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB97fa1dc4f8a1dcc94a08daae823d9e75?method=download&shareKey=9a4f41817d4838c0c28ee393539cb357" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<h4 id="7-2-2-if语句-用于更新语句作为入参判断"><a href="#7-2-2-if语句-用于更新语句作为入参判断" class="headerlink" title="7.2.2 if语句(用于更新语句作为入参判断)"></a>7.2.2 if语句(用于更新语句作为入参判断)</h4><ul>
<li><p>解决在增量更新时，因为不是所有字段都更新,所以有些字段没有赋值，造成的更新数据库某些数据被置空的为题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;update id=&quot;updateBook&quot; parameterType=&quot;book&quot;&gt;</span><br><span class="line">	UPDATE book SET </span><br><span class="line">	&lt;if test=&quot;bookNam!=null&quot;&gt;book_name=#&#123;bookName&#125;,&lt;/if&gt;</span><br><span class="line">	&lt;if test=&quot;author!=null and author.name!=null&quot;&gt;author_name=#&#123;author.name&#125;,&lt;/if&gt;</span><br><span class="line">	&lt;if test=&quot;price!=null&quot;&gt;price=#&#123;price&#125;&lt;/if&gt;</span><br><span class="line">	WHERE book_id=#&#123;bookId&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在更新时，由于有些字段不需要更新而造成的SQL语句多逗号(,)问题</span><br></pre></td></tr></table></figure></li>
<li><p>解决方式(</p>
<p>标签)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;update id=&quot;updateBook&quot; parameterType=&quot;book&quot;&gt;</span><br><span class="line">	UPDATE book </span><br><span class="line">	&lt;set&gt;</span><br><span class="line">		&lt;if test=&quot;bookNam!=null&quot;&gt;book_name=#&#123;bookName&#125;,&lt;/if&gt;</span><br><span class="line">		&lt;if test=&quot;author!=null and author.name!=null&quot;&gt;author_name=#&#123;author.name&#125;,&lt;/if&gt;</span><br><span class="line">		&lt;if test=&quot;price!=null&quot;&gt;price=#&#123;price&#125;&lt;/if&gt;</span><br><span class="line">	&lt;/set&gt;</span><br><span class="line">	WHERE book_id=#&#123;bookId&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://note.youdao.com/yws/api/personal/file/WEB0da056304be34fd2b0a5e355f7e1ff55?method=download&shareKey=a6a05b0000575db0118d831edcd955bb"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/WEB0da056304be34fd2b0a5e355f7e1ff55?method=download&shareKey=a6a05b0000575db0118d831edcd955bb" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="img"></a></p>
<h4 id="7-2-3-choose-when-otherwise"><a href="#7-2-3-choose-when-otherwise" class="headerlink" title="7.2.3 choose (when, otherwise)"></a>7.2.3 choose (when, otherwise)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于匹配多个条件中的一个(不常用)</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;getBooks&quot; parameterType=&quot;book&quot; resultType=&quot;book&quot;&gt;</span><br><span class="line">	SELECT * FROM book WHERE</span><br><span class="line">	&lt;choose&gt;</span><br><span class="line">		&lt;when test=&quot;bookName!=null&quot;&gt;book_name=#&#123;bookName&#125;&lt;/when&gt;</span><br><span class="line">		&lt;when test=&quot;author!=null and author.name!=null&quot;&gt;author_name=#&#123;author.name&#125;&lt;/when&gt;</span><br><span class="line">		&lt;when test=&quot;price!=null&quot;&gt;price=#&#123;price&#125;&lt;/when&gt;</span><br><span class="line">		&lt;otherwise&gt;</span><br><span class="line">			book_id=#&#123;bookId&#125;</span><br><span class="line">		&lt;/otherwise&gt;</span><br><span class="line">	&lt;/choose&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-4-foreach-多用于批量操作"><a href="#7-2-4-foreach-多用于批量操作" class="headerlink" title="7.2.4 foreach(多用于批量操作)"></a>7.2.4 foreach(多用于批量操作)</h4><ul>
<li><p>批量操作Mapper层接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 操作数据库表的接口</span><br><span class="line"> * @author hu shuang</span><br><span class="line"> * @email hd1611756908@163.com</span><br><span class="line"> */</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * 批量添加</span><br><span class="line">	 */</span><br><span class="line">	//void batchAddUser(List&lt;User&gt; users); //根据类型匹配</span><br><span class="line">	void batchAddUser(@Param(&quot;users&quot;) List&lt;User&gt; users);//根据名称匹配</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * 批量查询</span><br><span class="line">	 */</span><br><span class="line">	void batchQueryUsers(List&lt;Integer&gt; ids);</span><br><span class="line">	/*</span><br><span class="line">	 * 批量删除</span><br><span class="line">	 */</span><br><span class="line">	void batchDeleteUsers(List&lt;Integer&gt; ids);</span><br><span class="line">	/*</span><br><span class="line">	 * 批量更新</span><br><span class="line">	 */</span><br><span class="line">	void batchUpdateUsers(List&lt;User&gt; users);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>批量添加语法</p>
</li>
<li><ul>
<li><p>方式一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一:</span><br><span class="line"> &lt;!-- 批量添加 --&gt;</span><br><span class="line"> &lt;!-- 根据类型匹配 --&gt;</span><br><span class="line"> &lt;insert id=&quot;batchAddUser&quot; parameterType=&quot;user&quot;&gt;</span><br><span class="line"> 	INSERT INTO user(user_name,create_time) VALUES </span><br><span class="line"> 	&lt;foreach collection=&quot;list&quot; item=&quot;item&quot;  separator=&quot;,&quot; &gt;</span><br><span class="line"> 		(#&#123;item.userName&#125;,#&#123;item.createTime&#125;)</span><br><span class="line"> 	&lt;/foreach&gt;</span><br><span class="line"> &lt;/insert&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>方式二</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 根据名称匹配 --&gt;</span><br><span class="line"> &lt;insert id=&quot;batchAddUser&quot; parameterType=&quot;user&quot;&gt;</span><br><span class="line"> 	INSERT INTO user(user_name,create_time) VALUES </span><br><span class="line"> 	&lt;foreach collection=&quot;users&quot; item=&quot;item&quot;  separator=&quot;,&quot; &gt;</span><br><span class="line"> 		(#&#123;item.userName&#125;,#&#123;item.createTime&#125;)</span><br><span class="line"> 	&lt;/foreach&gt;</span><br><span class="line"> &lt;/insert&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>批量查询语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 批量查询 --&gt;</span><br><span class="line"> &lt;select id=&quot;batchQueryUsers&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line"> 	SELECT * FROM user WHERE user_id IN </span><br><span class="line"> 	&lt;foreach collection=&quot;list&quot; item=&quot;item&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;</span><br><span class="line"> 		#&#123;item&#125;</span><br><span class="line"> 	&lt;/foreach&gt;</span><br><span class="line"> &lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>批量删除语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 批量删除 --&gt;</span><br><span class="line">&lt;delete id=&quot;batchDeleteUsers&quot;&gt;</span><br><span class="line">	DELETE FROM user WHERE user_id IN </span><br><span class="line">	&lt;foreach collection=&quot;list&quot; item=&quot;id&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">		#&#123;id&#125;</span><br><span class="line">	&lt;/foreach&gt;</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>批量更新语法</p>
</li>
<li><ul>
<li><p>批量更新配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用mybatis进行批量更新数据库数据时，需要在url地址后面加上allowMultiQueries参数等于true</span><br><span class="line">例如: jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&amp;allowMultiQueries=true</span><br><span class="line">注意:在properties文件中使用&amp;号;在xml配置文件中使用&amp;amp;连接参数</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>语法格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 批量更新 --&gt;</span><br><span class="line">&lt;update id=&quot;batchUpdateUsers&quot; parameterType=&quot;user&quot;&gt;</span><br><span class="line">	&lt;foreach collection=&quot;list&quot; item=&quot;item&quot;  open=&quot;&quot; separator=&quot;;&quot; close=&quot;&quot;&gt;</span><br><span class="line">		UPDATE user </span><br><span class="line">		&lt;set&gt;</span><br><span class="line">			&lt;if test=&quot;item.userName!=null&quot;&gt;user_name=#&#123;item.userName&#125;,&lt;/if&gt;</span><br><span class="line">			&lt;if test=&quot;item.createTime!=null&quot;&gt;create_time=#&#123;item.createTime&#125;&lt;/if&gt;</span><br><span class="line">		&lt;/set&gt;</span><br><span class="line">		WHERE user_id=#&#123;item.userId&#125;</span><br><span class="line">	&lt;/foreach&gt;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>单元测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class UserMapperTest &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * 批量添加</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testBatchAddUser() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//获取映射器类的对象实例</span><br><span class="line">		UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">		//构建入参</span><br><span class="line">		List&lt;User&gt; users = new ArrayList&lt;&gt;();</span><br><span class="line">		User user1 = new User(null, &quot;EEE&quot;, new Date());</span><br><span class="line">		User user2 = new User(null, &quot;FFF&quot;, new Date());</span><br><span class="line">		User user3 = new User(null, &quot;GGG&quot;, new Date());</span><br><span class="line">		User user4 = new User(null, &quot;HHH&quot;, new Date());</span><br><span class="line">		</span><br><span class="line">		users.add(user1);</span><br><span class="line">		users.add(user2);</span><br><span class="line">		users.add(user3);</span><br><span class="line">		users.add(user4);</span><br><span class="line">		</span><br><span class="line">		//调用添加用户方法</span><br><span class="line">		userMapper.batchAddUser(users);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * 批量查询</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testBatchQueryUsers() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//获取映射器类的对象实例</span><br><span class="line">		UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">		//构建入参</span><br><span class="line">		List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		ids.add(3);</span><br><span class="line">		ids.add(5);</span><br><span class="line">		ids.add(7);</span><br><span class="line">		</span><br><span class="line">		//调用批量查询用户方法</span><br><span class="line">		List&lt;User&gt; users = userMapper.batchQueryUsers(ids);</span><br><span class="line">		System.out.println(users);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * 批量删除</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testBatchDeleteUsers() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//获取映射器类的对象实例</span><br><span class="line">		UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">		//构建入参</span><br><span class="line">		List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		ids.add(3);</span><br><span class="line">		ids.add(5);</span><br><span class="line">		ids.add(7);</span><br><span class="line">		</span><br><span class="line">		//调用批量删除方法</span><br><span class="line">		userMapper.batchDeleteUsers(ids);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125; </span><br><span class="line">	/*</span><br><span class="line">	 * 批量更新</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testBatchUpdateUsers() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		//获取映射器类的对象实例</span><br><span class="line">		UserMapper userMapper = session.getMapper(UserMapper.class);</span><br><span class="line">		//构建入参</span><br><span class="line">		List&lt;User&gt; users = new ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		User user1 = new User(4,&quot;MMM&quot;, new Date());</span><br><span class="line">		User user2 = new User(6,&quot;VVV&quot;, new Date());</span><br><span class="line">		User user3 = new User(8,&quot;WWW&quot;, new Date());</span><br><span class="line">		</span><br><span class="line">		users.add(user1);</span><br><span class="line">		users.add(user2);</span><br><span class="line">		users.add(user3);</span><br><span class="line">		</span><br><span class="line">		//调用批量更新方法</span><br><span class="line">		userMapper.batchUpdateUsers(users);</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第八章-高级查询"><a href="#第八章-高级查询" class="headerlink" title="第八章 高级查询"></a>第八章 高级查询</h2><h3 id="8-1-数据库表创建-部门表-员工表"><a href="#8-1-数据库表创建-部门表-员工表" class="headerlink" title="8.1 数据库表创建(部门表/员工表)"></a>8.1 数据库表创建(部门表/员工表)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE department(</span><br><span class="line">    `dept_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">    `dept_name` VARCHAR(20) NOT NULL COMMENT &#x27;部门名称&#x27;</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=UTF8 COMMENT=&quot;部门表&quot;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE employee(</span><br><span class="line">    `emp_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">    `emp_name` VARCHAR(20) NOT NULL COMMENT &#x27;员工名称&#x27;,</span><br><span class="line">    `salary` DOUBLE(10,2) DEFAULT 0.00 COMMENT &#x27;工资&#x27;,</span><br><span class="line">    `dept_id` INT NOT NULL COMMENT &#x27;部门ID，关联部门表的主键&#x27;</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=UTF8 COMMENT=&quot;员工表&quot;;</span><br><span class="line"></span><br><span class="line">//关联</span><br><span class="line">ALTER TABLE employee ADD FOREIGN KEY(dept_id) REFERENCES department(dept_id);</span><br><span class="line"></span><br><span class="line">INSERT INTO department(dept_name) VALUES(&#x27;行政部&#x27;),(&#x27;人事部&#x27;),(&#x27;IT部&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO employee(emp_name,salary,dept_id) VALUES(&#x27;孙悟空&#x27;,100.12,1000),(&#x27;猪八戒&#x27;,100.12,1001),(&#x27;沙悟净&#x27;,100.12,1002);</span><br></pre></td></tr></table></figure>

<h3 id="8-2-创建映射数据库表的实体类"><a href="#8-2-创建映射数据库表的实体类" class="headerlink" title="8.2 创建映射数据库表的实体类"></a>8.2 创建映射数据库表的实体类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 映射数据库部门表</span><br><span class="line"> * @author hu shuang</span><br><span class="line"> * @email hd1611756908@163.com</span><br><span class="line"> */</span><br><span class="line">public class Department &#123;</span><br><span class="line">	private Integer deptId;</span><br><span class="line">	private String deptName;</span><br><span class="line">	// 一个部门下有多个员工(一对多关联)</span><br><span class="line">	private List&lt;Employee&gt; employees;</span><br><span class="line"></span><br><span class="line">	public Department() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 映射数据库员工表</span><br><span class="line"> * @author hu shuang</span><br><span class="line"> * @email hd1611756908@163.com</span><br><span class="line"> */</span><br><span class="line">public class Employee &#123;</span><br><span class="line"></span><br><span class="line">	private Integer empId;</span><br><span class="line">	private String empName;</span><br><span class="line">	private Double salary;</span><br><span class="line">	// 一个员工对应一个部门(一对一关联)</span><br><span class="line">	private Department department;</span><br><span class="line"></span><br><span class="line">	public Employee() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-创建操作数据库的映射器接口"><a href="#8-3-创建操作数据库的映射器接口" class="headerlink" title="8.3 创建操作数据库的映射器接口"></a>8.3 创建操作数据库的映射器接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. (一对一)查询员工信息,将员工的部门信息同时查出(一个员工属于一个部门)</span><br><span class="line">2. (一对多)查询部门信息,将此部门下的所有员工信息都查询出来(一个部门下有多个员工)</span><br><span class="line">public interface DepartmentMapper &#123;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 根据部门ID查询部门详情,不需要将当前部门下的员工列表查出</span><br><span class="line">	 */</span><br><span class="line">	Department getDepartmentByDeptId(Integer deptId);</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * 根据部门ID查询部门详情,需要将当前部门下的员工列表查询出来(方式一 一对多关联查询 单条SQL)</span><br><span class="line">	 */</span><br><span class="line">	Department getDepartmentByDeptId_(Integer deptId);</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * 根据部门ID查询部门详情,需要将当前部门下的员工列表查询出来(方式二 一对多关联查询 多条SQL)</span><br><span class="line">	 */</span><br><span class="line">	Department getDepartmentByDeptId$(Integer deptId);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">public interface EmployeeMapper &#123;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 通过员工ID查询员工信息,同时查询出员工的部门信息( 方式一(单条SQL 关联查询) )</span><br><span class="line">	 */</span><br><span class="line">	Employee getEmployeeByEmpId(Integer empId);</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * 通过员工ID查询员工信息,同时查询出员工的部门信息( 方式二(多条SQL查询) )</span><br><span class="line">	 */</span><br><span class="line">	Employee getEmployeeByEmpId_(Integer empId);</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * 通过部门ID查询员工列表</span><br><span class="line">	 */</span><br><span class="line">	List&lt;Employee&gt; getEmployeesByDeptId(Integer deptId);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-创建注册接口的XML配置文件"><a href="#8-4-创建注册接口的XML配置文件" class="headerlink" title="8.4 创建注册接口的XML配置文件"></a>8.4 创建注册接口的XML配置文件</h3><ul>
<li><p>一对一(方式一)单条SQL关联查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EmployeeMapper.xml</span><br><span class="line"></span><br><span class="line">&lt;!-- 一对一 方式一(单条SQL 关联查询) --&gt;</span><br><span class="line">&lt;resultMap type=&quot;employee&quot; id=&quot;employeeMap&quot;&gt;</span><br><span class="line">	&lt;!-- 映射主键 --&gt;</span><br><span class="line">	&lt;id property=&quot;empId&quot; column=&quot;emp_id&quot;/&gt;</span><br><span class="line">	&lt;!-- 其他映射 --&gt;</span><br><span class="line">	&lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt;</span><br><span class="line">	&lt;result property=&quot;salary&quot; column=&quot;salary&quot;/&gt;</span><br><span class="line">	&lt;!-- 使用 association 进行一对一关联查询 --&gt;</span><br><span class="line">	&lt;association property=&quot;department&quot; javaType=&quot;department&quot;&gt;</span><br><span class="line">		&lt;id property=&quot;deptId&quot; column=&quot;dept_id&quot;/&gt;</span><br><span class="line">		&lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;/&gt;</span><br><span class="line">	&lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;getEmployeeByEmpId&quot; parameterType=&quot;Integer&quot; resultMap=&quot;employeeMap&quot;&gt;</span><br><span class="line">	SELECT * FROM employee e,department d WHERE e.dept_id=d.dept_id AND e.emp_id=#&#123;empId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>一对一(方式二)多条SQL分别查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EmployeeMapper.xml</span><br><span class="line"></span><br><span class="line">&lt;!-- 一对一 方式二(多条SQL查询) --&gt;</span><br><span class="line">&lt;resultMap type=&quot;employee&quot; id=&quot;employeeMap_&quot;&gt;</span><br><span class="line">	&lt;id property=&quot;empId&quot; column=&quot;emp_id&quot;/&gt;</span><br><span class="line">	&lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt;</span><br><span class="line">	&lt;result property=&quot;salary&quot; column=&quot;salary&quot;/&gt;</span><br><span class="line">	&lt;!-- </span><br><span class="line">		 当使用方式二时,association标签内有一个select属性,需要在此调用DepartmentMapper xml</span><br><span class="line">		 配置文件中的statement进行二次查询</span><br><span class="line">		 com.im.mapper.DepartmentMapper.getDepartmentByDeptId:DepartmentMapper.xml中的namespace(接口全类名)+id属性(方法名字)</span><br><span class="line">	--&gt;</span><br><span class="line">	&lt;association property=&quot;department&quot; javaType=&quot;department&quot; column=&quot;dept_id&quot; select=&quot;com.im.mapper.DepartmentMapper.getDepartmentByDeptId&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;getEmployeeByEmpId_&quot; parameterType=&quot;Integer&quot; resultMap=&quot;employeeMap_&quot;&gt;</span><br><span class="line">	SELECT * FROM employee WHERE emp_id=#&#123;empId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DepartmentMapper.xml</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;getDepartmentByDeptId&quot; parameterType=&quot;Integer&quot; resultType=&quot;department&quot;&gt;</span><br><span class="line">	SELECT * FROM department WHERE dept_id=#&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>一对多(方式一)单条SQL关联查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DepartmentMapper.xml</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据部门ID查询部门详情,需要将当前部门下的员工列表查询出来(方式一 一对多关联查询 单条SQL) --&gt;</span><br><span class="line">&lt;resultMap type=&quot;department&quot; id=&quot;departmentMap_&quot;&gt;</span><br><span class="line">	&lt;id property=&quot;deptId&quot; column=&quot;dept_id&quot;/&gt;</span><br><span class="line">	&lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;/&gt;</span><br><span class="line">	&lt;!-- 一对多关联查询多的一方使用collection标签 ofType:集合中的泛型类型;property:多的一方属性名 --&gt;</span><br><span class="line">	&lt;collection property=&quot;employees&quot; ofType=&quot;employee&quot;&gt;</span><br><span class="line">		&lt;id property=&quot;empId&quot; column=&quot;emp_id&quot;/&gt;</span><br><span class="line">		&lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;/&gt;</span><br><span class="line">		&lt;result property=&quot;salary&quot; column=&quot;salary&quot;/&gt;</span><br><span class="line">	&lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;getDepartmentByDeptId_&quot; parameterType=&quot;Integer&quot; resultMap=&quot;departmentMap_&quot;&gt;</span><br><span class="line">	SELECT * FROM department d,employee e WHERE d.dept_id=e.dept_id AND d.dept_id=#&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>一对多(方式二)多条SQL分别查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DepartmentMapper.xml</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据部门ID查询部门详情,需要将当前部门下的员工列表查询出来(方式二 一对多关联查询 多条SQL) --&gt;</span><br><span class="line">&lt;resultMap type=&quot;department&quot; id=&quot;departmentMap$&quot;&gt;</span><br><span class="line">	&lt;id property=&quot;deptId&quot; column=&quot;dept_id&quot;/&gt;</span><br><span class="line">	&lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;/&gt;</span><br><span class="line">	&lt;!-- 一对多关联查询多的一方使用collection标签 ofType:集合中的泛型类型;property:多的一方属性名 column:关联关系的键 --&gt;</span><br><span class="line">	&lt;collection property=&quot;employees&quot; ofType=&quot;employee&quot; column=&quot;dept_id&quot; select=&quot;com.im.mapper.EmployeeMapper.getEmployeesByDeptId&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;getDepartmentByDeptId$&quot; parameterType=&quot;Integer&quot; resultMap=&quot;departmentMap$&quot;&gt;</span><br><span class="line">	SELECT * FROM department WHERE dept_id=#&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EmployeeMapper.xml</span><br><span class="line"></span><br><span class="line">&lt;select id=&quot;getEmployeesByDeptId&quot; parameterType=&quot;Integer&quot; resultType=&quot;employee&quot;&gt;</span><br><span class="line">	SELECT * FROM employee WHERE dept_id=#&#123;deptId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-5-单元测试类"><a href="#8-5-单元测试类" class="headerlink" title="8.5 单元测试类"></a>8.5 单元测试类</h3></li>
<li><p>EmployeeMapperTest.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class EmployeeMapperTest &#123;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 一对一 方式一(使用一条SQL语句关联查询)</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testGetEmployeeByEmpId() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		</span><br><span class="line">		EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">		Employee employee = employeeMapper.getEmployeeByEmpId(1000);</span><br><span class="line">		System.out.println(employee);</span><br><span class="line">		</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * 一对一 方式二(多条SQL分别查询)</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testGetEmployeeByEmpId_() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		</span><br><span class="line">		EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">		Employee employee = employeeMapper.getEmployeeByEmpId_(1000);</span><br><span class="line">		System.out.println(employee);</span><br><span class="line">		</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>DepartmentMapperTest.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class DepartmentMapperTest &#123;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 一对多 方式一(使用一条SQL语句关联查询)</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testGetDepartmentByDeptId_() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		</span><br><span class="line">		DepartmentMapper mapper = session.getMapper(DepartmentMapper.class);</span><br><span class="line">		Department department = mapper.getDepartmentByDeptId_(1000);</span><br><span class="line">		System.out.println(department);</span><br><span class="line">		</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/*</span><br><span class="line">	 * 一对多 方式二(多条SQL单独查询)</span><br><span class="line">	 */</span><br><span class="line">	@Test</span><br><span class="line">	public void testGetDepartmentByDeptId$() throws IOException &#123;</span><br><span class="line">		//加载外部属性资源文件</span><br><span class="line">		InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">		//创建SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">		//创建SqlSession</span><br><span class="line">		SqlSession session = sessionFactory.openSession();</span><br><span class="line">		</span><br><span class="line">		DepartmentMapper mapper = session.getMapper(DepartmentMapper.class);</span><br><span class="line">		Department department = mapper.getDepartmentByDeptId$(1000);</span><br><span class="line">		System.out.println(department);</span><br><span class="line">		</span><br><span class="line">		//提交</span><br><span class="line">		session.commit();</span><br><span class="line">		//关闭会话</span><br><span class="line">		session.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-6-关联查询bug扩展"><a href="#8-6-关联查询bug扩展" class="headerlink" title="8.6 关联查询bug扩展"></a>8.6 关联查询bug扩展</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于带有关联关系的多个POJO之间因为属性名相同问题而引起的映射数据出错的BUG处理以及解决方式</span><br></pre></td></tr></table></figure></li>
<li><p>创建数据库表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tb_key(</span><br><span class="line">    `id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">    `name` VARCHAR(20) NOT NULL COMMENT &#x27;钥匙名称&#x27;,</span><br><span class="line">    `lock_id` INT NOT NULL COMMENT &#x27;锁ID关联锁表的主键&#x27;</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=UTF8 COMMENT=&quot;钥匙表&quot;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tb_lock(</span><br><span class="line">    `id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">    `name` VARCHAR(20) NOT NULL COMMENT &#x27;锁名称&#x27;</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=UTF8 COMMENT=&quot;锁表&quot;;</span><br><span class="line">//关联</span><br><span class="line">ALTER TABLE tb_key ADD FOREIGN KEY(lock_id) REFERENCES tb_lock(id);</span><br><span class="line"></span><br><span class="line">INSERT INTO tb_key(name,lock_id) VALUES(&quot;铁牛钥匙&quot;,1000);</span><br><span class="line">INSERT INTO tb_lock(name) VALUES(&#x27;铁牛锁&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>创建映射数据库表的实体类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 锁类</span><br><span class="line"> */</span><br><span class="line">public class TbLock &#123;</span><br><span class="line"></span><br><span class="line">	private Integer id;</span><br><span class="line">	private String name;</span><br><span class="line"></span><br><span class="line">	public TbLock() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 钥匙类</span><br><span class="line"> */</span><br><span class="line">public class TbKey &#123;</span><br><span class="line"></span><br><span class="line">	private Integer id;</span><br><span class="line">	private String name;</span><br><span class="line">	//一把钥匙只能开一把锁 一对一关联</span><br><span class="line">	private TbLock tbLock;</span><br><span class="line"></span><br><span class="line">	public TbKey() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建操作数据库表的映射器接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface TbKeyMapper &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * 通过钥匙ID钥匙信息以及锁的信息</span><br><span class="line">	 */</span><br><span class="line">	TbKey getKeyInfo(Integer keyId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建注册操作数据库表接口的xml配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;com.im.mapper.TbKeyMapper&quot;&gt;</span><br><span class="line">	&lt;resultMap type=&quot;tbKey&quot; id=&quot;tbKeyMap&quot;&gt;</span><br><span class="line">		&lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">		&lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;</span><br><span class="line">		&lt;association property=&quot;tbLock&quot; javaType=&quot;tbLock&quot;&gt;</span><br><span class="line">			&lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">			&lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;</span><br><span class="line">		&lt;/association&gt;</span><br><span class="line">	&lt;/resultMap&gt;</span><br><span class="line">	&lt;select id=&quot;getKeyInfo&quot; parameterType=&quot;Integer&quot; resultMap=&quot;tbKeyMap&quot;&gt;</span><br><span class="line">		SELECT * FROM tb_key tk,tb_lock tl WHERE tk.lock_id=tl.id AND tk.id=#&#123;keyId&#125;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>编写测试类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testGetKeyInfo() throws IOException &#123;</span><br><span class="line">	//加载外部属性资源文件</span><br><span class="line">	InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">	//创建SqlSessionFactory</span><br><span class="line">	SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">	//创建SqlSession</span><br><span class="line">	SqlSession session = sessionFactory.openSession();</span><br><span class="line">	</span><br><span class="line">	TbKeyMapper keyMapper = session.getMapper(TbKeyMapper.class);</span><br><span class="line">	TbKey keyInfo = keyMapper.getKeyInfo(1000);</span><br><span class="line">	System.out.println(keyInfo);</span><br><span class="line">	</span><br><span class="line">	//提交</span><br><span class="line">	session.commit();</span><br><span class="line">	//关闭会话</span><br><span class="line">	session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结果分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">得出的结果,会发现映射出错,钥匙和锁信息都是相同的</span><br><span class="line"></span><br><span class="line">TbKey [id=1000, name=铁牛钥匙, tbLock=TbLock [id=1000, name=铁牛钥匙]]</span><br><span class="line"></span><br><span class="line">造成以上问题的原因是因为TbKey和TbLock两个JavaBean类中的属性名字相同造成的,由此可以看出 association 标签映射Java对象时采用的是通过名称映射的,在两个JavaBean属性名字相同时，在映射时候就会出现映射不清的问题。</span><br></pre></td></tr></table></figure></li>
<li><p>解决方案: 采用多SQL联查的方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap type=&quot;tbKey&quot; id=&quot;tbKeyMap&quot;&gt;</span><br><span class="line">	&lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">	&lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;</span><br><span class="line">	&lt;association property=&quot;tbLock&quot; javaType=&quot;tbLock&quot; column=&quot;lock_id&quot; select=&quot;com.im.mapper.TbLockMapper.getLockInfo&quot;/&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;select id=&quot;getKeyInfo&quot; parameterType=&quot;Integer&quot; resultMap=&quot;tbKeyMap&quot;&gt;</span><br><span class="line">	SELECT * FROM tb_key WHERE id=#&#123;keyId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第九章-mybatis的懒加载"><a href="#第九章-mybatis的懒加载" class="headerlink" title="第九章 mybatis的懒加载"></a>第九章 mybatis的懒加载</h2><h3 id="9-1-什么是懒加载"><a href="#9-1-什么是懒加载" class="headerlink" title="9.1 什么是懒加载"></a>9.1 什么是懒加载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">懒加载又称延时加载，就是在我们获取数据时，有些数据是不需要实时获取的，当需要时在获取，这样的加载数据的方式被称为懒加载</span><br></pre></td></tr></table></figure>

<h3 id="9-2-懒加载的使用"><a href="#9-2-懒加载的使用" class="headerlink" title="9.2 懒加载的使用"></a>9.2 懒加载的使用</h3><ul>
<li><p>添加jar包如果是maven依赖,可以不加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cglib-2.2.2.jar</span><br><span class="line">asm-3.3.1.jar</span><br></pre></td></tr></table></figure></li>
<li><p>在mybatis全局配置文件中开启懒加载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关闭及时加载 aggressiveLazyLoading</span><br><span class="line">开启懒加载 lazyLoadingEnabled</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">	&lt;!-- 设置经典Java命名规则和经典数据库命名规则的自动映射 --&gt;</span><br><span class="line">	&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">	&lt;!-- 开启懒加载 --&gt;</span><br><span class="line">	&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">	&lt;!-- 关闭延时加载 --&gt;</span><br><span class="line">	&lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 特定关联关系是指使用关联映射标签</span><br><span class="line">&lt;collection&gt;或者&lt;association&gt;中的select</span><br><span class="line">属性，而不是使用多表联查的方式.</span><br><span class="line">2. 可以通过&lt;collection&gt;或者&lt;association&gt;的fetchType属性设置成lazy</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第十章-mybatis的缓存"><a href="#第十章-mybatis的缓存" class="headerlink" title="第十章 mybatis的缓存"></a>第十章 mybatis的缓存</h2><h3 id="10-1-缓存的优缺点"><a href="#10-1-缓存的优缺点" class="headerlink" title="10.1 缓存的优缺点"></a>10.1 缓存的优缺点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优点: 减少读数据库的读操作,降低数据库压力,加快响应速度</span><br><span class="line">缺点:可能造成数据不一致问题,增加成本</span><br></pre></td></tr></table></figure>

<h3 id="10-2-mybatis的一级缓存"><a href="#10-2-mybatis的一级缓存" class="headerlink" title="10.2 mybatis的一级缓存"></a>10.2 mybatis的一级缓存</h3><ul>
<li><p>一级缓存特点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 一级缓存默认是开启的</span><br><span class="line">2. 一级缓存默认是SqlSession级别的</span><br></pre></td></tr></table></figure></li>
<li><p>验证一级缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在一个SqlSession下根据相同条件多次查询,发现日志只打印一条SQL,说明有缓存存在</span><br><span class="line">2. 在多个SqlSession下,根据相同条件查询,打印多条SQL说明一级缓存是SqlSession级别的,创新创建SqlSession对象之后缓存失效</span><br></pre></td></tr></table></figure></li>
<li><p>一级缓存失效方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 使用sqlSession.clearCache()刷新缓存</span><br><span class="line">2. 关闭SqlSession之后重新打开</span><br><span class="line">3. SqlSession执行增删改之后会清空缓存</span><br></pre></td></tr></table></figure>

<h3 id="10-3-mybatis的二级缓存"><a href="#10-3-mybatis的二级缓存" class="headerlink" title="10.3 mybatis的二级缓存"></a>10.3 mybatis的二级缓存</h3></li>
<li><p>二级缓存特点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 二级缓存需要手动配置</span><br><span class="line">2. 二级缓存是SqlSessionFactory级别的</span><br></pre></td></tr></table></figure></li>
<li><p>二级缓存的使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①在myabtis-config.xml全局的开启二级缓存</span><br><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;!-- 开启二级缓存 --&gt;</span><br><span class="line">    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br><span class="line"></span><br><span class="line">②SQL map映射文件中添加&lt;cache/&gt;</span><br><span class="line">&lt;cache/&gt;标签中属性的介绍:</span><br><span class="line">&lt;cache</span><br><span class="line">    eviction=&quot;FIFO&quot; </span><br><span class="line">    flushInterval=&quot;60000&quot; </span><br><span class="line">    size=&quot;512&quot; </span><br><span class="line">    readOnly=&quot;true&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">eviction: 缓存的回收策略</span><br><span class="line">—&gt;LRU  – 最近最少使用的:移除最长时间不被使用的对象</span><br><span class="line">—&gt;FIFO – 先进先出: 按对象进入缓存的顺序来移除它们</span><br><span class="line">—&gt;SOFT – 软引用: 移除基于垃圾回收器状态和软引用规则的对象 </span><br><span class="line">—&gt;WEAK – 弱引用: 更积极地移除基于垃圾收集器状态和弱引用规则的对象</span><br><span class="line"></span><br><span class="line">flushInterval: 刷新间隔,默认不刷新，可以设置任意的正整数,毫秒数</span><br><span class="line"></span><br><span class="line">size: 引用数目-&gt;可以被设置为任意正整数,要记住你缓存的对象数目和你运行环境的可用内存资源数目,默认值是1024。</span><br><span class="line"></span><br><span class="line">readOnly: 是否只读默认是false-&gt;只读的缓存会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存会返回缓存对象的拷贝(映射数据库的实体类必须实现序列化) 。这会慢一些,但是安全,因此默认是 false</span><br></pre></td></tr></table></figure></li>
<li><p>二级缓存设置成功的标志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日志中会出现缓存命中率，并且在每一次查询结束之后都要提交事务,否则二级缓存不会起作用,缓存命中率不会发生变化.</span><br><span class="line"></span><br><span class="line">Cache Hit Ratio [com.im.mapper.UserMapper]: 0.0</span><br></pre></td></tr></table></figure>

<h3 id="10-4-集成第三方缓存ehcache"><a href="#10-4-集成第三方缓存ehcache" class="headerlink" title="10.4 集成第三方缓存ehcache"></a>10.4 集成第三方缓存ehcache</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用二级缓存产品ehcache步骤</span><br></pre></td></tr></table></figure></li>
<li><p>添加jar包或者依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ehcache-2.10.4.jar</span><br><span class="line">mybatis-ehcache-1.0.0.jar</span><br></pre></td></tr></table></figure></li>
<li><p>添加ehcache产品配置文件ehcache.xml</p>
</li>
<li><p>配置Ehcache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在SQL map 文件中配置&lt;cache/&gt;标签</span><br><span class="line"></span><br><span class="line"> &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;</span><br><span class="line"> 	&lt;!-- 缓存创建以后，最后一次访问缓存，间隔多久缓存失效(单位s) --&gt;</span><br><span class="line"> 	&lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line"> 	&lt;!-- 缓存创建日期起到失效时的时间间隔(单位s) --&gt;</span><br><span class="line"> 	&lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line"> 	&lt;!-- 堆内存中缓存对象数(0:没有限制) --&gt;</span><br><span class="line"> 	&lt;property name=&quot;maxEntriesLocalHeap&quot; value=&quot;1000&quot;/&gt;</span><br><span class="line"> 	&lt;!-- 磁盘中的对象数,默认为0不限制 --&gt;</span><br><span class="line"> 	&lt;property name=&quot;maxEntriesLocalDisk&quot; value=&quot;1000000&quot;/&gt;</span><br><span class="line"> 	&lt;!-- 内存存储与释放策略(FIFO:先进先出,LFU:一直以来最少被使用的,LRU:最近最少使用的) --&gt;</span><br><span class="line"> 	&lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt;</span><br><span class="line"> &lt;/cache&gt;</span><br></pre></td></tr></table></figure>

<h2 id="第十一章-MYSQL分页"><a href="#第十一章-MYSQL分页" class="headerlink" title="第十一章 MYSQL分页"></a>第十一章 MYSQL分页</h2></li>
</ul>
<h3 id="11-1-分页准备"><a href="#11-1-分页准备" class="headerlink" title="11.1 分页准备"></a>11.1 分页准备</h3><ul>
<li><p>操作数据库的接口代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 操作数据库表的接口</span><br><span class="line"> */</span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">	/*</span><br><span class="line">	 * 原生SQL分页</span><br><span class="line">	 * @Param:方法入参为多个时要使用此注解指定入参,否则mybatis表达式(#&#123;xxx&#125;)会找不到方法入参</span><br><span class="line">	 */</span><br><span class="line">	List&lt;User&gt; getUserPage(@Param(&quot;offset&quot;)int offset,@Param(&quot;pageSize&quot;)int pageSize);</span><br><span class="line">	/*</span><br><span class="line">	 * 分页插件分页</span><br><span class="line">	 */</span><br><span class="line">	List&lt;User&gt; getUserPage_();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注册接口的xml配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.im.mapper.UserMapper&quot;&gt;</span><br><span class="line">	&lt;!-- 原生分页 --&gt;</span><br><span class="line">	&lt;select id=&quot;getUserPage&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">		SELECT * FROM user LIMIT #&#123;offset&#125;,#&#123;pageSize&#125;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">	&lt;!-- 插件分页,pageHelper插件分页时,方法不需要传任何入参 --&gt;</span><br><span class="line">	&lt;select id=&quot;getUserPage_&quot; resultType=&quot;user&quot;&gt;</span><br><span class="line">		SELECT * FROM user</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-原生分页"><a href="#11-2-原生分页" class="headerlink" title="11.2 原生分页"></a>11.2 原生分页</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 原生分页</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetUserPage() throws IOException &#123;</span><br><span class="line">	//加载外部属性资源文件</span><br><span class="line">	InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">	//创建SqlSessionFactory</span><br><span class="line">	SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">	//创建SqlSession</span><br><span class="line">	SqlSession session = sessionFactory.openSession();</span><br><span class="line">	</span><br><span class="line">	UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">	int pageNo=3;//当前页</span><br><span class="line">	int pageSize=2;//每页显示的条数</span><br><span class="line">	//mysql分页的第一个参数,转换公式</span><br><span class="line">	int offset=(pageNo-1)*pageSize;</span><br><span class="line">	List&lt;User&gt; page = mapper.getUserPage(offset, pageSize);</span><br><span class="line">	System.out.println(page);</span><br><span class="line">	//提交</span><br><span class="line">	session.commit();</span><br><span class="line">	//关闭会话</span><br><span class="line">	session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="11-3-分页插件-PageHelper"><a href="#11-3-分页插件-PageHelper" class="headerlink" title="11.3 分页插件(PageHelper)"></a>11.3 分页插件(PageHelper)</h3><ul>
<li><p>添加jar包或者依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jsqlparser-0.9.5.jar</span><br><span class="line">pagehelper-5.1.2.jar</span><br></pre></td></tr></table></figure></li>
<li><p>在mybatis-config.xml中配置PageHelper</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置分页插件pageHelper --&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">	&lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;</span><br><span class="line">		&lt;!--</span><br><span class="line">			分页合理化参数，默认值为false。当该参数设置为 true 时， </span><br><span class="line">			pageNum&lt;=0 时会查询第一页， pageNum&gt;pages(超过总数时)， </span><br><span class="line">			会查询最后一页。默认false 时，直接根据参数进行查询</span><br><span class="line">		--&gt;</span><br><span class="line">		&lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">		&lt;!-- 支持合法的参数化,设置这个属性以及下面的属性,可以设置方法的入参 --&gt;</span><br><span class="line">		&lt;property name=&quot;supportMethodsArguments&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">		&lt;!-- 参数化的key值 --&gt;</span><br><span class="line">		&lt;property name=&quot;params&quot; value=&quot;pageNum=pageNumKey;pageSize=pageSizeKey;&quot;/&gt;</span><br><span class="line">	&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>Junit单元测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * pageHelper分页</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetUserPage_() throws IOException &#123;</span><br><span class="line">	//加载外部属性资源文件</span><br><span class="line">	InputStream in = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">	//创建SqlSessionFactory</span><br><span class="line">	SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">	//创建SqlSession</span><br><span class="line">	SqlSession session = sessionFactory.openSession();</span><br><span class="line">	UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">	//在查询全部数据之前直接调用PageHelper.startPage(2, 2);方法进行分页</span><br><span class="line">	//注意不能再两个方法之间插入其他的代码方法入参为第一个:pageNo；第二个:pageSize</span><br><span class="line">	PageHelper.startPage(2, 2);</span><br><span class="line">	List&lt;User&gt; page_ = mapper.getUserPage_();</span><br><span class="line">	for (User user : page_) &#123;</span><br><span class="line">		System.out.println(user);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//提交</span><br><span class="line">	session.commit();</span><br><span class="line">	//关闭会话</span><br><span class="line">	session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第十二章-mybatis和spring框架的整合"><a href="#第十二章-mybatis和spring框架的整合" class="headerlink" title="第十二章 mybatis和spring框架的整合"></a>第十二章 mybatis和spring框架的整合</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring + mybatis 框架整合</span><br><span class="line">整合步骤:</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建Java普通项目(因为没有页面所以不需要web项目)</p>
</li>
<li><p>添加jar包目或者maven依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commons-logging-1.2.jar</span><br><span class="line">druid-1.1.6.jar</span><br><span class="line">jsqlparser-0.9.5.jar</span><br><span class="line">log4j-1.2.17.jar</span><br><span class="line">mybatis-3.4.6.jar</span><br><span class="line">mybatis-spring-1.3.1.jar</span><br><span class="line">mysql-connector-java-5.1.7-bin.jar</span><br><span class="line">pagehelper-5.1.2.jar</span><br><span class="line">slf4j-api-1.7.25.jar</span><br><span class="line">slf4j-log4j12-1.7.25.jar</span><br><span class="line">spring-aop-4.3.10.RELEASE.jar</span><br><span class="line">spring-aspects-4.3.10.RELEASE.jar</span><br><span class="line">spring-beans-4.3.10.RELEASE.jar</span><br><span class="line">spring-context-4.3.10.RELEASE.jar</span><br><span class="line">spring-context-support-4.3.10.RELEASE.jar</span><br><span class="line">spring-core-4.3.10.RELEASE.jar</span><br><span class="line">spring-expression-4.3.10.RELEASE.jar</span><br><span class="line">spring-jdbc-4.3.10.RELEASE.jar</span><br><span class="line">spring-orm-4.3.10.RELEASE.jar</span><br><span class="line">spring-oxm-4.3.10.RELEASE.jar</span><br><span class="line">spring-test-4.3.10.RELEASE.jar</span><br><span class="line">spring-tx-4.3.10.RELEASE.jar</span><br></pre></td></tr></table></figure></li>
<li><p>创建jdbc.properties配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc_user=root</span><br><span class="line">jdbc_password=root</span><br><span class="line">jdbc_url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8</span><br></pre></td></tr></table></figure></li>
<li><p>创建mybatis-config.xml配置⽂件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">	&lt;settings&gt;</span><br><span class="line">		&lt;!-- 开启二级缓存 --&gt;</span><br><span class="line">		&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">		&lt;!-- 开启驼峰命名 --&gt;</span><br><span class="line">		&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">	&lt;/settings&gt;</span><br><span class="line">	&lt;!-- 配置分页插件pageHelper --&gt;</span><br><span class="line">	&lt;plugins&gt;</span><br><span class="line">		&lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;</span><br><span class="line">			&lt;!--</span><br><span class="line">				分页合理化参数，默认值为false。当该参数设置为 true 时， </span><br><span class="line">				pageNum&lt;=0 时会查询第一页， pageNum&gt;pages(超过总数时)， </span><br><span class="line">				会查询最后一页。默认false 时，直接根据参数进行查询</span><br><span class="line">			--&gt;</span><br><span class="line">			&lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">		&lt;/plugin&gt;</span><br><span class="line">	&lt;/plugins&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>创建applicationContext.xml配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">	xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span><br><span class="line">		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 1.导入外部属性资源文件 --&gt;</span><br><span class="line">	&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;</span><br><span class="line">	&lt;!-- 2.扫描需要扫描的包 --&gt;</span><br><span class="line">	&lt;context:component-scan base-package=&quot;com.sc&quot; /&gt;</span><br><span class="line">	&lt;!-- 3.配置数据库连接池 --&gt;</span><br><span class="line">	&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;</span><br><span class="line">		&lt;!-- 基本属性 url、user、password --&gt;</span><br><span class="line">		&lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc_url&#125;&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc_user&#125;&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc_password&#125;&quot; /&gt;</span><br><span class="line">		&lt;!-- 配置初始化大小、最小、最大 --&gt;</span><br><span class="line">		&lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;minIdle&quot; value=&quot;1&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt;</span><br><span class="line">		&lt;!-- 配置获取连接等待超时的时间 --&gt;</span><br><span class="line">		&lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt;</span><br><span class="line">		&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span><br><span class="line">		&lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt;</span><br><span class="line">		&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span><br><span class="line">		&lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;validationQuery&quot; value=&quot;SELECT &#x27;x&#x27;&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">		&lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;</span><br><span class="line">		&lt;property name=&quot;poolPreparedStatements&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;20&quot; /&gt;</span><br><span class="line">		&lt;!-- 配置监控统计拦截的filters --&gt;</span><br><span class="line">		&lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 4.配置SqlSessionFactory --&gt;</span><br><span class="line">	&lt;bean id=&quot;sqlSessionFactory&quot;</span><br><span class="line">		class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.sc.entity&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 5.配置平台事务管理理器器 --&gt;</span><br><span class="line">	&lt;bean id=&quot;transactionManager&quot;</span><br><span class="line">		class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">	&lt;!-- 6.开启基于注解的声明式事务 --&gt;</span><br><span class="line">	&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;</span><br><span class="line">		&lt;!-- 7.注册mybatis接⼝口加⼊入到Spring IOC容器器中 --&gt;</span><br><span class="line">	&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">		&lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;basePackage&quot; value=&quot;com.sc.mapper&quot; /&gt;</span><br><span class="line">		&lt;property name=&quot;annotationClass&quot; value=&quot;org.springframework.stereotype.Repository&quot; /&gt;</span><br><span class="line">	&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>添加log4j.xml配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;</span><br><span class="line">&lt;log4j:configuration</span><br><span class="line">	xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt;</span><br><span class="line">	&lt;appender name=&quot;STDOUT&quot;</span><br><span class="line">		class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;</span><br><span class="line">		&lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt;</span><br><span class="line">		&lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">			&lt;param name=&quot;ConversionPattern&quot;</span><br><span class="line">				value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m  (%F:%L) \n&quot; /&gt;</span><br><span class="line">		&lt;/layout&gt;</span><br><span class="line">	&lt;/appender&gt;</span><br><span class="line">	&lt;logger name=&quot;java.sql&quot;&gt;</span><br><span class="line">		&lt;level value=&quot;debug&quot; /&gt;</span><br><span class="line">	&lt;/logger&gt;</span><br><span class="line">	&lt;logger name=&quot;org.apache.ibatis&quot;&gt;</span><br><span class="line">		&lt;level value=&quot;debug&quot; /&gt;</span><br><span class="line">	&lt;/logger&gt;</span><br><span class="line">	&lt;root&gt;</span><br><span class="line">		&lt;level value=&quot;debug&quot; /&gt;</span><br><span class="line">		&lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">	&lt;/root&gt;</span><br><span class="line">&lt;/log4j:configuration&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第十三章-spring框架的单元测试"><a href="#第十三章-spring框架的单元测试" class="headerlink" title="第十三章 spring框架的单元测试"></a>第十三章 spring框架的单元测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring和mybatis框架整合完成之后，需要测试整合是否成功,接下来需要进行测试,测试采用spring框架的spring-tx-4.3.10.RELEASE.jar 依赖进行单元测试.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用mybatis上面的例子进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations= &#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span><br><span class="line">public class UserMapperTest &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private UserMapper userMapper;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void test01() &#123;</span><br><span class="line">		List&lt;User&gt; users = userMapper.getUsers();</span><br><span class="line">		System.out.println(users);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第十四章-mybatis映射MYSQL5-7新增的JSON数据类型"><a href="#第十四章-mybatis映射MYSQL5-7新增的JSON数据类型" class="headerlink" title="第十四章 mybatis映射MYSQL5.7新增的JSON数据类型"></a>第十四章 mybatis映射MYSQL5.7新增的JSON数据类型</h2><h3 id="14-1-mybatis-5-7-json数据类型介绍"><a href="#14-1-mybatis-5-7-json数据类型介绍" class="headerlink" title="14.1 mybatis 5.7 json数据类型介绍"></a>14.1 mybatis 5.7 json数据类型介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MYSQL5.7的GA版本开始支持json格式的数据</span><br><span class="line">json格式有两种一种单个对象&#123;&#125;;另一种就是集合格式[]</span><br></pre></td></tr></table></figure>

<h3 id="14-2-Java对象和json数据的互通"><a href="#14-2-Java对象和json数据的互通" class="headerlink" title="14.2 Java对象和json数据的互通"></a>14.2 Java对象和json数据的互通</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">看看mybatis是怎么实现将Java的对象保存到数据库中的json数据格式,又怎么将数据库中的json数据格式查询出来保存成Java对象</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建数据库表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tb_order(</span><br><span class="line">    `order_id` INT NOT NULL PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    `users` json NOT NULL,</span><br><span class="line">    `user` json NOT NULL</span><br><span class="line">)ENGINE=InnoDB AUTO_INCREMENT=1000 DEFAULT CHARSET=UTF8;</span><br></pre></td></tr></table></figure></li>
<li><p>创建映射数据库表的Java实体类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//测试数据库两种数据类型</span><br><span class="line">public class Order &#123;</span><br><span class="line"></span><br><span class="line">	private Integer orderId;</span><br><span class="line">    //[&#123;&quot;id&quot;:1001,&quot;name&quot;:&quot;李雷&quot;&#125;,&#123;&quot;id&quot;:1001,&quot;name&quot;:&quot;李雷&quot;&#125;]</span><br><span class="line">	private List&lt;User&gt; users;</span><br><span class="line">    //&#123;&quot;id&quot;:1001,&quot;name&quot;:&quot;李雷&quot;&#125;</span><br><span class="line">	private User user;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">	// 用户ID</span><br><span class="line">	private Integer userId;</span><br><span class="line">	// 用户名</span><br><span class="line">	private String userName;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建自定义类型转换器进行JSON和POJO的转换</p>
</li>
<li><ul>
<li><p>集合类型处理器(处理集合数据) JsonArrayTypeHandler.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.sql.CallableStatement;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.type.BaseTypeHandler;</span><br><span class="line">import org.apache.ibatis.type.JdbcType;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.im.entity.User;</span><br><span class="line">/*</span><br><span class="line"> * 数组类型的相互转换</span><br><span class="line"> * JSON转换使用的是阿里巴巴的fastjson</span><br><span class="line"> */</span><br><span class="line">public class JsonArrayTypeHandler extends BaseTypeHandler&lt;List&lt;User&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * 使用列名获取数据库中保存的json数据</span><br><span class="line">	 * 并将其数据类型转换成List集合</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public List&lt;User&gt; getNullableResult(ResultSet arg0, String arg1) throws SQLException &#123;</span><br><span class="line">		String string = arg0.getString(arg1);</span><br><span class="line">		return JSON.parseObject(string, List.class);</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 使用索引获取数据库中保存的json数据</span><br><span class="line">	 * 并将其数据类型转换成List集合</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public List&lt;User&gt; getNullableResult(ResultSet arg0, int arg1) throws SQLException &#123;</span><br><span class="line">		String string = arg0.getString(arg1);</span><br><span class="line">		return JSON.parseObject(string, List.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 使用索引获取数据库中保存的json数据</span><br><span class="line">	 * 并将其数据类型转换成List集合</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public List&lt;User&gt; getNullableResult(CallableStatement arg0, int arg1) throws SQLException &#123;</span><br><span class="line">		String string = arg0.getString(arg1);</span><br><span class="line">		return JSON.parseObject(string,List.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 将集合的实体对象转换成JSON保存到数据库中</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public void setNonNullParameter(PreparedStatement arg0, int arg1, List&lt;User&gt; arg2, JdbcType arg3)</span><br><span class="line">			throws SQLException &#123;</span><br><span class="line">		arg0.setString(arg1, JSON.toJSONString(arg2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>单个对象处理器(处理单个对象) JsonTypeHandler.java</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.sql.CallableStatement;</span><br><span class="line">import java.sql.PreparedStatement;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.type.BaseTypeHandler;</span><br><span class="line">import org.apache.ibatis.type.JdbcType;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.im.entity.User;</span><br><span class="line">/**</span><br><span class="line"> * 自定义类型处理器</span><br><span class="line"> * @author hushuang</span><br><span class="line"> * json转换使用阿里巴巴的fastjson</span><br><span class="line"> */</span><br><span class="line">public class JsonTypeHandler extends BaseTypeHandler&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public User getNullableResult(ResultSet arg0, String arg1) throws SQLException &#123;</span><br><span class="line">		return JSON.parseObject(arg0.getString(arg1), User.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public User getNullableResult(ResultSet arg0, int arg1) throws SQLException &#123;</span><br><span class="line">		return JSON.parseObject(arg0.getString(arg1), User.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public User getNullableResult(CallableStatement arg0, int arg1) throws SQLException &#123;</span><br><span class="line">		return JSON.parseObject(arg0.getString(arg1), User.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void setNonNullParameter(PreparedStatement arg0, int arg1, User arg2, JdbcType arg3) throws SQLException &#123;</span><br><span class="line">		arg0.setString(arg1, JSON.toJSONString(arg2));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><ul>
<li><p>注册自定义类型转换器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在mybatis-config.xml配置文件中注册</span><br><span class="line"></span><br><span class="line">&lt;typeHandlers&gt;</span><br><span class="line">	&lt;typeHandler handler=&quot;com.im.handler.JsonTypeHandler&quot; /&gt;</span><br><span class="line">	&lt;typeHandler handler=&quot;com.im.handler.JsonArrayTypeHandler&quot; /&gt;</span><br><span class="line">&lt;/typeHandlers&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建注解操作接口的xml配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.im.mapper.OrderMapper&quot;&gt;</span><br><span class="line">	&lt;!-- 测试插入 --&gt;</span><br><span class="line">	&lt;insert id=&quot;addOrder&quot; parameterType=&quot;order&quot;&gt;</span><br><span class="line">		INSERT INTO tb_order(users,user) </span><br><span class="line">		VALUES(#&#123;users,typeHandler=com.im.handler.JsonArrayTypeHandler&#125;,#&#123;user,typeHandler=com.im.handler.JsonTypeHandler&#125;)</span><br><span class="line">	&lt;/insert&gt;</span><br><span class="line">	&lt;!-- 测试查询 --&gt;</span><br><span class="line">	&lt;resultMap type=&quot;order&quot; id=&quot;orderMap&quot;&gt;</span><br><span class="line">		&lt;id property=&quot;orderId&quot; column=&quot;order_id&quot;/&gt;</span><br><span class="line">		&lt;result property=&quot;users&quot; column=&quot;users&quot; typeHandler=&quot;com.im.handler.JsonArrayTypeHandler&quot;/&gt;</span><br><span class="line">		&lt;result property=&quot;user&quot; column=&quot;user&quot; typeHandler=&quot;com.im.handler.JsonTypeHandler&quot;/&gt;</span><br><span class="line">	&lt;/resultMap&gt;</span><br><span class="line">	&lt;select id=&quot;getOrder&quot; resultMap=&quot;orderMap&quot;&gt;</span><br><span class="line">		SELECT * FROM tb_order WHERE order_id=#&#123;id&#125;</span><br><span class="line">	&lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>单元测试(略)</p>
</li>
</ul>
<hr>
<h2 id="第十五章-相关文档"><a href="#第十五章-相关文档" class="headerlink" title="第十五章 相关文档"></a>第十五章 相关文档</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mybatis中文官网地址:https://mybatis.org/mybatis-3/zh/index.html</span><br><span class="line">Druid中文官网地址:https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98</span><br><span class="line">pageHelper官网地址:https://pagehelper.github.io/docs/howtouse/</span><br><span class="line">ehcache 官网地址:http://mybatis.org/ehcache-cache/</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/2021/08/08/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8RabbitMQ/</url>
    <content><![CDATA[<hr>
<h2 id="第一章-RabbitMQ介绍"><a href="#第一章-RabbitMQ介绍" class="headerlink" title="第一章 RabbitMQ介绍"></a>第一章 RabbitMQ介绍</h2><h3 id="第1节-MQ是什么"><a href="#第1节-MQ是什么" class="headerlink" title="第1节 MQ是什么"></a>第1节 MQ是什么</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 消息队列(Message Queue),又叫做消息中间件</span><br><span class="line">2. 用高效可靠的消息传递机制进行与平台无关的数据交流,并基于数据通信来进行分布式系统的集成</span><br><span class="line">3. 通过提供消息传递和消息队列模型,可以在分布式环境下扩展进程的通信</span><br><span class="line">4. MQ 是用来解决通信的问题,主要用来帮我们存储和转发消息</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第2节-MQ-的主要特点"><a href="#第2节-MQ-的主要特点" class="headerlink" title="第2节 MQ 的主要特点"></a>第2节 MQ 的主要特点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 是一个独立运行的服务.生产者发送消息,消费者接收消费,需要先跟服务器建立连接</span><br><span class="line">2. 采用队列作为数据结构,有先进先出的特点</span><br><span class="line">3. 具有发布/订阅的模型,消费者可以获取自己需要的消息</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第3节-RabbitMQ介绍"><a href="#第3节-RabbitMQ介绍" class="headerlink" title="第3节 RabbitMQ介绍"></a>第3节 RabbitMQ介绍</h3><ul>
<li>官网地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.rabbitmq.com/</span><br><span class="line">官网介绍: RabbitMQ is the most widely deployed open source message broker</span><br><span class="line">中文解释: RabbitMQ 是部署最广泛的开源消息队列代理服务器</span><br><span class="line"></span><br><span class="line">RabbitMQ是一个开源的AMQP(高级消息队列协议)实现,服务器端用Erlang语言编写,支持多种客户端,如:Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第二章-RabbitMQ安装-Docker"><a href="#第二章-RabbitMQ安装-Docker" class="headerlink" title="第二章 RabbitMQ安装(Docker)"></a>第二章 RabbitMQ安装(Docker)</h2><h3 id="第1节-安装步骤"><a href="#第1节-安装步骤" class="headerlink" title="第1节 安装步骤"></a>第1节 安装步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 首先就是查询镜像,我们要用带有management版本的，此版本是带有管理界面的</span><br><span class="line">    </span><br><span class="line">    docker search rabbitmq:management</span><br><span class="line"></span><br><span class="line">2. 拉取镜像</span><br><span class="line"></span><br><span class="line">    docker pull rabbitmq:management</span><br><span class="line"></span><br><span class="line">3. 查看已下载的rabbitmq镜像</span><br><span class="line"></span><br><span class="line">    docker images</span><br><span class="line"></span><br><span class="line">4. 运行RabbitMQ服务器</span><br><span class="line"></span><br><span class="line">    docker run –name rabbitmq-server -d -p 15672:15672 -p 5672:5672 rabbitmq:management</span><br><span class="line">    </span><br><span class="line">    4.1 –name指定了容器名称</span><br><span class="line">    4.2 -d 指定容器以后台守护进程方式运行</span><br><span class="line">    4.3 -p指定容器内部端口号与宿主机之间的映射，rabbitmq默认要使用15672为其web端界面访问时端口，5672为数据通信端口</span><br><span class="line"></span><br><span class="line">5. 执行docker ps 命令查看当前运行服务器列表</span><br><span class="line"></span><br><span class="line">6. 查看启动的RabbitMQ服务器日志命令</span><br><span class="line">    </span><br><span class="line">    docker logs -f 容器ID</span><br><span class="line">    </span><br><span class="line">    从打印的日志中可以发现这几句日志信息</span><br><span class="line">    Creating user ‘guest’ // 默认创建了用户名 guest</span><br><span class="line">    Setting user tags for user ‘guest’ to [administrator] // 添加了administrator角色</span><br><span class="line">    Setting permissions for ‘guest’ in ‘/‘ to ‘.‘, ‘.‘, ‘.*’ // 密码为 guest</span><br><span class="line"></span><br><span class="line">7. 访问RabbitMQ的web管理页面</span><br><span class="line"></span><br><span class="line">    在浏览器中输入: http://192.168.1.129:15672</span><br><span class="line">    </span><br><span class="line">    192.168.1.129是我的主机IP,换成个人的IP地址即可</span><br><span class="line">    输入默认创建的用户名和密码 guest guest</span><br></pre></td></tr></table></figure>

<p><a href="https://note.youdao.com/yws/api/personal/file/D076E449167648528F050D3073B89206?method=download&shareKey=024152ae70e2306af337b15040844d3b"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/D076E449167648528F050D3073B89206?method=download&shareKey=024152ae70e2306af337b15040844d3b" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="RabbitMQ-success"></a></p>
<hr>
<h3 id="第2节-用户管理"><a href="#第2节-用户管理" class="headerlink" title="第2节 用户管理"></a>第2节 用户管理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给RabbitMQ服务器添加新用户并且赋予权限</span><br><span class="line">    </span><br><span class="line">    1. 进入容器</span><br><span class="line">        docker exec -i -t 0e7e57214cfb bin/bash 通过容器ID进入容器内部</span><br><span class="line">        </span><br><span class="line">    2. 添加用户名和密码都是root的用户</span><br><span class="line">        rabbitmqctl add_user root root</span><br><span class="line">    </span><br><span class="line">    3. 赋予root用户所有权限</span><br><span class="line">        rabbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">    </span><br><span class="line">    4. 赋予root用户administrator角色</span><br><span class="line">        rabbitmqctl set_user_tags root administrator</span><br><span class="line">    </span><br><span class="line">    5. 查看所有用户列表,即可看到我们添加的root</span><br><span class="line">        rabbitmqctl list_users</span><br><span class="line">    </span><br><span class="line">    6. 回到我们的web管理页面,将原有的用户注销,使用新创建的root用户登录测试</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第三章-RabbitMQ架构及通讯范式"><a href="#第三章-RabbitMQ架构及通讯范式" class="headerlink" title="第三章 RabbitMQ架构及通讯范式"></a>第三章 RabbitMQ架构及通讯范式</h2><h3 id="第1节-RabbitMQ的整体架构图"><a href="#第1节-RabbitMQ的整体架构图" class="headerlink" title="第1节 RabbitMQ的整体架构图"></a>第1节 RabbitMQ的整体架构图</h3><table>
<thead>
<tr>
<th align="left">架构</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://note.youdao.com/yws/api/personal/file/8863E25C1B284CC1A8970B4B57E836E6?method=download&shareKey=e86315ae9c7142836439b405eeb18ba7"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/8863E25C1B284CC1A8970B4B57E836E6?method=download&shareKey=e86315ae9c7142836439b405eeb18ba7" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="RabbitMQ"></a></td>
</tr>
</tbody></table>
<hr>
<ul>
<li>Producer</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息发布者,主要用来进行消息发布</span><br></pre></td></tr></table></figure>

<ul>
<li>Exchange</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">交换器,消息发布者将消息发送给交换器,交换器在通过路由发送到队列中</span><br></pre></td></tr></table></figure>

<ul>
<li>Queue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">保存消息</span><br></pre></td></tr></table></figure>

<ul>
<li>Customer</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息消费者</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个消息(message)从开始到结束的过程</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息(message)被发布者(Producer)发送给交换器(exchange)然后交换机将收到的消息根据路由规则分发给绑定的队列(queue)最后将消息投递给订阅了此队列的消费者(consumer),或者消费者按照需求自行获取</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第四章-快速入门-RabbitMQ-HelloWorld"><a href="#第四章-快速入门-RabbitMQ-HelloWorld" class="headerlink" title="第四章 快速入门(RabbitMQ-HelloWorld)"></a>第四章 快速入门(RabbitMQ-HelloWorld)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RabbitMQ快速入门,使用Java语言来向RabbitMQ服务器发送和消费消息</span><br></pre></td></tr></table></figure>

<h3 id="第1节-原理图"><a href="#第1节-原理图" class="headerlink" title="第1节 原理图"></a>第1节 原理图</h3><table>
<thead>
<tr>
<th align="left">HelloWorld</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://note.youdao.com/yws/api/personal/file/73FEFD26A1A9415DAFA7FAA35666DB2E?method=download&shareKey=a214ae16b858ce24c5bc0bf89125cff0"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/73FEFD26A1A9415DAFA7FAA35666DB2E?method=download&shareKey=a214ae16b858ce24c5bc0bf89125cff0" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="python-one"></a></td>
</tr>
</tbody></table>
<ul>
<li>P: producer 生产者</li>
<li>C: consumer 消费者</li>
<li>中间红色的部分是一个队列,在RabbitMQ中代表消息缓冲区</li>
</ul>
<hr>
<h3 id="第2节-客户端依赖"><a href="#第2节-客户端依赖" class="headerlink" title="第2节 客户端依赖"></a>第2节 客户端依赖</h3><blockquote>
<p>在编写Java代码之前首先需要创建Java项目并且添加maven依赖,使用的是5.8.0版本的MQ客户端</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.8.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">依赖添加完成之后就是编写代码</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第3节-消息发布"><a href="#第3节-消息发布" class="headerlink" title="第3节 消息发布"></a>第3节 消息发布</h3><ul>
<li>代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 向队列中发送一个消息</span><br><span class="line"> */</span><br><span class="line">public class ProducerMessage &#123;</span><br><span class="line">    //声明一个队列名称</span><br><span class="line">    private static final String QUEUE_NAME=&quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,false,false,false,null);</span><br><span class="line">        //构建一个消息</span><br><span class="line">        String message = &quot;Hello RabbitMQ&quot;;</span><br><span class="line">        /*</span><br><span class="line">            向队列中发送上面的message消息</span><br><span class="line">            里面涉及到两个参数</span><br><span class="line">            第2个参数  routingKey : 指定发送队列的名称</span><br><span class="line">            第4个参数  body       : 设置需要发送的消息,byte数组格式</span><br><span class="line">            其它参数会在后面介绍其它功能时详解</span><br><span class="line">         */</span><br><span class="line">        channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes());</span><br><span class="line">        System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        //关闭频道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>控制台查看</li>
</ul>
<table>
<thead>
<tr>
<th align="left">管理页面</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://note.youdao.com/yws/api/personal/file/857866450CCF4C4EB915A1D2520023FF?method=download&shareKey=ab85826f124ccb750b8a0a49ee90389e"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/857866450CCF4C4EB915A1D2520023FF?method=download&shareKey=ab85826f124ccb750b8a0a49ee90389e" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="RabbitMQ-info1"></a></td>
</tr>
<tr>
<td align="left"><a href="https://note.youdao.com/yws/api/personal/file/8112AB223BD9422EBC756A94F0A84D56?method=download&shareKey=9c582e5c4c58c616463ec1b95cb15107"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/8112AB223BD9422EBC756A94F0A84D56?method=download&shareKey=9c582e5c4c58c616463ec1b95cb15107" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="RabbitMQ-info2"></a></td>
</tr>
</tbody></table>
<hr>
<h3 id="第4节-消息消费"><a href="#第4节-消息消费" class="headerlink" title="第4节 消息消费"></a>第4节 消息消费</h3><ul>
<li>代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从队列中获取消息</span><br><span class="line"> */</span><br><span class="line">public class ConsumerMessage &#123;</span><br><span class="line">    //声明要获取消息的队列名称</span><br><span class="line">    private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,false,false,false,null);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot; [x] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        /*</span><br><span class="line">            消费队列里面的消息</span><br><span class="line">            参数介绍: 暂时只关注第1、3、4这三个参数,第二个参数在下面的案例中会介绍到</span><br><span class="line">            第1个参数: 设置待消费的队列名称</span><br><span class="line">            第3个参数: 当消息被传递过来时，回调</span><br><span class="line">            第4个参数: 当消费者被意外取消或关闭时回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,true,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>控制台查看</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当消费完成在回到RabbitMQ的web管理页面查看消息,会发队列中的消息已经被消费</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注意</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在启动代码的时候先启动消费者,后启动提供者,先启动消费者创建队列,后启动发布者向队列中发布数据</span><br><span class="line">当前入门的例子,因为手动创建了具体的队列所以不会出现发送消息到指定队列不存在的问题,但是接下来后面的练习可能会出错.</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="第五章-工作队列-RabbitMQ-Work"><a href="#第五章-工作队列-RabbitMQ-Work" class="headerlink" title="第五章 工作队列(RabbitMQ-Work)"></a>第五章 工作队列(RabbitMQ-Work)</h2><h3 id="第1节-原理图-1"><a href="#第1节-原理图-1" class="headerlink" title="第1节 原理图"></a>第1节 原理图</h3><p><a href="https://note.youdao.com/yws/api/personal/file/4206F7B415534996A787434BF870F1BF?method=download&shareKey=cde013258e1b91a4d13683ffe7285112"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/4206F7B415534996A787434BF870F1BF?method=download&shareKey=cde013258e1b91a4d13683ffe7285112" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="python-two"></a></p>
<hr>
<h3 id="第2节-Work-工作队列-介绍"><a href="#第2节-Work-工作队列-介绍" class="headerlink" title="第2节 Work(工作队列)介绍"></a>第2节 Work(工作队列)介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HelloWorld入门的例子介绍了我们提供者向队列中发送一个消息,消费者从队列中取出消息消费;接下来我们将要创建一个工作队列,用来在多个消费者(consumer)之间分发任务,然后观察,我们分发的任务在多个工作者之间是怎么进行消费的</span><br></pre></td></tr></table></figure>

<ul>
<li><p>工作队列(任务队列)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如消息提供者将消息发送到任务队列中,根据上面图示,任务队列会被多个消费者(consumer)连接,这时候如果我们向任务队列中发送多个任务,这些任务会被所有的消费者(consumer)共享,那么问题来了,这个任务队列是怎么将任务合理的分配给消费者(consumer)进行消费的.</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第3节-Work-工作队列-实现"><a href="#第3节-Work-工作队列-实现" class="headerlink" title="第3节 Work(工作队列)实现"></a>第3节 Work(工作队列)实现</h3><ul>
<li>需求举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">消息发布者: 向队列中发送多条消息(比如我这里发送10条消息)</span><br><span class="line">消息消费者: 创建多个消费者验证,查看每个消费者处理的消息任务数(我这里创建两个消费者)</span><br></pre></td></tr></table></figure>

<ul>
<li>消息发布代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 向工作队列中发送消息</span><br><span class="line"> */</span><br><span class="line">public class ProducerWorkMessage &#123;</span><br><span class="line">    //声明一个队列名称</span><br><span class="line">    private static final String QUEUE_NAME=&quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,false,false,false,null);</span><br><span class="line">        //构建10条消息并且发送到队列</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            String message = &quot;Hello RabbitMQ i=&quot;+i;</span><br><span class="line">            channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes());</span><br><span class="line">            System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭频道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息消费代码(下面是两个消费者)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//消费者1</span><br><span class="line">/**</span><br><span class="line"> * 从队列中获取消息</span><br><span class="line"> */</span><br><span class="line">public class ConsumerWorkMessage1 &#123;</span><br><span class="line">    //声明要获取消息的队列名称</span><br><span class="line">    private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,false,false,false,null);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot; [x] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        /*</span><br><span class="line">            消费队列里面的消息</span><br><span class="line">            参数介绍: 暂时只关注第1、3、4这三个参数,第二个参数在下面的案例中会介绍到</span><br><span class="line">            第1个参数: 设置待消费的队列名称</span><br><span class="line">            第3个参数: 当消息被传递过来时，回调</span><br><span class="line">            第4个参数: 当消费者被意外取消或关闭时回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,true,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//消费者2</span><br><span class="line">/**</span><br><span class="line"> * 从队列中获取消息</span><br><span class="line"> */</span><br><span class="line">public class ConsumerWorkMessage2 &#123;</span><br><span class="line">    //声明要获取消息的队列名称</span><br><span class="line">    private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,false,false,false,null);</span><br><span class="line">        </span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot; [x] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        /*</span><br><span class="line">            消费队列里面的消息</span><br><span class="line">            参数介绍: 暂时只关注第1、3、4这三个参数,第二个参数在下面的案例中会介绍到</span><br><span class="line">            第1个参数: 设置待消费的队列名称</span><br><span class="line">            第3个参数: 当消息被传递过来时，回调</span><br><span class="line">            第4个参数: 当消费者被意外取消或关闭时回调</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,true,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果展示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上面代码所得的结果显示: </span><br><span class="line"></span><br><span class="line">消息发布者发送的10条消息:</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=0&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=1&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=2&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=3&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=4&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=5&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=6&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=7&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=8&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=9&#x27;</span><br><span class="line"></span><br><span class="line">消费者1消费的消息: 1,3,5,7,9</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=1&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=3&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=5&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=7&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=9&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">消费者2消费的消息: 0,2,4,6,8</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=0&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=2&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=4&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=6&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=8&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>结果分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 通过上面的结果可以看出发布者发布消息会平均分配给每一个消费者,采用默认的任务分发机制(轮询)</span><br><span class="line">2. 这种方式有优点当然也有缺点</span><br><span class="line">    2.1 优点: 可以轻易的并行工作,如果我们积压很多任务，我们可以通过增加工作者(consumer)来解决这一问题,使得系统的伸缩性更强</span><br><span class="line">    2.2 缺点: 这种分发机制没有考虑处理处理任务的时间问题(因为他分配任务的时候是一次性分配,并非是一个一个分配),按照轮询的方式将任务等分给了两个消费者,可能某一个消费者性能比较差,累积任务会越来越多,所以一直忙个不停;而另一个消费者性能比较好,处理任务块,可能闲的不行,这就造成了资源浪费</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    怎么解决这个问题呢? ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓ 向下看 ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="第4节-Fair-dispatch-公平分发"><a href="#第4节-Fair-dispatch-公平分发" class="headerlink" title="第4节 Fair dispatch(公平分发)"></a>第4节 Fair dispatch(公平分发)</h3><h4 id="4-1-原理图"><a href="#4-1-原理图" class="headerlink" title="4.1 原理图"></a>4.1 原理图</h4><table>
<thead>
<tr>
<th align="left">公平分发</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://note.youdao.com/yws/api/personal/file/BF2A1C28FB224A9CB377B696083EBD23?method=download&shareKey=6faeae09766496483f4324d86177b69b"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/BF2A1C28FB224A9CB377B696083EBD23?method=download&shareKey=6faeae09766496483f4324d86177b69b" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="python-eight"></a></td>
</tr>
</tbody></table>
<hr>
<h4 id="4-2-公平分发原则"><a href="#4-2-公平分发原则" class="headerlink" title="4.2 公平分发原则"></a>4.2 公平分发原则</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上面的轮询机制会造成资源浪费的问题,原因是因为RabbitMQ在分发任务的时候盲目的一次性平均分配任务,它不看消费者是否应答(分发给消费者的任务后,不看消费者是否完成,直接在分配，这样就造成了累积),为了解决这个问题,RabbitMQ提供了一个方法来解决</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int prefetchCount = 1;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br><span class="line"></span><br><span class="line">这段代码的意义就是来限制RabbitMQ只发不超过1条的消息给同一个消费者,且当消息处理完毕后,有了反馈,才会进行第二次发送.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当然在使用basicQos方法的时候还需要设置两个参数</span><br><span class="line">1、设置autoAck为false channel.basicConsume(QUEUE_NAME,false,deliverCallback,consumerTag -&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">2、在从MQ获取到消息之后设置 channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);</span><br><span class="line"></span><br><span class="line">这两个参数的意义: </span><br><span class="line">    autoAck: 设置应答模式,默认是自动应答</span><br><span class="line">        - 自动应答:只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费</span><br><span class="line">        - 手动应答:消费者从队列中获取消息后,服务器会将该消息标记为不可用状态，等待消费者的反馈,如果消费者一直没有反馈,那么该消息将一直处于不可用状态,打开手动确认还有一个好处就是当消费者不正常死亡(通道关闭,连接关闭或TCP连接丢失),RabbitMQ会将这个消息进行重新加入队列进行排队.当然如果正常消费,RabbitMQ就会正常删除掉他.</span><br><span class="line">        - 当使用公平分发的时候,必须取消自动应答模式,改为手动应答模式.</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h4><ul>
<li>消息发布代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 向任务队列中发送消息</span><br><span class="line"> */</span><br><span class="line">public class ProducerWorkMessage &#123;</span><br><span class="line">    //声明一个队列名称</span><br><span class="line">    private static final String QUEUE_NAME=&quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,false,false,false,null);</span><br><span class="line"></span><br><span class="line">        //限制发送消息给同一个消费者不得超过一条</span><br><span class="line">        int prefetchCount = 1;</span><br><span class="line">        channel.basicQos(prefetchCount);</span><br><span class="line"></span><br><span class="line">        //构建10条消息并且发送到队列</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            String message = &quot;Hello RabbitMQ i=&quot;+i;</span><br><span class="line">            channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes());</span><br><span class="line">            System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭频道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息消费代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消费者1</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从队列中获取消息</span><br><span class="line"> */</span><br><span class="line">public class ConsumerWorkMessage1 &#123;</span><br><span class="line">    //声明要获取消息的队列名称</span><br><span class="line">    private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,false,false,false,null);</span><br><span class="line">        //保证发送给消费者的消息只分发一次</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot; [x] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">            //开启手动消息应答</span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);</span><br><span class="line">        &#125;;</span><br><span class="line">        /*</span><br><span class="line">            消费队列里面的消息</span><br><span class="line">            参数介绍: 这里只说第2个参数，其他参数前面已经说过</span><br><span class="line">            第2个参数 autoAck : false</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,false,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//消费者2</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从队列中获取消息</span><br><span class="line"> */</span><br><span class="line">public class ConsumerWorkMessage2 &#123;</span><br><span class="line">    //声明要获取消息的队列名称</span><br><span class="line">    private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个队列,现在只关注第1个参数,队列名称,后面其他参数会在下面的例子中一个个讲解</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,false,false,false,null);</span><br><span class="line">        //保证发送给消费者的消息只分发一次</span><br><span class="line">        channel.basicQos(1);</span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot; [x] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">            //给一个消费者开启一点延时,模拟性能问题</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            //开启手动消息应答</span><br><span class="line">            channel.basicAck(delivery.getEnvelope().getDeliveryTag(),false);</span><br><span class="line">        &#125;;</span><br><span class="line">        /*</span><br><span class="line">            消费队列里面的消息</span><br><span class="line">            参数介绍: 这里只说第2个参数，其他参数前面已经说过</span><br><span class="line">            第2个参数 autoAck : false</span><br><span class="line">         */</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,false,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果展示</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">运行上面的代码打印出来的消息为:</span><br><span class="line"></span><br><span class="line">消息提供者:发送10条消息</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=0&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=1&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=2&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=3&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=4&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=5&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=6&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=7&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=8&#x27;</span><br><span class="line">    [x] Sent &#x27;Hello RabbitMQ i=9&#x27;</span><br><span class="line"></span><br><span class="line">消息消费者1:(消费者1具体处理几条不一定)</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=1&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=2&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=4&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=5&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=6&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=8&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=9&#x27;</span><br><span class="line"></span><br><span class="line">消息消费者2:(消费者2具体处理几条不一定)</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=0&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=3&#x27;</span><br><span class="line">    [x] Received &#x27;Hello RabbitMQ i=7&#x27;</span><br><span class="line"></span><br><span class="line">通过以上代码运行可以看出不在是基本的轮询，而是采用了公平分发的原则。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第5节-消息队列的持久化"><a href="#第5节-消息队列的持久化" class="headerlink" title="第5节 消息队列的持久化"></a>第5节 消息队列的持久化</h3><h4 id="5-1-消息持久化介绍"><a href="#5-1-消息持久化介绍" class="headerlink" title="5.1 消息持久化介绍"></a>5.1 消息持久化介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上面介绍的队列都是在RabbitMQ退出或者崩溃时就会消失的队列,如果当时队列里面还有消息未被消费,那么异常退出会造成任务丢失,怎么保证就算RabbitMQ意外退出,也不会造成队列中的任务丢失呢,这回就用到了消息队列的持久化.</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-2-消息持久化设置"><a href="#5-2-消息持久化设置" class="headerlink" title="5.2 消息持久化设置"></a>5.2 消息持久化设置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置持久化队列比较简单只需要在提供者和消费者都设置</span><br><span class="line">//第二个参数设置为true</span><br><span class="line">channel.queueDeclare(QUEUE_NAME,true,false,false,null);</span><br><span class="line"></span><br><span class="line">这样当我们消息发布者发布一条消息之后然后重启docker RabbitMQ服务器,查看web管理页面会发现,消息还在</span><br><span class="line"></span><br><span class="line">重启docker容器的命令: docker container restart bf44c7a5089a</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-3-消息持久化实现"><a href="#5-3-消息持久化实现" class="headerlink" title="5.3 消息持久化实现"></a>5.3 消息持久化实现</h4><ul>
<li>消息发送代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 向队列中发送一个消息</span><br><span class="line"> */</span><br><span class="line">public class ProducerMessage &#123;</span><br><span class="line">    //声明一个队列名称</span><br><span class="line">    private static final String QUEUE_NAME=&quot;hello&quot;;</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        /*</span><br><span class="line">            声明一个持久化队列</span><br><span class="line">            参数说明:第2个参数: durable: 设置为true,这时我们声明的队列就是一个持久化队列</span><br><span class="line">         */</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,true,false,false,null);</span><br><span class="line">        //构建一个消息</span><br><span class="line">        String message = &quot;Hello RabbitMQ&quot;;</span><br><span class="line">        channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.getBytes());</span><br><span class="line">        System.out.println(&quot; [x] Sent &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        //关闭频道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息消费代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 从队列中获取消息</span><br><span class="line"> */</span><br><span class="line">public class ConsumerMessage &#123;</span><br><span class="line">    //声明要获取消息的队列名称</span><br><span class="line">    private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个队列,第2个参数,设置为true声明一个持久化队列</span><br><span class="line">        channel.queueDeclare(QUEUE_NAME,true,false,false,null);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot; [x] Received &#x27;&quot; + message + &quot;&#x27;&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,true,deliverCallback,consumerTag -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第六章-发布-订阅-RabbitMQ-Publish-amp-Subscribe"><a href="#第六章-发布-订阅-RabbitMQ-Publish-amp-Subscribe" class="headerlink" title="第六章 发布/订阅(RabbitMQ-Publish&amp;Subscribe)"></a>第六章 发布/订阅(RabbitMQ-Publish&amp;Subscribe)</h2><h3 id="第1节-Publish-amp-Subscribe原理图"><a href="#第1节-Publish-amp-Subscribe原理图" class="headerlink" title="第1节 Publish&amp;Subscribe原理图"></a>第1节 Publish&amp;Subscribe原理图</h3><table>
<thead>
<tr>
<th align="left">Publish&amp;Subscribe</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://note.youdao.com/yws/api/personal/file/F597EF30C192405787080AB890611CA0?method=download&shareKey=be3b46c9d51c7386649f03285c0422fc"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/F597EF30C192405787080AB890611CA0?method=download&shareKey=be3b46c9d51c7386649f03285c0422fc" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="python-four"></a></td>
</tr>
</tbody></table>
<hr>
<h3 id="第2节-Publish-amp-Subscribe介绍"><a href="#第2节-Publish-amp-Subscribe介绍" class="headerlink" title="第2节 Publish&amp;Subscribe介绍"></a>第2节 Publish&amp;Subscribe介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在前面的例子中,我们创建了一个工作队列,都是一个任务只交给一个消费者.这次我们做一些完全不同的事儿.将消息发送给多个消费者,这种模式叫做 &quot;发布/订阅&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第3节-Exchanges-交换器"><a href="#第3节-Exchanges-交换器" class="headerlink" title="第3节 Exchanges(交换器)"></a>第3节 Exchanges(交换器)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要想实现上面的发布/订阅这种模式,需要使用到交换器</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-1-交换器是干什么的"><a href="#3-1-交换器是干什么的" class="headerlink" title="3.1 交换器是干什么的"></a>3.1 交换器是干什么的</h4><blockquote>
<p>前面的例子,我们都是基于一个队列发送和接收消息.现在介绍一下完整的消息传递模式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RabbitMQ消息模式的核心理念:</span><br><span class="line">1. 生产者没有直接发送任何消费到队列</span><br><span class="line">2. 实际上,生产者都不知道这个消费是发送给哪个队列的</span><br><span class="line">3. 相反,生产者只需发送消息给交换器,交换器一方面它接受生产者的消息,另一方面向队列推送消息</span><br><span class="line">4. 交换器必须清楚的知道如何处理接收到的消息,指定一个队列或者指定多个队列或者是直接丢弃消息等处理方式,这些规则通过交换器的类型进行定义</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-交换器的常见类型"><a href="#3-2-交换器的常见类型" class="headerlink" title="3.2 交换器的常见类型"></a>3.2 交换器的常见类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常见的交换器类型有: direct、topic、headers 和 fanout</span><br><span class="line"></span><br><span class="line">下面会介绍常见类型的交换器</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-3-交换器的创建"><a href="#3-3-交换器的创建" class="headerlink" title="3.3 交换器的创建"></a>3.3 交换器的创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel.exchangeDeclare(&quot;logs&quot;, &quot;fanout&quot;); //使用channel对象创建一个名为logs，类型为fanout交换器</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-4-匿名交换器和临时队列"><a href="#3-4-匿名交换器和临时队列" class="headerlink" title="3.4 匿名交换器和临时队列"></a>3.4 匿名交换器和临时队列</h4><ul>
<li><p>匿名交换器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上面两个例子我们没有使用交换器,但是也可以将消息发送到队列，那是因为我们使用了默认的交换器,交换器名字为空字符串</span><br><span class="line"></span><br><span class="line">代码: channel.basicPublish(&quot;&quot;, &quot;hello&quot;, null, message.getBytes()); 第1个参数空字符串就是交换器名称,现在创建了一个类型为fanout名字为logs的交换器,可以指定交换器的名字了</span><br><span class="line"></span><br><span class="line">代码: channel.basicPublish(&quot;logs&quot;,&quot;&quot;,null,message.getBytes());</span><br></pre></td></tr></table></figure></li>
<li><p>临时队列</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们上面的例子在使用队列的时候都会指定一个名字,队列有名字对我们来说是非常重要的因为我们需要为消费者指定同一个队列去消费消息,但是接下来对于我们要完成的日志系统的例子来说指定具体队列不是我们所必须的，我们只关心消息发布出来之后消费者全部都接收到,不需要指定一个具体队列,使用临时队列即可.首先每当我们连接到RabbitMQ的时候需要为我们需要创建一个随机名字的空队列,其次,一旦消费者断开连接,队列将自动删除.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建一个非持久化、独立的、自动删除且名字是随机生成的临时队列的方式: String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">queueName是一个随机队列名 比如生成一个amq.gen-JzTY20BRgKO-HjmUJj0wLg名字</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-5-队列绑定"><a href="#3-5-队列绑定" class="headerlink" title="3.5 队列绑定"></a>3.5 队列绑定</h4><table>
<thead>
<tr>
<th align="left">队列绑定</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://note.youdao.com/yws/api/personal/file/C01B8A01CE52497680E92F5F1D724EA6?method=download&shareKey=526761beb2b1d94d9c53796b8167247a"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/C01B8A01CE52497680E92F5F1D724EA6?method=download&shareKey=526761beb2b1d94d9c53796b8167247a" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="python-bindings"></a></td>
</tr>
</tbody></table>
<hr>
<h3 id="第4节-Publish-amp-Subscribe实现"><a href="#第4节-Publish-amp-Subscribe实现" class="headerlink" title="第4节 Publish&amp;Subscribe实现"></a>第4节 Publish&amp;Subscribe实现</h3><blockquote>
<p>练习 消息的发布/订阅</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构建一个简单日志系统.它包含2段程序:第一个是消息提供者,将发布日志消息,第二个是消息消费者接受并打印消息,当然需要启动多个消费者,验证多个消费者同时订阅消息,这个模式类似于我们的广播(一个电台播放音乐,每个人订阅这个电台频道,都可以收到这个电台放的音乐,对应我们的需求,就是发布者发布消息,可以被所有的消费者接收到)</span><br><span class="line"></span><br><span class="line">注意: 在启动下面代码示例时,首先要先启动消费者的两个客户端代码,其次启动提供者客户端的代码</span><br></pre></td></tr></table></figure>

<ul>
<li>发布消息(消息提供者)代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 消息发布代码</span><br><span class="line"> */</span><br><span class="line">public class PublishMessageLog &#123;</span><br><span class="line">    //声明需要创建的交换器名称</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;logs&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        /*</span><br><span class="line">            创建一个名为logs，类型为fanout交换器</span><br><span class="line">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class="line">        //向交换器中发送几条消息,我这里循环发送三条消息</span><br><span class="line">        for (int i = 1; i &lt;=3; i++) &#123;</span><br><span class="line">            //构建发送的消息</span><br><span class="line">            String message = &quot;Hello RabbitMQ &quot;+i;</span><br><span class="line">            //发送</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,&quot;&quot;,null,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;========消息发布完成========&quot;);</span><br><span class="line">        //关闭频道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">生产者声明了一个广播模式的交换器,订阅这个交换器的消费者都可以收到每一条消息.可以看到在生产者中,没有声明队列.这也验证了之前说的.生产者其实只关心exchange,至于exchange会把消息转发给哪些队列,并不是生产者关心的</span><br></pre></td></tr></table></figure>

<ul>
<li>订阅消息(消息消费者)代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在这里使用两个消费者测试,一个消费者将订阅到的消息直接打印到控制台,另一个消费者将订阅到的消息保存为本地日志文件</span><br><span class="line"></span><br><span class="line">//消费者1</span><br><span class="line">/**</span><br><span class="line"> * 消息订阅代码</span><br><span class="line"> */</span><br><span class="line">public class SubscribeMessageLog1 &#123;</span><br><span class="line">    //声明需要创建的交换器名称</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;logs&quot;;</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        System.out.println(&quot;消费者客户端1&quot;);</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        /*</span><br><span class="line">            创建一个名为logs，类型为fanout交换器</span><br><span class="line">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class="line">        //声明一个随机队列</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        //将交换器和随机队列绑定到一起</span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            //获取订阅到的消息</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot;订阅到的消息为: &quot;+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        //获取订阅到的消息</span><br><span class="line">        channel.basicConsume(queueName,true,deliverCallback,consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//消费者2</span><br><span class="line">/**</span><br><span class="line"> * 消息订阅代码</span><br><span class="line"> */</span><br><span class="line">public class SubscribeMessageLog2 &#123;</span><br><span class="line">    //声明需要创建的交换器名称</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;logs&quot;;</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        System.out.println(&quot;消费者客户端2&quot;);</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        /*</span><br><span class="line">            创建一个名为logs，类型为fanout交换器</span><br><span class="line">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class="line">        //声明一个随机队列</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        //将交换器和随机队列绑定到一起</span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            //获取订阅到的消息</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            //将获取到的日志信息保存为本地文件 文件名为abc.log</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(new File(&quot;abc.log&quot;), true);</span><br><span class="line">            fos.write(message.getBytes());</span><br><span class="line">            fos.flush();</span><br><span class="line">            //关闭</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;;</span><br><span class="line">        //获取订阅到的消息</span><br><span class="line">        channel.basicConsume(queueName,true,deliverCallback,consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">2个消费者,一个打印日志,一个写入文件,消费者实例启动后,会创建一个随机队列,这个在管理页面可以看到(如下图).而消费者实例关闭后,随机队列也会自动删除(所以需要先启动消费者创建随机队列,后启动生产者)</span><br></pre></td></tr></table></figure>

<ul>
<li>管理控制台查看</li>
</ul>
<table>
<thead>
<tr>
<th align="left">管理页面</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://note.youdao.com/yws/api/personal/file/344E988DBA584222AE133C4CE389578D?method=download&shareKey=07e8b064c7affa6f996d5dd8f4be815e"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/344E988DBA584222AE133C4CE389578D?method=download&shareKey=07e8b064c7affa6f996d5dd8f4be815e" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="RabbitMQ-info3"></a></td>
</tr>
</tbody></table>
<hr>
<h2 id="第七章-路由-RabbitMQ-Route"><a href="#第七章-路由-RabbitMQ-Route" class="headerlink" title="第七章 路由(RabbitMQ-Route)"></a>第七章 路由(RabbitMQ-Route)</h2><h3 id="第1节-原理图-2"><a href="#第1节-原理图-2" class="headerlink" title="第1节 原理图"></a>第1节 原理图</h3><table>
<thead>
<tr>
<th align="left">Route</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://note.youdao.com/yws/api/personal/file/27C56AD394AA4B339F170DC425AED42C?method=download&shareKey=a33eda00e49a812cf7238ac294dc4287"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/27C56AD394AA4B339F170DC425AED42C?method=download&shareKey=a33eda00e49a812cf7238ac294dc4287" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="python-six"></a></td>
</tr>
</tbody></table>
<hr>
<h3 id="第2节-Route-路由-介绍"><a href="#第2节-Route-路由-介绍" class="headerlink" title="第2节 Route(路由)介绍"></a>第2节 Route(路由)介绍</h3><ul>
<li>Route的功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在上个消息&quot;发布/订阅&quot;案例中我们建立了一个简单的日志系统,可以广播消息给多个消费者</span><br><span class="line">2. 在这个案例中我们将添加新的特性.我们可以只订阅部分消息.比如:我们的日志分多个级别(info,debug,error)</span><br><span class="line">3. 如果是上面的单纯的&quot;发布/订阅&quot;模式,那么我们会把所有级别的日志都打印到控制台或者保存到本地日志文件中</span><br><span class="line">4. 但是对于有些级别的日志我们不需要保存到本地硬盘,占用空间,这时候就需要对发布者发布的消息进行过滤,进行有针对性的消费,这就需要我们的Route帮助我们完成.</span><br></pre></td></tr></table></figure>

<ul>
<li>交换器的选择</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前面讲到我们的日志系统广播消息给所有的消费者.我们想对其扩展,根据消息的严重性来过滤消息.我们使用的fanout交换器,不能给我们太多的灵活性.它仅仅只是盲目的广播而已.我们使用direct交换器进行代替,其背后的算法很简单,消息会被推送至绑定键(routingKey)和消息发布附带的选择键(routingKey)完全匹配的队列</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Route的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 消息发布</span><br><span class="line">    1.1 交换器类型 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT)</span><br><span class="line">    1.2 发布消息的参数 channel.basicPublish(EXCHANGE_NAME,&quot;routingKey&quot;,null,message.getBytes())</span><br><span class="line"></span><br><span class="line">2. 消息订阅</span><br><span class="line">    2.1 交换器类型 channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT)</span><br><span class="line">    2.2 队列绑定 channel.queueBind(queueName, EXCHANGE_NAME, severity) //可以进行多重绑定</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="第3节-Route-路由-实现"><a href="#第3节-Route-路由-实现" class="headerlink" title="第3节 Route(路由)实现"></a>第3节 Route(路由)实现</h3><ul>
<li>发布消息(消息提供者)代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 消息发布代码</span><br><span class="line"> */</span><br><span class="line">public class PublishMessageLog &#123;</span><br><span class="line">    //声明需要创建的交换器名称</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;logs&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号,如果不设置为默认值</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        /*</span><br><span class="line">            创建一个名为logs，类型为direct交换器</span><br><span class="line">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">            模拟发送多个级别的日志库[info,debug,error]</span><br><span class="line">         */</span><br><span class="line">        String[] severities=&#123;&quot;error&quot;,&quot;info&quot;,&quot;warning&quot;&#125;;</span><br><span class="line">        for (int i = 0; i &lt; severities.length; i++) &#123;</span><br><span class="line">            //模拟待发送的消息</span><br><span class="line">            String message = &quot;Hello RabbitMQ &quot;+i+&quot;\n&quot;;</span><br><span class="line">            //发送消息,每次发送之前指定 routingKey: 使用severities里面的值标记每条发送消息的日志级别(就是给每条消息设置路由key)</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME,severities[i],null,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;========消息发布完成========&quot;);</span><br><span class="line">        //关闭频道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>订阅消息(消息消费者)代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//客户端1</span><br><span class="line">/**</span><br><span class="line"> * 消息订阅代码</span><br><span class="line"> */</span><br><span class="line">public class SubscribeMessageLog1 &#123;</span><br><span class="line">    //声明需要创建的交换器名称</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;logs&quot;;</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        System.out.println(&quot;消费者客户端1&quot;);</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        /*</span><br><span class="line">            创建一个名为logs，类型为direct交换器</span><br><span class="line">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        //声明一个随机队列</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">            消费者1采用多重绑定的方式,订阅所有的日志级别的信息</span><br><span class="line">         */</span><br><span class="line">        String[] severities=&#123;&quot;error&quot;,&quot;info&quot;,&quot;warning&quot;&#125;;</span><br><span class="line">        for (String severity : severities) &#123;</span><br><span class="line">            channel.queueBind(queueName,EXCHANGE_NAME,severity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            //获取订阅到的消息</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot;订阅到的消息为: &quot;+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        //获取订阅到的消息</span><br><span class="line">        channel.basicConsume(queueName,true,deliverCallback,consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//客户端2</span><br><span class="line">/**</span><br><span class="line"> * 消息订阅代码</span><br><span class="line"> */</span><br><span class="line">public class SubscribeMessageLog2 &#123;</span><br><span class="line">    //声明需要创建的交换器名称</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;logs&quot;;</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        System.out.println(&quot;消费者客户端2&quot;);</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        /*</span><br><span class="line">            创建一个名为logs，类型为direct交换器</span><br><span class="line">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        //声明一个随机队列</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        //消费者2只绑定日志级别为error的消息</span><br><span class="line">        String routingKey = &quot;error&quot;;</span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,routingKey);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            //获取订阅到的消息</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            //将获取到的日志信息保存为本地文件 文件名为abc.log</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(new File(&quot;abc.log&quot;), true);</span><br><span class="line">            fos.write(message.getBytes());</span><br><span class="line">            fos.flush();</span><br><span class="line">            //关闭</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;;</span><br><span class="line">        //获取订阅到的消息</span><br><span class="line">        channel.basicConsume(queueName,true,deliverCallback,consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">上面说了很多,其实就为了做一件事,我们可以使用Direct exchange+routingKey来过滤自己感兴趣的消息,一个队列可以绑定多个routingKey,这就是有选择</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">    1. 启动的时候还是需要先启动消费者端,后启动提供者端</span><br><span class="line">    2. 如果当前路由选择的案例延续使用消息&quot;发布/订阅&quot;案例需要注意不要使用原有的队列,我们新的参数在原有队列不生效</span><br><span class="line">    3. 解决方法,重新声明队列,或者重启RabbitMQ docker容器</span><br><span class="line">        - 关闭容器命令 docker contanier stop &quot;CONTAINER ID&quot;</span><br><span class="line">        - 启动容器命令 docker contanier start &quot;CONTAINER ID&quot;</span><br><span class="line">        - 重启容易命令 docker contanier restart &quot;CONTAINER ID&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第八章-主题-RabbitMQ-Topic"><a href="#第八章-主题-RabbitMQ-Topic" class="headerlink" title="第八章 主题(RabbitMQ-Topic)"></a>第八章 主题(RabbitMQ-Topic)</h2><h3 id="第1节-Topic-主题-原理图"><a href="#第1节-Topic-主题-原理图" class="headerlink" title="第1节 Topic(主题)原理图"></a>第1节 Topic(主题)原理图</h3><table>
<thead>
<tr>
<th align="left">Topic</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://note.youdao.com/yws/api/personal/file/33D7EA24E9394502AF326BEFAEEFC14F?method=download&shareKey=0ca2a435211c05d1c411e24d5cddb2ed"><img "" class="lazyload placeholder" data-original="https://note.youdao.com/yws/api/personal/file/33D7EA24E9394502AF326BEFAEEFC14F?method=download&shareKey=0ca2a435211c05d1c411e24d5cddb2ed" src="https://img10.360buyimg.com/ddimg/jfs/t1/157667/29/9156/134350/603c6445Ebbc9cabe/41219c5d36d45072.gif" alt="python-serven"></a></td>
</tr>
</tbody></table>
<hr>
<h3 id="第2节-Topic-主题-介绍"><a href="#第2节-Topic-主题-介绍" class="headerlink" title="第2节 Topic(主题)介绍"></a>第2节 Topic(主题)介绍</h3><ul>
<li>Topic(主题)交换器的功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在上一节中我们使用了direct类型的交换器改进了日志系统,但是还是具有一定的局限性,不能根据多重条件进行路由选择,在我们的日志系统中，我们可能不仅仅根据日志严重性(info/warning/error)订阅日志，也想根据日志来源(auth/cron/kern)订阅日志，这将给我们带来更大的灵活性.比如我们可以订阅auth来源的error级别日志,还可以订阅cron来源的所有级别日志,这就需要我们强大的主题类型的交换器</span><br></pre></td></tr></table></figure>

<ul>
<li>Topic(主题)交换器使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们主题交换器的使用和上面的Route(路由交换器)使用是类似的,都需要指定routingKey,只是发送给主题交换器的消息不能是任意设置的routingKey，必须是用小数点隔开的一系列的标识符.这些标识符可以是随意,但是通常跟消息的某些特性相关联.合法的routingKey 比如&quot;socket.usd.nyse&quot;,&quot;nyse.vmw&quot;,&quot;quick.orange.rabbit&quot;,你愿意用多少单词都可以,只要不超过上限的255个字节,关于routingKey有两种特殊的情况：*(星号)可以代替任意一个标识符; #(井号)可以代替零个或多个标识符(单词)</span><br><span class="line">消息发布:</span><br><span class="line"></span><br><span class="line">    1. 交换器设置为topic channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">    2. 构建routingKey并发布 channel.basicPublish(EXCHANGE_NAME,routingKey,null,message.getBytes());</span><br><span class="line"></span><br><span class="line">消息订阅:</span><br><span class="line"></span><br><span class="line">    1. 交换器设置为topic channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">    2. 绑定设置好订阅规则的routingKey channel.queueBind(queueName,EXCHANGE_NAME,routingKey);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第3节-Topic-主题-实现"><a href="#第3节-Topic-主题-实现" class="headerlink" title="第3节 Topic(主题)实现"></a>第3节 Topic(主题)实现</h3><ul>
<li>发布消息(消息提供者)代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 消息发布代码</span><br><span class="line"> */</span><br><span class="line">public class PublishMessageLog &#123;</span><br><span class="line">    //声明需要创建的交换器名称</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;logs&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号,如果不设置为默认值</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        /*</span><br><span class="line">            创建一个名为logs，类型为topic交换器</span><br><span class="line">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        /*</span><br><span class="line">            模拟多个设备[&quot;auth&quot;,&quot;cron&quot;,&quot;kern&quot;]</span><br><span class="line">            模拟级别的日志库[info,debug,error]</span><br><span class="line">         */</span><br><span class="line">        String[] facilities =&#123;&quot;auth&quot;,&quot;cron&quot;,&quot;kern&quot;&#125;;</span><br><span class="line">        String[] severities=&#123;&quot;error&quot;,&quot;info&quot;,&quot;warning&quot;&#125;;</span><br><span class="line"></span><br><span class="line">        //模拟发送所有设备(facilities)的所有级别(severities)的日志</span><br><span class="line">        for (int i = 0; i &lt; facilities.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;severities.length; j++) &#123;</span><br><span class="line">                /*</span><br><span class="line">                    拼装routingKey</span><br><span class="line">                    格式为: auth.info  auth.waring auth.error</span><br><span class="line">                 */</span><br><span class="line">                String routingKey = facilities[i]+&quot;.&quot;+severities[j];</span><br><span class="line">                // 设置发送的消息</span><br><span class="line">                String message = &quot;[&quot;+facilities[i]+&quot;.&quot;+severities[j]+&quot;] Hello RabbitMQ i=&quot; + i;</span><br><span class="line">                //发送</span><br><span class="line">                channel.basicPublish(EXCHANGE_NAME,routingKey,null,message.getBytes());</span><br><span class="line">                System.out.println(&quot;消息提供者发送的日志消息: &quot;+message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;========消息发布完成========&quot;);</span><br><span class="line">        //关闭频道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>订阅消息(消息消费者)代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消费者1</span><br><span class="line">/**</span><br><span class="line"> * 消息订阅代码</span><br><span class="line"> */</span><br><span class="line">public class SubscribeMessageLog1 &#123;</span><br><span class="line">    //声明需要创建的交换器名称</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;logs&quot;;</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        System.out.println(&quot;消费者客户端1&quot;);</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        /*</span><br><span class="line">            创建一个名为logs，类型为topic交换器</span><br><span class="line">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        //声明一个随机队列</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        /*</span><br><span class="line">            消费者1采用多重绑定的方式,订阅所有设备的日志级别的信息</span><br><span class="line">            所以我们需要构建routingKey来订阅发布者发布的信息</span><br><span class="line">            使用通配符过滤哪些消息被丢弃，哪些消息被消费打印到控制台</span><br><span class="line">            auth.*    : 订阅auth系统后面是一个单词的日志 比如 auth.info auth.warning auth.error</span><br><span class="line">            *.info    : 订阅info级别的并且前面是一个单词的日志 比如 auth.info等 如果前面有两个单词的如auth.abc.info 不会被订阅到</span><br><span class="line">            #.warning : 订阅所有系统的warning的级别日志，因为#匹配多个单词</span><br><span class="line">         */</span><br><span class="line">        String[] routingKeys =&#123;&quot;auth.*&quot;,&quot;*.info&quot;,&quot;#.warning&quot;&#125;;</span><br><span class="line">        for (String routingKey : routingKeys) &#123;</span><br><span class="line">            channel.queueBind(queueName,EXCHANGE_NAME,routingKey);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            //获取订阅到的消息</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            System.out.println(&quot;订阅到的消息为: &quot;+message);</span><br><span class="line">        &#125;;</span><br><span class="line">        //获取订阅到的消息</span><br><span class="line">        channel.basicConsume(queueName,true,deliverCallback,consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 消费者2</span><br><span class="line">/**</span><br><span class="line"> * 消息订阅代码</span><br><span class="line"> */</span><br><span class="line">public class SubscribeMessageLog2 &#123;</span><br><span class="line">    //声明需要创建的交换器名称</span><br><span class="line">    private final static String EXCHANGE_NAME = &quot;logs&quot;;</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        System.out.println(&quot;消费者客户端2&quot;);</span><br><span class="line">        //创建连接RabbitMQ服务器的连接</span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        //设置连接RabbitMQ的服务器地址</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        //设置连接RabbitMQ的服务器AMQP端口号</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        //创建一个连接</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        //创建频道</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        /*</span><br><span class="line">            创建一个名为logs，类型为topic交换器</span><br><span class="line">            RabbitMQ客户端提供了交换器类型的枚举BuiltinExchangeType</span><br><span class="line">         */</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);</span><br><span class="line">        //声明一个随机队列</span><br><span class="line">        String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">        //消费者2只订阅 auth系统级别为error的日志消息</span><br><span class="line">        String routingKey = &quot;auth.error&quot;;</span><br><span class="line">        channel.queueBind(queueName,EXCHANGE_NAME,routingKey);</span><br><span class="line"></span><br><span class="line">        DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            //获取订阅到的消息</span><br><span class="line">            String message = new String(delivery.getBody());</span><br><span class="line">            //将获取到的日志信息保存为本地文件 文件名为abc.log</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(new File(&quot;abc.log&quot;), true);</span><br><span class="line">            fos.write(message.getBytes());</span><br><span class="line">            fos.flush();</span><br><span class="line">            //关闭</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;;</span><br><span class="line">        //获取订阅到的消息</span><br><span class="line">        channel.basicConsume(queueName,true,deliverCallback,consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过上面的例子的结果</span><br><span class="line"></span><br><span class="line">发布者发布的消息:</span><br><span class="line">    消息提供者发送的日志消息: [auth.error] Hello RabbitMQ i=0</span><br><span class="line">    消息提供者发送的日志消息: [auth.info] Hello RabbitMQ i=0</span><br><span class="line">    消息提供者发送的日志消息: [auth.warning] Hello RabbitMQ i=0</span><br><span class="line">    消息提供者发送的日志消息: [cron.error] Hello RabbitMQ i=1</span><br><span class="line">    消息提供者发送的日志消息: [cron.info] Hello RabbitMQ i=1</span><br><span class="line">    消息提供者发送的日志消息: [cron.warning] Hello RabbitMQ i=1</span><br><span class="line">    消息提供者发送的日志消息: [kern.error] Hello RabbitMQ i=2</span><br><span class="line">    消息提供者发送的日志消息: [kern.info] Hello RabbitMQ i=2</span><br><span class="line">    消息提供者发送的日志消息: [kern.warning] Hello RabbitMQ i=2</span><br><span class="line"></span><br><span class="line">消费者1消费的消息:</span><br><span class="line">	将符合routingKey的消息消费了 &#123;&quot;auth.*&quot;,&quot;*.info&quot;,&quot;#.warning&quot;&#125;</span><br><span class="line">	消息如下:</span><br><span class="line">        订阅到的消息为: [auth.error] Hello RabbitMQ i=0</span><br><span class="line">        订阅到的消息为: [auth.info] Hello RabbitMQ i=0</span><br><span class="line">        订阅到的消息为: [auth.warning] Hello RabbitMQ i=0</span><br><span class="line">        订阅到的消息为: [cron.info] Hello RabbitMQ i=1</span><br><span class="line">        订阅到的消息为: [cron.warning] Hello RabbitMQ i=1</span><br><span class="line">        订阅到的消息为: [kern.info] Hello RabbitMQ i=2</span><br><span class="line">        订阅到的消息为: [kern.warning] Hello RabbitMQ i=2</span><br><span class="line"></span><br><span class="line">消费者2消费的消息:</span><br><span class="line">	将符合routingKey的消息消费了 &quot;auth.error&quot;</span><br><span class="line">	消息如下:</span><br><span class="line">		[auth.error] Hello RabbitMQ i=0[auth.error] Hello RabbitMQ i=0</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第九章-SpringBoot整合RabbitMQ"><a href="#第九章-SpringBoot整合RabbitMQ" class="headerlink" title="第九章 SpringBoot整合RabbitMQ"></a>第九章 SpringBoot整合RabbitMQ</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建SpringBoot项目,并且选择RabbitMQ的依赖,由于不同的时间段可能SpringBoot和RabbitMQ的版本略微不同</span><br><span class="line"></span><br><span class="line">jdk版本        : 1.8</span><br><span class="line">springboot版本 : 2.1.13.RELEASE</span><br></pre></td></tr></table></figure>

<h3 id="第1节-SpringBoot和RabbitMQ整合并配置"><a href="#第1节-SpringBoot和RabbitMQ整合并配置" class="headerlink" title="第1节 SpringBoot和RabbitMQ整合并配置"></a>第1节 SpringBoot和RabbitMQ整合并配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在application.properties配置文件中配置基本的配置信息</span><br><span class="line"></span><br><span class="line">#设置MQ服务器地址</span><br><span class="line">spring.rabbitmq.host=192.168.1.129</span><br><span class="line">#设置MQ的端口号</span><br><span class="line">spring.rabbitmq.port=5672</span><br><span class="line">#开启ACK 自动/手动</span><br><span class="line">spring.jms.listener.acknowledge-mode=auto</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第2节-代码实现"><a href="#第2节-代码实现" class="headerlink" title="第2节 代码实现"></a>第2节 代码实现</h3><h4 id="2-1-不设置交换器"><a href="#2-1-不设置交换器" class="headerlink" title="2.1 不设置交换器"></a>2.1 不设置交换器</h4><ul>
<li>RabbitMQ configuration配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfig &#123;</span><br><span class="line">    //普通队列名称</span><br><span class="line">    private static final String QUEUE_SIMPLE=&quot;HELLO_QUEUE&quot;;</span><br><span class="line">    //持久化队列名称</span><br><span class="line">    private static final String QUEUE_PERSIST =&quot;WORK_QUEUE&quot;;</span><br><span class="line"></span><br><span class="line">    //创建一个普通队列(非持久化) 导包 org.springframework.amqp.core.Queue 别导错包</span><br><span class="line">    @Bean(&quot;simpleQueue&quot;)</span><br><span class="line">    public Queue createSimpleQueue()&#123;</span><br><span class="line">        return new Queue(QUEUE_SIMPLE,false);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建一个持久化队列</span><br><span class="line">    @Bean(&quot;workQueue&quot;)</span><br><span class="line">    public Queue createWorkQueue()&#123;</span><br><span class="line">        return new Queue(QUEUE_PERSIST,true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息发布和消费</li>
<li><ul>
<li>定义一个User的POJO类用于作为消息发送</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//类一定序列化</span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private Integer userId;</span><br><span class="line">    private String userName;</span><br><span class="line">    private Date createTime;</span><br><span class="line">    private double salary;</span><br><span class="line">    //省略get/set方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>消息发布</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ProducerMessage &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private Queue simpleQueue; //注入配置中的普通队列</span><br><span class="line">    @Resource</span><br><span class="line">    private Queue workQueue;   //注入配置中的持久化队列</span><br><span class="line">    @Resource</span><br><span class="line">    private AmqpTemplate amqpTemplate;// RabbitMQ使用AmqpTemplate进行消息发布</span><br><span class="line">    /**</span><br><span class="line">     * 发送一个User对象到普通队列</span><br><span class="line">     */</span><br><span class="line">    public void sendUser(User user)&#123;</span><br><span class="line">        //指定队列名称</span><br><span class="line">        amqpTemplate.convertAndSend(simpleQueue.getName(),user);</span><br><span class="line">        System.out.println(&quot;消息发送成功...........&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 发送一个User集合到持久化队列</span><br><span class="line">     */</span><br><span class="line">    public void sendUserList(List&lt;User&gt; userList)&#123;</span><br><span class="line">        //指定队列名称</span><br><span class="line">        amqpTemplate.convertAndSend(workQueue.getName(),userList);</span><br><span class="line">        System.out.println(&quot;消息发送成功...........&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>消息订阅</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ConsumerMessage &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 监听消费普通队列的消息</span><br><span class="line">     */</span><br><span class="line">    @RabbitListener(queues = &#123;&quot;HELLO_QUEUE&quot;&#125;)</span><br><span class="line">    public void receiveUser(User user)&#123;</span><br><span class="line">        System.out.println(&quot;接收到的user:&quot;+user);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 监听消费持久化队列里面的消息</span><br><span class="line">     */</span><br><span class="line">    @RabbitListener(queues = &#123;&quot;WORK_QUEUE&quot;&#125;)</span><br><span class="line">    public void receiveUserList(List&lt;User&gt; users)&#123;</span><br><span class="line">        System.out.println(&quot;接收到的users:&quot;+users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>测试</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//测试的时候只需要测试消息发布，不需要写消息接受的测试,因为消息消费是监听器(RabbitListener),是时时的,在我们发送完成之后，直接就会消费，不需要在写测试类，去消费。</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ProducerMessageTest&#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private ProducerMessage producerMessage;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void sendUser() &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUserId(1001);</span><br><span class="line">        user.setSalary(30000.12);</span><br><span class="line">        user.setUserName(&quot;李雷&quot;);</span><br><span class="line">        user.setCreateTime(new Date());</span><br><span class="line">        producerMessage.sendUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void sendUserList() &#123;</span><br><span class="line">        List&lt;User&gt; userList = new ArrayList&lt;&gt;();</span><br><span class="line">        User user1 = new User();</span><br><span class="line">        user1.setUserId(1001);</span><br><span class="line">        user1.setSalary(30000.12);</span><br><span class="line">        user1.setUserName(&quot;李雷&quot;);</span><br><span class="line">        user1.setCreateTime(new Date());</span><br><span class="line">        User user2 = new User();</span><br><span class="line">        user2.setUserId(1002);</span><br><span class="line">        user2.setSalary(320000.12);</span><br><span class="line">        user2.setUserName(&quot;李雷2&quot;);</span><br><span class="line">        user2.setCreateTime(new Date());</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        producerMessage.sendUserList(userList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行测试之后的部分日志,可以看到我们运行的提供者，但是消费者的消费消息也打印出来了。</span><br><span class="line">消息发送成功...........</span><br><span class="line">接收到的 users:[User&#123;userId=1001, userName=&#x27;李雷&#x27;, createTime=Fri Apr 03 20:23:00 CST 2020, salary=30000.12&#125;, User&#123;userId=1002, userName=&#x27;李雷2&#x27;, createTime=Fri Apr 03 20:23:00 CST 2020, salary=320000.12&#125;]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-设置交换器"><a href="#2-2-设置交换器" class="headerlink" title="2.2 设置交换器"></a>2.2 设置交换器</h4><ul>
<li>RabbitMQ configuration配置</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitMQConfig &#123;</span><br><span class="line"></span><br><span class="line">    //队列名称</span><br><span class="line">    private static final String QUEUE_NAME =&quot;queueWork&quot;;</span><br><span class="line">    //交换器名称</span><br><span class="line">    private static final String EXCHANGE_NAME=&quot;LOGS&quot;;</span><br><span class="line">    //声明需要订阅的routingKey类型</span><br><span class="line">    private static final String ROUTING_KEY=&quot;*.error&quot;;</span><br><span class="line"></span><br><span class="line">    //创建一个队列</span><br><span class="line">    @Bean(&quot;queueWork&quot;)</span><br><span class="line">    public Queue createworkQueue()&#123;</span><br><span class="line">        return new Queue(QUEUE_NAME,true);</span><br><span class="line">    &#125;</span><br><span class="line">    //创建一个TOPIC类型交换器</span><br><span class="line">    @Bean(&quot;topicExchange&quot;)</span><br><span class="line">    public TopicExchange createTopicExchange()&#123;</span><br><span class="line">        return new TopicExchange(EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">    //将队列、交换器和ROUTING_KEY绑定,如果想绑定多个ROUTING_KEY可以定义多个bindQueueExchageKey方法</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding bindQueueExchageKey()&#123;</span><br><span class="line">        return BindingBuilder.bind(createworkQueue()).to(createTopicExchange()).with(ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息发布和消费</li>
<li><ul>
<li>消息发布</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ProducerMessage &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private Exchange topicExchange;// topic类型的交换器</span><br><span class="line">    @Resource</span><br><span class="line">    private AmqpTemplate amqpTemplate;// 消息处理的对象</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用topic类型交换器</span><br><span class="line">     * 发送多个设备多种类型的消息</span><br><span class="line">     */</span><br><span class="line">    public void sendLevelMessage()&#123;</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app1.info&quot;,&quot;我app1.info下的消息&quot;);</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app1.waring&quot;,&quot;我app1.waring下的消息&quot;);</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app1.error&quot;,&quot;我app1.error下的消息&quot;);</span><br><span class="line"></span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app2.info&quot;,&quot;我app2.info下的消息&quot;);</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app2.waring&quot;,&quot;我app2.waring下的消息&quot;);</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app2.error&quot;,&quot;我app2.error下的消息&quot;);</span><br><span class="line"></span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app3.info&quot;,&quot;我app3.info下的消息&quot;);</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app3.waring&quot;,&quot;我app3.waring下的消息&quot;);</span><br><span class="line">        amqpTemplate.convertAndSend(topicExchange.getName(),</span><br><span class="line">                                    &quot;app3.error&quot;,&quot;我app3.error下的消息&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>消息消费</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ConsumerMessage &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 消费消息</span><br><span class="line">     */</span><br><span class="line">    @RabbitListener(bindings = @QueueBinding(</span><br><span class="line">            value = @Queue(value = &quot;queueWork&quot;),</span><br><span class="line">            exchange = @Exchange(value = &quot;topicExchange&quot;)))</span><br><span class="line">    public void receiveErrorLogs(Message message)&#123;</span><br><span class="line">        System.out.println(&quot;获取到的error消息为:&quot;+ new String(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ProducerMessageTest&#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private ProducerMessage producerMessage;</span><br><span class="line">    @Test</span><br><span class="line">    public void sendLevelMessage()&#123;</span><br><span class="line">        producerMessage.sendLevelMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//日志中的打印结果:</span><br><span class="line">/**</span><br><span class="line"> * 获取到的error消息为:我app1.error下的消息</span><br><span class="line"> * 获取到的error消息为:我app2.error下的消息</span><br><span class="line"> * 获取到的error消息为:我app3.error下的消息</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="第十章-RabbitMQ事务-amp-Confirm"><a href="#第十章-RabbitMQ事务-amp-Confirm" class="headerlink" title="第十章 RabbitMQ事务&amp;Confirm"></a>第十章 RabbitMQ事务&amp;Confirm</h2><h3 id="第1节-RabbitMQ事务机制"><a href="#第1节-RabbitMQ事务机制" class="headerlink" title="第1节 RabbitMQ事务机制"></a>第1节 RabbitMQ事务机制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 通过上面的学习大家都知道我们的RabbitMQ的队列是可以持久化保存数据的，就算我们的MQ服务器挂掉或者重启也不会造成数据丢失,但是如果我们的消息还没有到队列就丢失了怎么办呢？</span><br><span class="line"></span><br><span class="line">2. 接下来我们就说一下RabbitMQ怎么解决这个问题,如果不做任何配置的情况下我们使用消息提供者发布消息,消息发布完成之后其实提供者是不知道消息发送是否成功的,是否正确到达broker的，RabbitMQ提供了两种方式来解决这个问题:</span><br><span class="line"></span><br><span class="line">    第1种: 通过AMQP事务机制实现</span><br><span class="line">    第2种: 通过将channel设置成confirm模式来实现</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第2节-AMQP事物机制"><a href="#第2节-AMQP事物机制" class="headerlink" title="第2节 AMQP事物机制"></a>第2节 AMQP事物机制</h3><h4 id="2-1-AMQP事物机制介绍"><a href="#2-1-AMQP事物机制介绍" class="headerlink" title="2.1 AMQP事物机制介绍"></a>2.1 AMQP事物机制介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该模式与数据库的事务非常相似。RabbitMQ中与事务机制有关的方法有txSelect(),txCommit()以及txRollback()。txSelect用于将当前channel设置成transaction模式，txCommit用于提交事务，txRollback用于回滚事务。在通过txSelect开启事务之后，我们便可以发布消息给broker了，如果txCommit提交成功了，则消息一定到达了broker了，如果在txCommit执行之前broker异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback回滚事务了</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-2-AMQP事物机制实现"><a href="#2-2-AMQP事物机制实现" class="headerlink" title="2.2 AMQP事物机制实现"></a>2.2 AMQP事物机制实现</h4><ul>
<li>代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ProducerAMQP &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个持久化队列</span><br><span class="line">        channel.queueDeclare(&quot;AMQP_QUEUE&quot;,true,false,false,null);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //创建消息</span><br><span class="line">            String message=&quot;AMQP事物消息&quot;;</span><br><span class="line">            //开启事务</span><br><span class="line">            channel.txSelect();</span><br><span class="line">            //发布消息</span><br><span class="line">            channel.basicPublish(&quot;&quot;,&quot;AMQP_QUEUE&quot;,true, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes());</span><br><span class="line">            //用于测试的异常</span><br><span class="line">            int i=1/0;</span><br><span class="line">            //提交事务</span><br><span class="line">            channel.txCommit();</span><br><span class="line">            System.out.println(&quot;消息发送成功...........&quot;);</span><br><span class="line">        &#125;catch (RuntimeException e)&#123;</span><br><span class="line">            System.out.println(&quot;消息发送失败...........&quot;);</span><br><span class="line">            //回滚事务</span><br><span class="line">            channel.txRollback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">该模式用法简单,但是有个致命的缺点,那就是事务提交非常慢,会严重降低系统吞吐量,所以一般不推荐使用该模式,而改用confirm模式</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第3节-Confirm机制"><a href="#第3节-Confirm机制" class="headerlink" title="第3节 Confirm机制"></a>第3节 Confirm机制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Confirm发送方确认模式使用和事务类似,也是通过设置Channel进行发送方确认的,并且Confirm支持异步.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Confirm的三种实现方式:</span><br><span class="line">方式一: channel.waitForConfirms()普通发送方确认模式</span><br><span class="line">方式二: channel.waitForConfirmsOrDie()批量确认模式</span><br><span class="line">方式三: channel.addConfirmListener()异步监听发送方确认模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们这里只演示最后一种常用的异步监听发送方式:</span><br><span class="line">    - 消息发布者发布多条消息,并使用异步监听</span><br><span class="line">    - 消息订阅者消息确认模式(ack)采用手动模式</span><br><span class="line">    - prefetch设置为1，限制通道上未完成的发送消息数量</span><br></pre></td></tr></table></figure>

<ul>
<li>消息提供者代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ProducerConfirm &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个持久化队列</span><br><span class="line">        channel.queueDeclare(&quot;CONFIRM_QUEUE&quot;,true,false,false,null);</span><br><span class="line">        //开启发送方确认模式</span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        //发送消息</span><br><span class="line">        //创建消息</span><br><span class="line">        String message = &quot;Hello RabbitMQ Confirm &quot;;</span><br><span class="line">        channel.basicPublish(&quot;&quot;,&quot;CONFIRM_QUEUE&quot;,MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes());</span><br><span class="line">        System.out.println(&quot;发送消息为: &quot;+message);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //监听发送状态</span><br><span class="line">        channel.addConfirmListener(new ConfirmListener() &#123;</span><br><span class="line">            /*</span><br><span class="line">                消息确认成功</span><br><span class="line">                deliveryTag: 如果发送多条，这是最后一条消息的deliveryTag</span><br><span class="line">             */</span><br><span class="line">            @Override</span><br><span class="line">            public void handleAck(long deliveryTag, boolean multiple) throws IOException &#123;</span><br><span class="line">                System.out.println(&quot;已确认消息: &quot;+deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            //消息确认异常</span><br><span class="line">            @Override</span><br><span class="line">            public void handleNack(long deliveryTag, boolean multiple) throws IOException &#123;</span><br><span class="line">                System.out.println(&quot;未确认消息: &quot;+deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>消息消费者代码如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ConsumerConfirm &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">        ConnectionFactory factory = new ConnectionFactory();</span><br><span class="line">        factory.setHost(&quot;192.168.1.129&quot;);</span><br><span class="line">        factory.setPort(5672);</span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        //声明一个持久化队列</span><br><span class="line">        channel.queueDeclare(&quot;CONFIRM_QUEUE&quot;,true,false,false,null);</span><br><span class="line">        //设置prefetch</span><br><span class="line">        int prefetch=1;</span><br><span class="line">        channel.basicQos(prefetch);</span><br><span class="line">        //消费消息</span><br><span class="line">        boolean autoAck = false; //关闭消息的自动确认</span><br><span class="line">        channel.basicConsume(&quot;CONFIRM_QUEUE&quot;, autoAck, new DeliverCallback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handle(String consumerTag, Delivery message) throws IOException &#123;</span><br><span class="line">                //获取消息内容</span><br><span class="line">                byte[] body = message.getBody();</span><br><span class="line">                System.out.println(&quot;消息已被消费: &quot;+new String(body));</span><br><span class="line">                //获取消息序号</span><br><span class="line">                long deliveryTag = message.getEnvelope().getDeliveryTag();</span><br><span class="line">                System.out.println(&quot;消息已被消费 deliveryTag: &quot;+deliveryTag);</span><br><span class="line">                /*</span><br><span class="line">                    手动确认此序号的消息</span><br><span class="line">                    multiple:如果设置为false那么只确认当前程序的消息,如果设置为true，确认当前序号之前的所有消息</span><br><span class="line">                 */</span><br><span class="line">                channel.basicAck(deliveryTag,true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, (consumerTag) -&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>JAVAEE基础</title>
    <url>/2021/08/06/%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/</url>
    <content><![CDATA[<h2 id="5个阶段"><a href="#5个阶段" class="headerlink" title="5个阶段"></a>5个阶段</h2><p>1.javase  基础部分  </p>
<p>2.数据库 jdbc  mysql 数据库 </p>
<p>\3. javaweb BS  jsp +Servlet  </p>
<p>4.框架技术 SSM  </p>
<p>5.分布式项目技术  </p>
<p> redis  zookeeper  linux  rabbitmq  等等  </p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>java me</p>
<p>  se  基础 </p>
<p>  ee  BS  </p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>java  跨平台  性能高  稳定性好 </p>
<p> jvm  java虚拟机 </p>
<p>程序 相当于 菜  </p>
<p>jvm 相当于 盘子 </p>
<p>不同的操作系统相当于桌子 </p>
<h2 id="jdk安装"><a href="#jdk安装" class="headerlink" title="jdk安装"></a>jdk安装</h2><p>右键管理员身份运行</p>
<p> 2.配置环境变量 </p>
<p>  D:\Program Files\Java\jdk1.8.0_77\bin </p>
<p>将上面的路径粘贴到环境变量中 </p>
<p>(注意 上面这个路径 是你自己的安装路径)</p>
<p>3.验证  </p>
<p> win键+r  –&gt; 输入cmd  回车</p>
<p>  java -version  </p>
<p>hello </p>
<p>源文件  保存源代码的文件 后缀 .java</p>
<p>字节码文件  通过 javac命令 编译之后的能够</p>
<pre><code>   被 jvm 所解析执行的文件 后缀.class
</code></pre>
<p> cd 切换目录的  </p>
<p>  cd c:\abc  回车 </p>
<p>  d:  回车 切换盘符</p>
<p> javac  编译源文件   </p>
<pre><code> javac  源文件名.java

 javac Hello.java
</code></pre>
<p> java  执行字节码文件</p>
<pre><code> java  Hello   
</code></pre>
<p>todo：</p>
<p>在c盘下 创建文件夹 abc 并且 创建一个 Hello 的文本文件</p>
<p> 编辑 内容为 </p>
<p>  public  class  Hello{</p>
<pre><code>public  static  void  main(String[] args)&#123; 

System.out.println(&quot;Hello&quot;);
</code></pre>
<p>   } </p>
<p>   }</p>
<p>更改文本文件的后缀 为 .java  </p>
<p>javac 不是内部命令 问题 </p>
<p>原因:  环境变量配置的问题 正常应该配置到jdk的bin 目录下 </p>
<p> 可能你给配置成 jre\bin 目录了  导致 找不到 javac </p>
<p> 解决 ： 重新配置  path 路径中 的 路径变成 jdk\bin  </p>
<p>path 里面原有的内容 不要删除  </p>
<p>程序代码 </p>
<p>书写规范 </p>
<p> java 区分大小写 的  </p>
<p>类名称 需要 首字母大写 </p>
<p>类名称 需要 和 文件的名称一致 </p>
<pre><code>public  class  Hello &#123; 

  //程序入口  

 public static  void  main(String[] args)&#123;

  System.out.println(&quot;Hello&quot;); 

  &#125;

&#125; 
</code></pre>
<p>符号 都是 英文的  </p>
<p>语句以;结尾</p>
<p> System.out.println(“Hello”);</p>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>1.基本数据类型</p>
<p>  整数  byte short  int  long </p>
<pre><code>byte  b=127;  -128~127

short  s=22;

int  age=23;

long  qq=222222222222;
</code></pre>
<p>  小数  float  double</p>
<pre><code>float f=1.2f;

double  d=2.3;
</code></pre>
<p>  字符  char  存单个的字符 ‘a’  “aaaa”</p>
<p>   char  sex=’男’;</p>
<p>   String  strsex=”爷们”;</p>
<p>  布尔  boolean  真假值 true/false</p>
<p> boolean  isdang=true;</p>
<p>2.引用数据类型 </p>
<p> 字符串  数组  类对象</p>
<p>练习</p>
<p>//定义 一个类 BianLiang</p>
<p>//定义一个 main 方法  </p>
<p>//在main 方法中 定义变量用来保存</p>
<p>// 姓名  身高 175  体重  65.5  年龄  是否毕业 </p>
<p>// 性别  男或女  并输出以上的变量内容</p>
<p>位数  </p>
<p>  bit  1个 0或1的二进制数据位 </p>
<p>二进制 满2 就进一   1+1–&gt;10  0 1  </p>
<p>十进制 满10就进一  9+1–&gt; 10</p>
<p>十   二</p>
<p> 5  –&gt; 101</p>
<p> 101</p>
<p> +1  </p>
<p> 6  –&gt; 110</p>
<pre><code>     1  1  1  1  1  1  1
</code></pre>
<p> 1024.. 256  128  64  32  16  8  4  2  1</p>
<p>2^10             2^3 2^2 2^1 2^0</p>
<pre><code>             1  1  1 +1

           1  0  0  0
</code></pre>
<p>1278</p>
<p>10^3  10^2  10^1   10^0</p>
<p> 1   2    7     8</p>
<p>11000+  2100+710 + 81</p>
<p>10010</p>
<p>基本数据类型 </p>
<p> 整数    byte 8      short  16     int  32    long  64  </p>
<p> 小数    float 32   double 64</p>
<p>  字符   char 16</p>
<p>  布尔   boolean 8  </p>
<p> byte 8  -128~127</p>
<p>0    0000000</p>
<p>符号位  数据位</p>
<p>符号位0: 正数 1:负数</p>
<p> 1111111</p>
<p>int 类型 21亿4千万 多 </p>
<p>2147483647</p>
<p>原码  </p>
<p>原码</p>
<p>反码 按位取反 </p>
<p>补码  原码取反+1 </p>
<p>10000000</p>
<p>01111111+1</p>
<p>10000000</p>
<p>1byte=8bit</p>
<p>1kb=1024byte</p>
<p>1mb=1024kb</p>
<p>1gb=1024mb</p>
<p>1tb=1024g</p>
<p>1pb=1024tb</p>
<p>数据类型格式</p>
<p>三个可以加字母的 </p>
<p> double d  float f  long  l</p>
<pre><code>D    F    L
</code></pre>
<p> double  sg=1.75D;</p>
<p> float  ff=1.7f;</p>
<p> long  qq=222;</p>
<p>1个可以相互转换的 </p>
<p>ascII  字符集  </p>
<p>int  &lt;&lt;——&gt;&gt; char</p>
<p>‘a’  97     ‘A’  65      ‘0’ 48     ‘   ‘ 32</p>
<p>‘b’  98     ‘B’  66      ‘1’ 49</p>
<p>‘c’  99</p>
<p>强制类型转换 </p>
<p> byte  8  short  int  long 64</p>
<p> 00000101</p>
<p>byte  b=5;</p>
<p> 00000000 00000000 00000000 00000101</p>
<p>int  i=6;</p>
<p> i=b;</p>
<p>int i=6;</p>
<p> syso(i); </p>
<p>  i=5;</p>
<p>syso(i);</p>
<p>byte  b=5; </p>
<p>int  i=256; </p>
<p>b=i;</p>
<p>System.out.println(b);</p>
<p>System.out.println(i);</p>
<p>强制类型转换会损失精度 </p>
<p>byte  b=5;</p>
<p>int  i=256;</p>
<p>b=(byte)i;</p>
<p>  强转</p>
<p>强转会损失精度 </p>
<p>大类型可以容纳小类型</p>
<p>boolean 不能转成其他的类型 </p>
<p>命名的规范  驼峰命名 </p>
<p> 变量 大部分是名词 </p>
<p> name  age  sex</p>
<p> firstName       PI 常量 固定不变 0.618  e  </p>
<p>表达式 符号 </p>
<p>+-/  % 求余数  &gt; &lt; != &gt;= &lt;=  == ,+=,-=,=,/= ,%=</p>
<p>int  a=7;</p>
<p>double  b=3;</p>
<p> //%–&gt;求余数  </p>
<p> System.out.println(a/b);</p>
<p> // a=a+b;</p>
<p> // a-=b;–&gt; a=a-b;</p>
<p>System.out.println(a);</p>
<p>System.out.println(b);</p>
<p> System.out.println(a+b); </p>
<p>逻辑运算符和位运算符 </p>
<p> 真假的 这种 </p>
<p>&amp;,&amp;&amp;  |,||  ! </p>
<p> &amp;  与 且  &amp;&amp; 短路与</p>
<p> |  或    || 短路或</p>
<p> !  非  !true –&gt; 假</p>
<p>int a=-14;</p>
<p>a&gt;2&amp;a&lt;5</p>
<p> true&amp;true  –&gt; true </p>
<p> true&amp;false  –&gt;false</p>
<p> false&amp;true  –&gt;false</p>
<p> false&amp;false  –&gt;false</p>
<p>&amp; &amp;&amp; 同真为真 </p>
<p>| ||  同假为假</p>
<p>false |false  false</p>
<p>true | false  true</p>
<p>false| true  true</p>
<p>true |true   true</p>
<p>短路  如果第一个 条件不满足 则跳过第二个判断条件 </p>
<p>3&gt;2||3&lt;2 –&gt;true </p>
<pre><code>public class Test&#123;
    public static void main(String[] args)&#123;
        int a=12;
        int b=3;
        boolean x=a&gt;b&amp;(a=a+b)&gt;b;
        System.out.println(x);
        System.out.println(a);
    &#125;
&#125;
</code></pre>
<p>自增 自减 </p>
<p> ++  – </p>
<p>一次增加1</p>
<p>int i=1;</p>
<p> //i++;</p>
<p> System.out.println(i++);</p>
<p> System.out.println(i);</p>
<h2 id="1-5"><a href="#1-5" class="headerlink" title="1-5"></a>1-5</h2><p>位运算 </p>
<p> 按照二进制位 进行计算 </p>
<p>5–&gt;101     3–&gt;&gt;011    </p>
<p>&amp;位与  同真为真</p>
<p>|位或   同假为假</p>
<p>^异或   不一样的就是真</p>
<pre><code> 5  101
</code></pre>
<p>&amp;  3  011</p>
<pre><code> 1  001



 5  101
</code></pre>
<p>|    3  011</p>
<pre><code> 7  111



 5  101
</code></pre>
<p>^   3  011</p>
<pre><code> 6  110
</code></pre>
<p>密码学</p>
<p>对称加密 和非对称加密</p>
<pre><code>明文   +秘钥--&gt;          密文

            加密算法                                   

key   2

10:30进攻   --&gt;  32:52进攻       

非对称加密：MD5
</code></pre>
<p> &lt;&lt;  左位移        &gt;&gt;  右位移 </p>
<p> 5&gt;&gt;1      2</p>
<p>5&lt;&lt;1       10</p>
<p>条件分支 判断</p>
<p>if(表达式判断条件){}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age=<span class="number">19</span>;</span><br><span class="line"><span class="keyword">if</span>(age&gt;=<span class="number">18</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;成年了！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未成年！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入身高体重判断BIM是否超标</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">        <span class="keyword">double</span> BMI;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;体重（KG）：&quot;</span>);</span><br><span class="line">        radius = input.nextDouble();</span><br><span class="line">        System.out.print(<span class="string">&quot;身高（M）：&quot;</span>);</span><br><span class="line">        <span class="keyword">double</span> tall = input.nextDouble();</span><br><span class="line">        BMI = radius / (tall * tall);</span><br><span class="line">        System.out.print(<span class="string">&quot;身体质量指数 = &quot;</span> +BMI);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入性别，判断结果</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Scanner input=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> System.out.println(<span class="string">&quot;请输入性别：&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> sex=input.nextInt();</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">if</span>(sex==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;娶媳妇！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sex==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;孤独终老&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sex==<span class="number">2</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;找老汉！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从键盘录入数据格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">//从键盘接收格式</span></span><br><span class="line">    <span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">    Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String xx=sc.next();<span class="comment">//获取字符串</span></span><br><span class="line">    String xxx=sc.nextLine();<span class="comment">//获取一行字符串</span></span><br><span class="line">    sc.nextDouble();<span class="comment">//获取数 double可以更改为int float等...</span></span><br><span class="line">    <span class="keyword">char</span> c=sc.next().charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">switch</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">switch</span><span class="params">(值)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 值：</span><br><span class="line"></span><br><span class="line">代码</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 值 <span class="number">2</span>：</span><br><span class="line"></span><br><span class="line">代码</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">代码；</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Switch</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">switch</span>(a)&#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行1&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                     <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行2&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                     <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行3&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;执行default&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>switch特点：</p>
<p>1.贯穿特性：从匹配到的位置向下执行，直到遇见break或default结束</p>
<p>2.值的类型 是可以转换成int 或者字符串的（jdk1.8）</p>
<p>while循环</p>
<p>周而复始 不断重复</p>
<p>1.while(){};</p>
<p>2.do()while{};</p>
<p>3.for(){}；</p>
<p>for的增强型</p>
<p>//如果判断条件是true 则会重复执行while{}中的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将输入的大写字母转换为小写字母</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;输入大写字母:&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> ch = scan.next().charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (ch &lt;<span class="string">&#x27;A&#x27;</span>|| ch &gt; <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;输入错误,请重新输入：&quot;</span>);</span><br><span class="line">            ch =scan.next().charAt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ch = (<span class="keyword">char</span>) (ch + <span class="number">32</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;小写字母:&quot;</span> + ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>循环的增强型</span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> kuangjia;<span class="keyword">import</span> java.util.Arrays;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFor</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;		<span class="keyword">int</span> []arr=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;		System.out.println(Arrays.toString(arr));		<span class="comment">//两种方式输入数组		for(int tmp:arr)&#123;			System.out.print(&quot; &quot;+tmp+&quot; &quot;);		&#125;	&#125;&#125;</span></span><br></pre></td></tr></table></figure>


<h2 id="1-6"><a href="#1-6" class="headerlink" title="1-6"></a>1-6</h2><p>求一个数的个十百千万位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x= <span class="number">12345</span>;System.out.println(<span class="string">&quot;个位：&quot;</span>+ x%<span class="number">10</span>);System.out.println(<span class="string">&quot;十位：&quot;</span>+(x/<span class="number">10</span>)%<span class="number">10</span>);System.out.println(<span class="string">&quot;百位：&quot;</span>+(x/<span class="number">100</span>)%<span class="number">10</span>);System.out.println(<span class="string">&quot;千位：&quot;</span>+(x/<span class="number">1000</span>)%<span class="number">10</span>);System.out.println(<span class="string">&quot;万位：&quot;</span>+(x/<span class="number">10000</span>)%<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>判断素数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断接收的数是不是素数import java.util.Scanner;public class Java&#123;   </span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;        Scanner sc=<span class="keyword">new</span> Scanner(System.in);       </span><br><span class="line">  System.out.println(<span class="string">&quot;请输入一个数：&quot;</span>);        <span class="keyword">int</span> a=sc.nextInt();        <span class="keyword">int</span> i;        <span class="keyword">boolean</span> ss=<span class="keyword">true</span>; <span class="comment">//标记；     </span></span><br><span class="line">     <span class="keyword">for</span>( i=<span class="number">2</span>;i&lt;a;i++)        &#123;            <span class="keyword">if</span>(a%i==<span class="number">0</span>)            &#123;                ss=<span class="keyword">false</span>;                <span class="keyword">break</span>;            &#125;        &#125;   </span><br><span class="line">              System.out.println(ss ? a+<span class="string">&quot;是素数&quot;</span> : a+<span class="string">&quot;是非素数&quot;</span>);    &#125;&#125;<span class="comment">//判断1000以内的素数</span></span><br><span class="line">              <span class="comment">//方法一</span></span><br><span class="line">              <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">              		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;			</span><br><span class="line">                    <span class="keyword">boolean</span> count = <span class="keyword">true</span>;<span class="comment">//*********** 			</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">2</span>; x &lt; i; x++) &#123;<span class="comment">//x = 2; x &lt; i****************			</span></span><br><span class="line">                    	<span class="keyword">if</span> (i % x == <span class="number">0</span>) &#123;					count=<span class="keyword">false</span>;				&#125;			&#125;	</span><br><span class="line">                        		<span class="keyword">if</span> (count) &#123;							System.out.println(i);			</span><br><span class="line">                                									&#125;		&#125;	&#125;&#125;</span><br><span class="line">             <span class="comment">//方法二</span></span><br><span class="line">             <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span></span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;			<span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//			</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;=i; x++) &#123;<span class="comment">//x = 1; x &lt;=i****重			</span></span><br><span class="line">             	<span class="keyword">if</span> (i % x == <span class="number">0</span>) &#123;					count++;				&#125;			&#125;		</span><br><span class="line">                	<span class="keyword">if</span> (count==<span class="number">2</span>) &#123;	<span class="comment">//count为2时才是素数			</span></span><br><span class="line">                    			System.out.println(i);											</span><br><span class="line">                                	&#125;		&#125;	</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br></pre></td></tr></table></figure>
<p>猴子吃桃</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个，第二天早上又将剩下的桃子吃了一半，又多吃一个，以后每天都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子。求第一天共摘了多少个？import java.util.Scanner;public class Java&#123;  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    	<span class="keyword">int</span> num = <span class="number">1</span>;		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;<span class="number">10</span>;i++) &#123;			num = (num+<span class="number">1</span>)*<span class="number">2</span>;		</span><br><span class="line">  &#125;		System.out.println(<span class="string">&quot;总共的桃子数为：&quot;</span>+num);	&#125;  </span><br><span class="line">    	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">九九乘法表</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java</span></span>&#123;   </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    	<span class="keyword">int</span> i,j;    	<span class="keyword">int</span> n;    	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) &#123;    		    		    		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)&#123;    			n=i*j;    			System.out.print(<span class="string">&quot; &quot;</span>+n+<span class="string">&quot; &quot;</span>);    		</span><br><span class="line"> &#125;System.out.println(<span class="string">&quot; &quot;</span>);    	&#125;			&#125;    	&#125;	</span><br></pre></td></tr></table></figure>
<p>鸡兔同笼</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for循环import java.util.Scanner;public class Java&#123;  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;    	<span class="keyword">int</span> i,j;    	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">35</span>;i++)&#123;    		   <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=<span class="number">35</span>;j++)&#123;    		   <span class="keyword">if</span>(i+j==<span class="number">35</span> &amp;&amp; <span class="number">2</span>*i+<span class="number">4</span>*j==<span class="number">94</span>)&#123;  </span><br><span class="line">    		   System.out.println(<span class="string">&quot;鸡有&quot;</span>+i+<span class="string">&quot;只&quot;</span>);    		   System.out.println(<span class="string">&quot;兔有&quot;</span>+j+<span class="string">&quot;只&quot;</span>);    	</span><br><span class="line">               	   &#125;    		  &#125;    		 &#125;    	&#125;			&#125;    	</span><br><span class="line">                   <span class="comment">//while循环</span></span><br><span class="line">                   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	        <span class="keyword">int</span> chicken = <span class="number">1</span>;	        <span class="keyword">int</span> rabbit = <span class="number">50</span> - chicken;	        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;	            <span class="keyword">if</span> (rabbit * <span class="number">4</span> + chicken *<span class="number">2</span> == <span class="number">160</span>) &#123;	       </span><br><span class="line">                            System.out.println(<span class="string">&quot;有&quot;</span> + chicken +<span class="string">&quot;只鸡&quot;</span>);	           </span><br><span class="line">                                 System.out.println(<span class="string">&quot;有&quot;</span> + rabbit + <span class="string">&quot;只兔子&quot;</span>);	   </span><br><span class="line">                                              <span class="keyword">break</span>;	            &#125;<span class="keyword">else</span>&#123;	                chicken++;	                rabbit--;	                <span class="keyword">if</span> (rabbit &lt; <span class="number">0</span>) &#123;	                  </span><br><span class="line">                                                System.out.println(<span class="string">&quot;输入的数字有误&quot;</span>);	                    <span class="keyword">break</span>;	          </span><br><span class="line">                                                      &#125;	            &#125;	        &#125;	       	        	    &#125;&#125;	</span><br></pre></td></tr></table></figure>
<p>*三角图形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">5</span> - i; j++) &#123;			System.out.print(<span class="string">&quot; &quot;</span>);		&#125;				<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span> * i - <span class="number">1</span>; k++) &#123;			System.out.print(<span class="string">&quot;*&quot;</span>);		&#125;		System.out.println();	&#125;System.out.println();	&#125;&#125;运行结果：     *    ***   *****  ******* *********</span><br><span class="line"></span><br><span class="line">反转输出</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;	System.out.println(<span class="string">&quot;请输入一个正整数：&quot;</span>);    Scanner sc=<span class="keyword">new</span> Scanner(System.in);    <span class="keyword">int</span> num=sc.nextInt();    <span class="keyword">int</span> a=<span class="number">0</span>;    <span class="keyword">for</span>(<span class="keyword">int</span> i=num;i&gt;<span class="number">0</span>;i/=<span class="number">10</span>)<span class="comment">//循环的形式求个十百位*******************************    &#123;            a=a*10+i%10;  //*********************************************                                   &#125;         System.out.println(num+&quot;最终逆序的结果是：&quot;+a);         &#125;&#125;</span></span><br><span class="line"></span><br><span class="line">冒泡排序</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		<span class="keyword">int</span> arr[] = &#123; <span class="number">32</span>, <span class="number">67</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">1</span>, <span class="number">30</span> &#125;;		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;			<span class="keyword">int</span> min = i;			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;<span class="number">6</span>; j++) &#123;				<span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;					<span class="keyword">int</span> t=arr[j];					arr[j]=arr[min];					arr[min]=t;				&#125;			&#125;		&#125;		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;			System.out.println(arr[i]);		&#125;	&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-7"><a href="#1-7" class="headerlink" title="1-7"></a>1-7</h2><p>去数据  组新数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> oldArr[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">5</span>&#125; ;要求将以上数组中值为<span class="number">0</span>的项去掉，将不为<span class="number">0</span>的值存入一个新的数组，生成的新数组    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span></span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;		<span class="keyword">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">5</span>&#125; ;		<span class="keyword">int</span> num = <span class="number">0</span>;		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;			<span class="keyword">if</span>(a[i]!=<span class="number">0</span>)&#123;				num++;			&#125;		&#125;			<span class="keyword">int</span> b[]=<span class="keyword">new</span> <span class="keyword">int</span>[num];			<span class="keyword">int</span> c=<span class="number">0</span>;			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;				<span class="keyword">if</span>(a[i]!=<span class="number">0</span>)&#123;					b[c]=a[i];					c++;				&#125;			&#125;						<span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;b.length;n++)&#123;				System.out.print(b[n]+<span class="string">&quot; &quot;</span>);		&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">数组排序、合并简便算法</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> java.util.Arrays;</span><br><span class="line">    <span class="comment">//导jar包</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span></span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">    	<span class="keyword">int</span> [] A = &#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>&#125;;		<span class="keyword">int</span> [] B = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>&#125;;	</span><br><span class="line">        	<span class="keyword">int</span> [] C = Arrays.copyOf(A,A.length+B.length);<span class="comment">//		</span></span><br><span class="line">            System.arraycopy(B, <span class="number">0</span>, C, A.length, B.length);<span class="comment">//		</span></span><br><span class="line">            Arrays.sort(C);<span class="comment">//数组排序		for(int i=0;i&lt;C.length;i++)&#123;		</span></span><br><span class="line">            	System.out.print(C[i]+<span class="string">&quot; &quot;</span>);		&#125;	&#125;&#125;</span><br><span class="line"></span><br><span class="line">杨辉三角</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> java.util.Scanner; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		Scanner sc = <span class="keyword">new</span> Scanner(System.in);		System.out.println(<span class="string">&quot;请输入一个整数n:&quot;</span>);		<span class="keyword">int</span> n = sc.nextInt();		<span class="keyword">int</span> [][] arr = <span class="keyword">new</span> <span class="keyword">int</span> [n][n];		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;				<span class="keyword">if</span>(j==<span class="number">0</span>)&#123;					arr[i][j]=<span class="number">1</span>;				&#125;<span class="keyword">else</span>&#123;					arr[i][j]=arr[i-<span class="number">1</span>][j-<span class="number">1</span>]+arr[i-<span class="number">1</span>][j];				&#125;							&#125;		&#125;		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;				System.out.print(arr[i][j]+<span class="string">&quot; &quot;</span>);			&#125;			System.out.println();		&#125;	&#125;&#125;	</span><br></pre></td></tr></table></figure>



<h2 id="1-11"><a href="#1-11" class="headerlink" title="1-11"></a>1-11</h2><p>数组</p>
<p>类型[]数组名称=new 类型[长度]；/动态定义 </p>
<p>int [] ages=new int[3];</p>
<p>ages[0]=22;</p>
<p>ages[1]=23;</p>
<p>ages[2]=33</p>
<p>类型[] 数组名={值，值，值}//静态的初始化</p>
<p>ages[]={2,3,4}重新定义一个静态初始化；</p>
<p>int[]ages=new int[3];</p>
<p>Scanner sc=new Scanner(System.in);</p>
<p>for(int i=0;i&lt;ages.length;i++){</p>
<p>ages[i]=sc.next();</p>
<p>}</p>
<p>int sum=0;</p>
<p>for(int i=0;i&lt;ages.length;i++){</p>
<p>System.out.println(“ages[i]”);</p>
<p>sum+=ages[i];</p>
<p>}</p>
<p>数组的内存模型</p>
<p>内存   jvm    堆  heap   大  查询速度慢</p>
<pre><code>                 栈  stack   小  查询速度快
</code></pre>
<p>硬盘</p>
<p>cpu</p>
<p>System.gc();垃圾回收机制；</p>
<p>Arryays.tostring方法</p>
<pre><code>import java.util.Arrays;public class Z &#123;    public static void main(String[] args) &#123;        int arr[]=&#123;2,3,4,5&#125;;        int[] arr3=arr;        String xxx=Arrays.toString(arr3);        System.out.println(xxx);            &#125;&#125;
</code></pre>
<p>Math.radom()   随机数 </p>
<pre><code>int [] a=&#123;22,·,44&#125;;int rr=(int)(Math.radom()*a.length);System.out.println(rr);//22或33或44(int)(Math.Random() * n)           返回大于等于 0 小于 n 的随机数m + (int)(Math.Random()  *n)       返回大于等于 m 小于 m+n (不包括 m+n )的随机数
</code></pre>
<p>***重难点</p>
<p>测试随机数</p>
<pre><code>int[] arr=new int[10000];            for (int i=0;i&lt;10000;i++)&#123;                arr[i]=(int)(Math.random()*2);            &#125;            int zeroNum=0;            int one=0;            for (int i=0;i&lt;10000;i++)&#123;                if(arr[i]==0)                    zeroNum++;                else                    one++;            &#125;            System.out.println(&quot;0个数:&quot;+zeroNum+&quot;,1个数:&quot;+one);
</code></pre>
<h2 id="1-12"><a href="#1-12" class="headerlink" title="1-12"></a>1-12</h2><p>oop面向对象</p>
<p>封装  继承  多态  抽象</p>
<p>面向过程</p>
<p>面向对象</p>
<p>面向接口     M      V      C</p>
<p>面向方面     AOP   项目    天气预报</p>
<p>面向服务     项目    天气预报</p>
<p>类和对象</p>
<p>类：一类具有相同特征和功能的事物的抽象    是一种模板</p>
<p>例：</p>
<p>描述一个桌子 特征 功能</p>
<p>材质  腿  长宽高  颜色  形状</p>
<p>对象</p>
<pre><code>public class table&#123;    int leg=4;    String shape=&quot;长方形&quot;;    public void fangdongxi()&#123;        System.out.println(&quot;放东西&quot;)    &#125;    public static void main(String[] args)&#123;        Table t=new Table();        System.out.println(t.leg);    &#125;&#125;
</code></pre>
<p>抽象一个 学生类 </p>
<p> 姓名 年龄  性别  学号  </p>
<pre><code>public  class Student&#123;  String  name;  int age;  String  sex;  String  stuno;&#125;public  class TestStudent&#123; public static void main(String[] args)&#123;  Student stu=new Student();     stu.name=&quot;张三疯&quot;;     stu.age=22;  &#125; &#125; 
</code></pre>
<p> 定义  方法 的参数列表    方法的返回值类型 </p>
<p> 参数：  在调用方法时将 值传入到 方法内部 </p>
<p>返回值： 在调用完方法时 想得到 方法运算的结果  </p>
<pre><code>public  boolean  eat(String food,int num  )&#123;    syso(&quot;吃&quot;+food);   if(num&gt;3)&#123;    return  false;    &#125;    return true;&#125;//加法  public  int  add(int aa,int b)&#123; return aa+b;&#125;
</code></pre>
<p>练习 定义一个类 JiSuanQi</p>
<p>//加减乘除 四个方法 </p>
<p>1.每个方法都有参数  还有返回值类型 </p>
<p>2.定义一个测试类 调用  加减乘除方法 并 接收其结果 进行输出 </p>
<p>overload 好处  调用时 不需要特别记住方法名称 会自动匹配</p>
<p>通过参数列表 来区分 </p>
<p> 先精确匹配 ，如果 没有 匹配的方法 可以扩大范围 模糊匹配  </p>
<p> int int  </p>
<p> int double</p>
<p> double  double  </p>
<p>各数据类型大小、默认值、范围</p>
<pre><code>package oop;abstract class A &#123;        static byte a;    static short b;    static int c;    static long d;    static float e;    static double f;    static char g;    static boolean h;        //String不是基本类型    static String str1 = &quot;&quot;;//生成一个String类型的引用，而且分配内存空间来存放&quot;&quot;;    static String str2; //只生成一个string类型的引用；不分配内存空间,默认为null     public static void main(String[] args) &#123;            System.out.println(&quot;byte的大小：&quot;+Byte.SIZE+&quot; byte的默认值：&quot;+a+&quot; byte的数据范围：&quot;+Byte.MIN_VALUE+&quot;~&quot;+Byte.MAX_VALUE);         System.out.println(&quot;short的大小：&quot;+Short.SIZE+&quot; short的默认值：&quot;+b+&quot; short的数据范围：&quot;+Short.MIN_VALUE+&quot;~&quot;+Short.MAX_VALUE);         System.out.println(&quot;int的大小：&quot;+Integer.SIZE+&quot; int的默认值：&quot;+c+&quot; int的数据范围：&quot;+Integer.MIN_VALUE+&quot;~&quot;+Integer.MAX_VALUE);         System.out.println(&quot;long的大小：&quot;+Long.SIZE+&quot; long的默认值：&quot;+d+&quot; long的数据范围：&quot;+Long.MIN_VALUE+&quot;~&quot;+Long.MAX_VALUE);         System.out.println(&quot;float的大小：&quot;+Float.SIZE+&quot; float的默认值：&quot;+e+&quot; float的数据范围：&quot;+Float.MIN_VALUE+&quot;~&quot;+Float.MAX_VALUE);         System.out.println(&quot;double的大小：&quot;+Double.SIZE+&quot; double的默认值：&quot;+f+&quot; double的数据范围：&quot;+Double.MIN_VALUE+&quot;~&quot;+Double.MAX_VALUE);         System.out.println(&quot;char的大小：&quot;+Character.SIZE+&quot; char的默认值：&quot;+g+&quot; char的数据范围：&quot;+Character.MIN_VALUE+&quot;~&quot;+Character.MAX_VALUE);         System.out.println(&quot;boolean的大小：&quot;+Byte.SIZE+&quot; boolean的默认值：&quot;+h+&quot; boolean的数据范围：&quot;+Byte.MIN_VALUE+&quot;~&quot;+Byte.MAX_VALUE);               System.out.println(&quot;String字符串的默认值：&quot;+str1+&quot;str的默认长度：&quot;+str1.length());         System.out.println(&quot;String字符串的默认值：&quot;+str2);              &#125;&#125;运行结果：    byte的大小：8 byte的默认值：0 byte的数据范围：-128~127    short的大小：16 short的默认值：0 short的数据范围：-32768~32767    int的大小：32 int的默认值：0 int的数据范围：-2147483648~2147483647    long的大小：64 long的默认值：0 long的数据范围：-9223372036854775808~9223372036854775807    float的大小：32 float的默认值：0.0 float的数据范围：1.4E-45~3.4028235E38    double的大小：64 double的默认值：0.0 double的数据范围：4.9E-324~1.7976931348623157E308    char的大小：16 char的默认值：
</code></pre>
<h2 id="1-13"><a href="#1-13" class="headerlink" title="1-13"></a>1-13</h2><p>动态参数列表</p>
<p>动态参数列表  </p>
<p>四个参数 做和</p>
<pre><code>public  int  add(int a,int b,int c,int d)&#123;   &#125;不固定的参数做和  public int jia(int[] arr)&#123;     int sum=0;        for(int i=0;i&lt;arr.length;i++)&#123;             sum+=arr[i];         &#125;        return sum;     &#125;
</code></pre>
<p>方法之间的调用  以及 构造方法  </p>
<p>字符串判断是否相等用.equals()</p>
<p>计算器  </p>
<p>加减乘除 </p>
<p> 定义一个计算的方法   根据 传入的符号 决定 调用 上面的加减乘除方法</p>
<pre><code>计算    符号  
</code></pre>
<p>构造方法 </p>
<p>构造方法：</p>
<p> 访问修饰符  类名 (参数列表 ){}</p>
<p>public  Student( ){} </p>
<p>new  Student();</p>
<p>普通方法 ：</p>
<p>访问修饰符  返回类型  名 (参数列表){ 方法体  }</p>
<p>public   int  add(int a,int b  ){</p>
<p>return  a+b;}</p>
<p>JiSuanQi jsq=new JiSuanQi();</p>
<p>  jsq.add(2,3);</p>
<p>构造方法的作用  :给属性赋值</p>
<p>用构造方法 设计 计时器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTime</span> </span>&#123;</span><br><span class="line"><span class="comment">//    其中应有三个整型成员：时（hour），分（minute），秒（second）    int hour;    int minute;    int second;</span></span><br><span class="line"><span class="comment">//    为MyTime类定义构造方法，以方便创建对象时初始化成员变量。   </span></span><br><span class="line"> MyTime(<span class="keyword">int</span> hour,<span class="keyword">int</span> minute,<span class="keyword">int</span> second)&#123;        <span class="keyword">this</span>.hour = hour;        <span class="keyword">this</span>.minute = minute;        <span class="keyword">this</span>.second = second;    &#125;</span><br><span class="line"> <span class="comment">//    再定义diaplay方法，用于将时间信息打印出来。    </span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">dispaly</span><span class="params">()</span></span>&#123;        System.out.println(hour+<span class="string">&quot;:&quot;</span>+minute+<span class="string">&quot;:&quot;</span>+second);    &#125;</span><br><span class="line"> <span class="comment">//    为MyTime类添加以下方法：   分别对时、分、秒进行加减运算。    </span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">addSecond</span><span class="params">(<span class="keyword">int</span> sec)</span></span>&#123;        minute += (second+sec)/<span class="number">60</span>;        second = (</span><br><span class="line"> second+sec)%<span class="number">60</span>;        hour += minute/<span class="number">60</span>;        minute = minute%<span class="number">60</span>;        hour = hour%<span class="number">24</span>;        dispaly();      <span class="comment">//打印时间    &#125;  </span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addMinute</span><span class="params">(<span class="keyword">int</span> min)</span></span>&#123;        hour += (minute+min)/<span class="number">60</span>;        minute = (minute+min)%<span class="number">60</span>;        hour = hour%<span class="number">24</span>;        dispaly();    &#125;    <span class="function"><span class="keyword">void</span> <span class="title">addHour</span><span class="params">(<span class="keyword">int</span> hou)</span></span>&#123;        hour = (hour+hou)%<span class="number">24</span>;        dispaly();    &#125;    <span class="function"><span class="keyword">void</span> <span class="title">subSecond</span><span class="params">(<span class="keyword">int</span> sec)</span></span>&#123;        <span class="keyword">if</span>(second &gt;= (sec%<span class="number">60</span>))&#123;            second -= sec%<span class="number">60</span>;        &#125;<span class="keyword">else</span>&#123;            second = <span class="number">60</span>+second-sec%<span class="number">60</span>;            minute--;            <span class="keyword">if</span>(minute == -<span class="number">1</span>)&#123;                minute = <span class="number">59</span>;                hour--;                <span class="keyword">if</span>(hour == -<span class="number">1</span>)&#123;                    hour = <span class="number">23</span>;                &#125;            &#125;        &#125;        <span class="keyword">if</span>(minute &gt;= sec/<span class="number">60</span>%<span class="number">60</span>)&#123;            minute -= sec/<span class="number">60</span>%<span class="number">60</span>;        &#125;<span class="keyword">else</span> &#123;            minute = <span class="number">24</span>+minute-sec/<span class="number">60</span>%<span class="number">60</span>;            hour --;            <span class="keyword">if</span>(hour == -<span class="number">1</span>)&#123;                hour = <span class="number">23</span>;            &#125;        &#125;        <span class="keyword">if</span>(hour &gt;= sec/<span class="number">60</span>/<span class="number">60</span>%<span class="number">24</span>)&#123;            hour -= sec/<span class="number">60</span>/<span class="number">60</span>%<span class="number">24</span>;        &#125;<span class="keyword">else</span> &#123;            hour = <span class="number">24</span>+hour-sec/<span class="number">60</span>/<span class="number">60</span>%<span class="number">24</span>;        &#125;        dispaly();    &#125;    <span class="function"><span class="keyword">void</span> <span class="title">subMinute</span><span class="params">(<span class="keyword">int</span> min)</span></span>&#123;        <span class="keyword">if</span>(minute &gt;= min%<span class="number">60</span>)&#123;            minute -= min%<span class="number">60</span>;        &#125;<span class="keyword">else</span> &#123;            minute = <span class="number">60</span>+minute-min%<span class="number">60</span>;            hour--;            <span class="keyword">if</span>(hour == -<span class="number">1</span>)&#123;                hour = <span class="number">23</span>;            &#125;        &#125;        <span class="keyword">if</span>(hour &gt;= min/<span class="number">60</span>%<span class="number">24</span>)&#123;            hour -= min/<span class="number">60</span>%<span class="number">24</span>;        &#125;<span class="keyword">else</span>&#123;            hour = <span class="number">24</span>+hour-min/<span class="number">60</span>%<span class="number">24</span>;        &#125;        dispaly();    &#125;    <span class="function"><span class="keyword">void</span> <span class="title">subHour</span><span class="params">(<span class="keyword">int</span> hou)</span></span>&#123;        <span class="keyword">if</span>(hour &gt;= hou%<span class="number">24</span>)&#123;            hour -= hou%<span class="number">24</span>;        &#125;<span class="keyword">else</span>&#123;            hour = <span class="number">24</span>+hour-hou%<span class="number">24</span>;        &#125;        dispaly();    &#125;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        MyTime time = <span class="keyword">new</span> MyTime(<span class="number">20</span>,<span class="number">23</span>,<span class="number">34</span>);        time.addSecond(<span class="number">110</span>);        time.addMinute(<span class="number">100</span>);        time.addHour(<span class="number">90</span>);        time.subSecond(<span class="number">80</span>);        time.subMinute(<span class="number">70</span>);        time.subHour(<span class="number">60</span>);     &#125; &#125;</span><br></pre></td></tr></table></figure>


<p> 构造方法如果不定义 系统会自动添加一个无参数的构造方法 </p>
<pre><code>       但是 如果 定义了 构造方法 则系统不会添加无参数的构造方法了

    建议 如果 加了有参数的构造方法 一定要加上无参数的构造方法
</code></pre>
<p>this()和this.</p>
<p>this.属性 方法 调用 本类的 属性 和方法 </p>
<p> public  Student (String name){</p>
<p>  this.name=name;</p>
<p>   }</p>
<p>this() 构造方法之间的调用</p>
<p>  1.用来 调用 其他的构造方法 </p>
<p>  2.一定在构造方法的第一行中使用  </p>
<p>封装  </p>
<p>封装  保护  </p>
<p>访问修饰符 </p>
<p>public   共有的</p>
<p>private   私有的</p>
<p>protected  受保护的</p>
<p>不写    默认的 </p>
<p>访问修饰符 可以修饰  方法和 属性 </p>
<pre><code>               本类           子类          本包其他类          其他包其他类
</code></pre>
<p>public           √                 √                      √                       √</p>
<p>private         √                 X                      X                       X</p>
<p>protected    √                 √                      √                       X                  如果子类在其他包也行</p>
<p>不写              √                 √                      √                       X                  子类也不行</p>
<p>封装    保护属性</p>
<p>封装  将属性私有化  开放公有的get set 方法  </p>
<p>  private  int  age ;</p>
<p> //get方法  得到 属性的值 </p>
<p>  public  int  getAge(){</p>
<pre><code>return  age;
</code></pre>
<p>   }</p>
<p>//set方法  设置属性值 </p>
<p>  public  void  setAge(int age){</p>
<pre><code>this.age=age;
</code></pre>
<p>   }</p>
<p>快速的生成方式  </p>
<p> eclipse //alt+shift+s–&gt; r  </p>
<pre><code>idea//alt+insert
</code></pre>
<p>继承  </p>
<p>extends</p>
<p>爷爷  extends  Object </p>
<p> ↓</p>
<p>父亲  extends 爷爷</p>
<p> ↓</p>
<p>儿子  extends  父亲</p>
<p>1.关键字  extends  继承是有方向性的 单继承   子类继承父类</p>
<p>2.子类可以使用父类非私有的属性和方法 </p>
<p>3.子类可以通过 super 关键字调用父类的属性或方法 </p>
<pre><code> this.属性或方法  调用的本类自己的 属性 或方法  
</code></pre>
<p>继承的意义何在 </p>
<p>继承关系的两个类 父类 可以提供一种默认的行为方式 子类 也可以通过重写的方式 按照自己的方式执行 </p>
<p>重写 override</p>
<p>父子类中的某个方法 声明部分 一样 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">建立一个汽车Auto类，包括轮胎个数，汽车颜色，车身重量、速度等成员变量。并通过不同的构造方法创建实例。至少要求： 汽车能够加速，减速，停车。 再定义一个小汽车类Car，继承Auto，并添加空调、CD等成员变量，     重点：覆盖父类 加速，减速的方法<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Auto</span> </span>&#123;	 <span class="keyword">int</span>  luntai;	 <span class="keyword">int</span> weight;	 <span class="keyword">int</span> speed;	 String color;	    Auto( <span class="keyword">int</span>  luntai,<span class="keyword">int</span> weight,<span class="keyword">int</span> speed,String color)&#123;	    	<span class="keyword">this</span>.color=color;	    	<span class="keyword">this</span>.luntai=luntai;	    	<span class="keyword">this</span>.speed=speed;	    	<span class="keyword">this</span>.weight=weight;	    		    &#125;	    <span class="function"><span class="keyword">void</span> <span class="title">jiasu</span><span class="params">()</span> </span>&#123;	        <span class="keyword">this</span>.speed+=<span class="number">10</span>;	        	    &#125;	    <span class="function"><span class="keyword">void</span> <span class="title">jiansu</span><span class="params">()</span> </span>&#123;	        <span class="keyword">this</span>.speed-=<span class="number">10</span>;	    &#125;	    <span class="function"><span class="keyword">void</span> <span class="title">tingche</span><span class="params">()</span> </span>&#123;	        <span class="keyword">this</span>.speed=<span class="number">0</span>;	        System.out.println(<span class="string">&quot;车已停！&quot;</span>);	    &#125;&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Auto</span></span>&#123;	String kongtiao;	String CD;	Car(<span class="keyword">int</span> luntai, <span class="keyword">int</span> weight, <span class="keyword">int</span> speed, String color,String kongtiao,String CD) &#123;		<span class="keyword">super</span>(luntai, weight, speed, color);		<span class="keyword">this</span>.kongtiao=kongtiao;		<span class="keyword">this</span>.CD=CD;	&#125;	  <span class="function"><span class="keyword">void</span> <span class="title">jiansu</span><span class="params">()</span>	    </span>&#123;	        <span class="keyword">this</span>.speed-=<span class="number">20</span>;	    &#125;	    <span class="function"><span class="keyword">void</span> <span class="title">jiasu</span><span class="params">()</span> </span>&#123;	        <span class="keyword">this</span>.speed+=<span class="number">20</span>;	        	    &#125;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		Auto auto=<span class="keyword">new</span> Auto(<span class="number">4</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="string">&quot;black&quot;</span>);		auto.jiansu();        System.out.println(auto.speed);        auto.jiansu();        System.out.println(auto.speed);                Car car=<span class="keyword">new</span> Car(<span class="number">6</span>,<span class="number">10</span>,<span class="number">300</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;you&quot;</span>,<span class="string">&quot;Something just like this&quot;</span>);        car.jiasu();        System.out.println(car.speed);        car.jiansu();        System.out.println(car.speed);	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>重载  overload </p>
<p> 同一类中方法名相同 参数列表不同  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vehicle类package oop;public class Vehicles &#123;String brand;String color;public Vehicles(String brand,String color)&#123;    this.brand=brand;    this.color=color;&#125;void run()&#123;	System.out.println(&quot;我已经开动了&quot;);&#125;void showInfo()&#123;	System.out.println(brand);	System.out.println(color);&#125;&#125;//Car类package oop;public class Car extends Vehicles &#123;	public Car c;	private int seats;void showCar()&#123;System.out.println(&quot;座位： &quot;  + seats + &quot; 个&quot;);&#125;public Car(String color,String brand,int seats)&#123;	 super(brand, color);	this.seats=seats;&#125;&#125;//Truck类	package oop;	public class Truck extends Vehicles&#123;		    private float load;		     public Truck(String brand, String color,float load) &#123;		         		         super(brand, color);		         this.load=load;		         // TODO Auto-generated constructor stub		     &#125;		     public void showTruck()&#123;		         super.showInfo();		         System.out.println(&quot;载重&quot;+load+&quot;吨&quot;);		     &#125;		 &#125; //测试类	package oop;public class Test &#123;	public static void main(String[] args) &#123;		         		         Vehicles v=new Vehicles(&quot;奥迪&quot;, &quot;黑色&quot;);		         v.showInfo();		         		         Car c= new Car(&quot;大众&quot;, &quot;红色&quot;, 6);		         c.showCar();		         		         Truck truck = new Truck(&quot;解放&quot;, &quot;蓝色&quot;, 10);		           truck.showTruck();		    &#125;&#125;</span></span><br></pre></td></tr></table></figure>






<h2 id="1-15"><a href="#1-15" class="headerlink" title="1-15"></a>1-15</h2><p>多态</p>
<pre><code> //多态: 父类的变量  指向了一个子类的对象  

 // p的表现形式取决于定义部分  p.都是 Pet 类中的属性和方法

 // 只有在子类中重写了该方法才走子类的 
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** * 【练习题】1.多态练习   1.定义一个Animal父类，方法有eat();	2.定义三个子类；			Cat,Dog,Eagle;			每个子类增加新的方法,并重写eat();	3.利用多态性			定义一个Animal类型的变量a，并将不同子类的实例赋给a；			调用eat();观察结果后，并理解多态	4.思考，如果a的引用指向一个Cat,如何调用Cat的新增方法； */</span> <span class="keyword">package</span> com.Oracle.oop4; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;		System.out.println(<span class="string">&quot;吃吃&quot;</span>);	&#125; &#125; <span class="keyword">package</span> com.Oracle.oop4; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123; 	<span class="meta">@Override</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;		System.out.println(<span class="string">&quot;咦，这是谁掉落的小鱼干(= =+)&quot;</span>);	&#125; 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scorn</span><span class="params">()</span> </span>&#123;		System.out.println(<span class="string">&quot;蔑视尔等凡人&quot;</span>);	&#125; &#125; <span class="keyword">package</span> com.Oracle.oop4; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;		System.out.println(<span class="string">&quot;汪汪汪，我什么都吃哒~&quot;</span>);	&#125;		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adhere</span><span class="params">()</span> </span>&#123;		System.out.println(<span class="string">&quot;不粘人的狗不是好狗&quot;</span>);	&#125;&#125; <span class="keyword">package</span> com.Oracle.oop4; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Eagle</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; 	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;		System.out.println(<span class="string">&quot;作为一只鹰，吃肉不是理所当然的吗&quot;</span>);	&#125;	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;		System.out.println(<span class="string">&quot;想飞上天，和太阳肩并肩&quot;</span>);	&#125; &#125; <span class="keyword">package</span> com.Oracle.oop4; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Polymorphic1</span> </span>&#123; 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		Animal a=<span class="keyword">new</span> Cat();		a.eat();		a=<span class="keyword">new</span> Dog();		a.eat();		a=<span class="keyword">new</span> Eagle();		a.eat();		<span class="keyword">if</span>(a <span class="keyword">instanceof</span> Cat) &#123;			Cat c=(Cat)a;			c.scorn();		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Dog) &#123;			Dog d=(Dog)a;			d.adhere();		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a <span class="keyword">instanceof</span> Eagle) &#123;			Eagle e=(Eagle)a;			e.fly();		&#125;	&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>实例运算符  </p>
<p> 对象  instanceof  类型</p>
<p> 判断 对象是否是 该类型的 </p>
<p>+代表公有</p>
<p>-代表私有</p>
<p>#代表保护</p>
<h2 id="1-18"><a href="#1-18" class="headerlink" title="1-18"></a>1-18</h2><p>封装</p>
<p>私有化  属性  开放共有的 get set 方法</p>
<p> is   a的关系 继承</p>
<p> use a 使用  依赖关系</p>
<p> has a  拥有  聚合关系</p>
<p>修饰符 </p>
<pre><code>                 属性              方法               类
</code></pre>
<p>静态 static      √                   √                   X</p>
<p>最终 final       √                    √                   √  </p>
<p>   static  静态的 跟类走 全局唯一</p>
<p> 非静态的跟对象走 </p>
<p>static  </p>
<p>静态属性和静态方法  </p>
<p> 通过类名.静态的属性方法 的方式进行调用           </p>
<p>静态 先于 非静态</p>
<p>普通方法 可以直接  调用 普通方法 和属性 </p>
<p>普通方法 可以直接  调用 静态方法 和静态属性</p>
<p>静态方法 不能直接  调用 普通方法 和普通属性</p>
<p>静态方法 可以直接  调用 静态方法和静态属性</p>
<p>块  </p>
<p>{  }  一段代码 </p>
<p>静态块   static{  代码}  全局唯一  只加载一次 </p>
<p>非静态块   { 代码   }  跟对象走</p>
<p>同等级别的块和属性 谁在上面先加载谁</p>
<p>静态的 属性和块 谁在上面先加载谁 </p>
<p>非静态的 属性和块  谁在上面先加载谁</p>
<p>类的 加载顺序  </p>
<p> new  类(); </p>
<p> 静态属性和块  非静态的属性和块–&gt; 构造方法 –&gt; 普通方法</p>
<p>final </p>
<p>最终的</p>
<p>可以修饰 类 属性 方法 </p>
<p>修饰类  不能被继承</p>
<p>修饰方法 不能被重写</p>
<p>修饰属性 不能改值  是常量  </p>
<p>public  static  int  age; </p>
<p> final  int  age=9;</p>
<p>抽象  abstract  </p>
<p>可以修饰    类   方法 </p>
<p>修饰类 叫抽象类  </p>
<pre><code>1.不能自己new 自己  

2.抽象类中可以有抽象方法  
</code></pre>
<p>修饰方法 叫抽象方法  </p>
<pre><code>抽象的方法  没有 方法体 只能定义在抽象类中
</code></pre>
<p>public  abstract  class  Chou{</p>
<p>   public  abstract  void  c(  );</p>
<p> main(){</p>
<p> Chou cc=new Chou();  X 不可以的  </p>
<p>} </p>
<p>}</p>
<p>意义 何在 :</p>
<p>抽象类中的抽象方法 是一种协议 用来限定 其子类中一定会实现该方法 </p>
<p>倾向于是一种协议规范 </p>
<p>修饰符 </p>
<pre><code>            属性   方法   类
</code></pre>
<p>静态 static   √    √    X</p>
<p>最终 final    √    √    √ </p>
<p>抽象 abstract   X    √     √ </p>
<p>接口 interface  </p>
<p> 接口 是 纯粹的 一种协议 一种规范 用来限定子类的行为模式 特点是</p>
<p>1.接口中的方法都是抽象的共有方法</p>
<p>2.接口中的属性都是共有的静态常量 </p>
<pre><code>public interface Ipad&#123;  static  final int  RONGLIANG=4000;   void  play(); &#125; public  class HuaiWeiPad  implements  Ipad,其他接口&#123;   public  void  play()&#123;  syso(&quot;播放视频&quot;);  &#125;  &#125;
</code></pre>
<h2 id="1-19"><a href="#1-19" class="headerlink" title="1-19"></a>1-19</h2><p>Object </p>
<p>包含 方法</p>
<p>Object中的方法 </p>
<p> equals 方法</p>
<p>比较两个对象 是否 相等  </p>
<p>== 是比较两个对象的地址</p>
<p>this  指的是当前的对象</p>
<p>obj 是传入的对象  </p>
<p>Object </p>
<p>hashCode() 得到对象地址有关的一串数 </p>
<p>1.如果 两个对象的 hash码不一样 则一定不是一个对象</p>
<p>2.如果 两个对象的 hash 码相同 不一定是一个对象 </p>
<p>***重难点</p>
<pre><code>package oop;public class StringTest &#123;    public static void main(String[] args) &#123;              String s=&quot;卡巴斯基#杀毒软件#免费版#俄罗斯#&quot;;        String name[]=s.split(&quot;#&quot;);        for(String i:name)        &#123;            System.out.println(i);        &#125;&#125;&#125;结果为：卡巴斯基 杀毒软件 免费版 俄罗斯 总结：     for(String i:name)         &#123;            System.out.println(i);        &#125;         相当于：     for(int i=0;i&lt;name.length;i++)         &#123;            System.out.println(name[i]);        &#125;

//求出字符串中有多少种字符，以及每个字符的个数package oop;public class StringTest &#123;     public static void main(String[] args) &#123;                       String s=&quot;apple is a apple.&quot;;            while(s.length()&gt;0)            &#123;                int h=s.length();            String  a=s.charAt(0)+&quot;&quot;;            s=s.replace(a,&quot;&quot;);            System.out.println(a+&quot;:&quot;+(h-s.length()));                        &#125;        &#125;        &#125;运行结果：a:3p:4l:2e:2 :3i:1s:1.:1
</code></pre>
<h2 id="1-20"><a href="#1-20" class="headerlink" title="1-20"></a>1-20</h2><p>字符串常用方法</p>
<p>1、字符串比较compareTo、compareToIgnoreCase<br>2、字符串查找indexOf、lastIndexOf<br>3、删除字符串<br>4、字符串替代replace、replaceAll<br>5、字符串反转reverse<br>6、字符串转变大小写toUpperCase、toLowerCase<br>7、去掉首位空格trim<br>8、是否包含某字符/字符串contains<br>9、返回指定位置字符charAt</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;    String str1 = <span class="string">&quot;Hello World&quot;</span>;    String str2 = <span class="string">&quot;Hello World&quot;</span>;    String str3 = <span class="string">&quot;hello world&quot;</span>;    String str4 = <span class="string">&quot; hello world &quot;</span>;  <span class="comment">//字符串比较字符串比较compareTo(返回的是int),0相等，复数小于，正数大于   </span></span><br><span class="line">    System.out.println(<span class="string">&quot;r1 : &quot;</span> + str1.compareTo(str2));    </span><br><span class="line">              System.out.println(<span class="string">&quot;r2 : &quot;</span> + str1.compareTo(str3));    <span class="comment">//字符串比较compareToIgnoreCase，忽略大小写。0相等，复数小于，正数大于    </span></span><br><span class="line">      System.out.println(<span class="string">&quot;r3 : &quot;</span> + str1.compareToIgnoreCase(str3));    <span class="comment">//字符串查找indexOf，返回的是找到的第一个的位置，没找到返回-1。从0开始    </span></span><br><span class="line">       System.out.println(<span class="string">&quot;r4 : &quot;</span> + str1.indexOf(<span class="string">&quot;o&quot;</span>));    <span class="comment">//查找字符串最后一次出现的位置lastIndexOf    </span></span><br><span class="line">       System.out.println(<span class="string">&quot;r5 : &quot;</span> + str1.lastIndexOf(<span class="string">&quot;o&quot;</span>));    <span class="comment">//删除字符串中的一个字符,字符串从0开始的 substring(a, b)返回指定起始位置（含）到结束位置（不含）之间的字符串    </span></span><br><span class="line">       System.out.println(<span class="string">&quot;r6 : &quot;</span> + str1.substring(<span class="number">0</span>, <span class="number">5</span>) + str1.substring(<span class="number">6</span>));    <span class="comment">//字符串替换,替换所有  </span></span><br><span class="line">         System.out.println(<span class="string">&quot;r7 : &quot;</span> + str1.replace(<span class="string">&quot;o&quot;</span>, <span class="string">&quot;h&quot;</span>));    <span class="comment">//字符串替换,替换所有   </span></span><br><span class="line">          System.out.println(<span class="string">&quot;r8 : &quot;</span> + str1.replaceAll(<span class="string">&quot;o&quot;</span>, <span class="string">&quot;h&quot;</span>));    <span class="comment">//字符串替换,替换第一个    </span></span><br><span class="line">          System.out.println(<span class="string">&quot;r9 : &quot;</span> + str1.replaceFirst(<span class="string">&quot;o&quot;</span>, <span class="string">&quot;h&quot;</span>));    <span class="comment">//字符串反转   </span></span><br><span class="line">           System.out.println(<span class="string">&quot;r10 : &quot;</span> + <span class="keyword">new</span> StringBuffer(str1).reverse());    <span class="comment">//字符串分割  </span></span><br><span class="line">             String [] temp = str1.split(<span class="string">&quot;\\ &quot;</span>);    <span class="keyword">for</span> (String str : temp)&#123;        System.out.println(<span class="string">&quot;r11 : &quot;</span> + str);    &#125;    <span class="comment">//字符串转大写   </span></span><br><span class="line">              System.out.println(<span class="string">&quot;r12 : &quot;</span> + str1.toUpperCase());    <span class="comment">//字符串转小写   </span></span><br><span class="line">               System.out.println(<span class="string">&quot;r13 : &quot;</span> + str1.toLowerCase());    <span class="comment">//去掉首尾空格    </span></span><br><span class="line">               System.out.println(<span class="string">&quot;r14 : &quot;</span> + str4.trim());    <span class="comment">//是否包含,大小写区分   </span></span><br><span class="line">                System.out.println(<span class="string">&quot;r15 : &quot;</span> + str1.contains(<span class="string">&quot;World&quot;</span>));    <span class="comment">//返回指定位置字符  </span></span><br><span class="line">                  System.out.println(<span class="string">&quot;r16 : &quot;</span> + str1.charAt(<span class="number">4</span>));&#125;运行结果：r1 : 0r2 : -32r3 : 0r4 : 4r5 : 7r6 : HelloWorldr7 : Hellh Whrldr8 : Hellh Whrldr9 : Hellh Worldr10 : dlroW olleHr11 : Hellor11 : Worldr12 : HELLO WORLDr13 : hello worldr14 : hello worldr15 : truer16 : o</span><br></pre></td></tr></table></figure>
<p>方法定义</p>
<p>1、length() 字符串的长度</p>
<p>　　例：char chars[]={‘a’,’b’.’c’};</p>
<p>　　　　String s=new String(chars);</p>
<p>　　　　int len=s.length();</p>
<p>2、charAt() 截取一个字符</p>
<p>　　例：char ch;</p>
<p>　　　　ch=”abc”.charAt(1); 返回’b’</p>
<p>3、getChars() 截取多个字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> sourceStart,<span class="keyword">int</span> sourceEnd,<span class="keyword">char</span> target[],<span class="keyword">int</span> targetStart)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　sourceStart指定了子串开始字符的下标，sourceEnd指定了子串结束后的下一个字符的下标。因此，子串包含从sourceStart到sourceEnd-1的字符。接收字符的数组由target指定，target中开始复制子串的下标值是targetStart。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　例：String s</span>=<span class="string">&quot;this is a demo of the getChars method.&quot;</span>;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">char</span> buf[]=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">　　　　s.getChars(<span class="number">10</span>,<span class="number">14</span>,buf,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、getBytes()</span><br><span class="line"></span><br><span class="line">　　替代getChars()的一种方法是将字符存储在字节数组中，该方法即getBytes()。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、toCharArray()</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、equals()和equalsIgnoreCase() 比较两个字符串</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、regionMatches() 用于比较一个字符串中特定区域与另一特定区域，它有一个重载的形式允许在比较中忽略大小写。</span><br><span class="line"></span><br><span class="line">　　<span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">int</span> startIndex,String str2,<span class="keyword">int</span> str2StartIndex,<span class="keyword">int</span> numChars)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase,<span class="keyword">int</span> startIndex,String str2,<span class="keyword">int</span> str2StartIndex,<span class="keyword">int</span> numChars)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">8、<span class="title">startsWith</span><span class="params">()</span>和<span class="title">endsWith</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="title">startsWith</span><span class="params">()</span>方法决定是否以特定字符串开始，<span class="title">endWith</span><span class="params">()</span>方法决定是否以特定字符串结束</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">9、<span class="title">equals</span><span class="params">()</span>和</span>==</span><br><span class="line"></span><br><span class="line">　　equals()方法比较字符串对象中的字符，==运算符比较两个对象是否引用同一实例。</span><br><span class="line"></span><br><span class="line">　　例：String s1=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">　　　　String s2=<span class="keyword">new</span> String(s1);</span><br><span class="line"></span><br><span class="line">　　　　s1.eauals(s2); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">　　　　s1==s2;<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>、compareTo()和compareToIgnoreCase() 比较字符串</span><br><span class="line"></span><br><span class="line"><span class="number">11</span>、indexOf()和lastIndexOf()</span><br><span class="line"></span><br><span class="line">　　indexOf() 查找字符或者子串第一次出现的地方。</span><br><span class="line"></span><br><span class="line">　　lastIndexOf() 查找字符或者子串是后一次出现的地方。</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>、substring()</span><br><span class="line"></span><br><span class="line">　　它有两种形式，第一种是：<span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　　　　　 第二种是：String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">13、<span class="title">concat</span><span class="params">()</span> 连接两个字符串</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">14 、<span class="title">replace</span><span class="params">()</span> 替换</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　它有两种形式，第一种形式用一个字符在调用字符串中所有出现某个字符的地方进行替换，形式如下：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> original,<span class="keyword">char</span> replacement)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　例如：String s</span>=<span class="string">&quot;Hello&quot;</span>.replace(<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"></span><br><span class="line">　　第二种形式是用一个字符序列替换另一个字符序列，形式如下：</span><br><span class="line"></span><br><span class="line">　　<span class="function">String <span class="title">replace</span><span class="params">(CharSequence original,CharSequence replacement)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">15、<span class="title">trim</span><span class="params">()</span> 去掉起始和结尾的空格</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">16、<span class="title">valueOf</span><span class="params">()</span> 转换为字符串</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">17、<span class="title">toLowerCase</span><span class="params">()</span> 转换为小写</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">18、<span class="title">toUpperCase</span><span class="params">()</span> 转换为大写</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">19、StringBuffer构造函数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　StringBuffer定义了三个构造函数：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="title">StringBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="title">StringBuffer</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="title">StringBuffer</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="title">StringBuffer</span><span class="params">(CharSequence chars)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="params">(<span class="number">1</span>)</span>、<span class="title">length</span><span class="params">()</span>和<span class="title">capacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　一个StringBuffer当前长度可通过<span class="title">length</span><span class="params">()</span>方法得到,而整个可分配空间通过<span class="title">capacity</span><span class="params">()</span>方法得到。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="params">(<span class="number">2</span>)</span>、<span class="title">ensureCapacity</span><span class="params">()</span> 设置缓冲区的大小</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　<span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="params">(<span class="number">3</span>)</span>、<span class="title">setLength</span><span class="params">()</span> 设置缓冲区的长度</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　<span class="keyword">void</span> <span class="title">setLength</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="params">(<span class="number">4</span>)</span>、<span class="title">charAt</span><span class="params">()</span>和<span class="title">setCharAt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　<span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> where)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　<span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> where,<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="params">(<span class="number">5</span>)</span>、<span class="title">getChars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　<span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> sourceStart,<span class="keyword">int</span> sourceEnd,<span class="keyword">char</span> target[],<span class="keyword">int</span> targetStart)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="params">(<span class="number">6</span>)</span>、<span class="title">append</span><span class="params">()</span> 可把任何类型数据的字符串表示连接到调用的StringBuffer对象的末尾。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　例：<span class="keyword">int</span> a</span>=<span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">　　　　　　StringBuffer sb=<span class="keyword">new</span> StringBuffer(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">　　　　　　String s=sb.append(<span class="string">&quot;a=&quot;</span>).append(a).append(<span class="string">&quot;!&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">　　(<span class="number">7</span>)、insert() 插入字符串</span><br><span class="line"></span><br><span class="line">　　　　<span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index,String str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index,Object obj)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　index指定将字符串插入到StringBuffer对象中的位置的下标。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="params">(<span class="number">8</span>)</span>、<span class="title">reverse</span><span class="params">()</span> 颠倒StringBuffer对象中的字符</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　StringBuffer <span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="params">(<span class="number">9</span>)</span>、<span class="title">delete</span><span class="params">()</span>和<span class="title">deleteCharAt</span><span class="params">()</span> 删除字符</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　StringBuffer <span class="title">deleteCharAt</span><span class="params">(<span class="keyword">int</span> loc)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="params">(<span class="number">10</span>)</span>、<span class="title">replace</span><span class="params">()</span> 替换</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex,String str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　<span class="params">(<span class="number">11</span>)</span>、<span class="title">substring</span><span class="params">()</span> 截取子串</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> startIndex)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　　　String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">***重难点</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Java中数组转成字符串及字符串的反转</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    1.数组转成字符串    <span class="keyword">public</span> class Test1 </span>&#123;	<span class="comment">/**	 * * 需求：把数组中的数据按照指定个格式拼接成一个字符串	* 			举例：				int[] arr = &#123;1,2,3&#125;;				输出结果：				&quot;[1, 2, 3]&quot;							用StringBuffer的功能实现	 */</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;		System.out.println(arrayToString(arr));	&#125;	<span class="comment">/*	 * 将数组转换为字符串	 * 1,返回值类型String	 * 2,参数列表int[]	 * 	 * arrayToString 将数组转换为字符串	 * array2String		2与to的发音一样就用2替换了to,后来演变成了一种书写习惯	 * dom4j  domForJ	 */</span>		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">arrayToString</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;		StringBuffer sb = <span class="keyword">new</span> StringBuffer();				<span class="comment">//创建字符串缓冲区对象		sb.append(&quot;[&quot;);										//将[添加到缓冲区						//&#123;1,2,3&#125;		for (int i = 0; i &lt; arr.length; i++) &#123;				//遍历数组			//sb.append(arr[i] + &quot;, &quot;);						//这样做没有]			if(i == arr.length - 1) &#123;				sb.append(arr[i]).append(&quot;]&quot;);				//[1, 2, 3]			&#125;else &#123;				sb.append(arr[i]).append(&quot;, &quot;);				//[1, 2,			&#125;		&#125;		return sb.toString();	&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="number">2.</span>字符串的反转    <span class="keyword">import</span> java.util.Scanner;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;	<span class="comment">/**	 * * A:案例演示	* 			需求：把字符串反转				举例：键盘录入&quot;abc&quot;						输出结果：&quot;cba&quot;							用StringBuffer的功能实现		 */</span>	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		Scanner sc = <span class="keyword">new</span> Scanner(System.in);				<span class="comment">//创建键盘录入对象		String line = sc.nextLine();						//将键盘录入的字符串存储在line中				/*StringBuffer sb = new StringBuffer(line);			//将字符串转换为StringBuffer对象		sb.reverse();										//将缓冲区的内容反转				System.out.println(sb.toString());*/				System.out.println(revString(line));	&#125;	/*	 * 将字符串反转	 * 1,返回值类型String	 * 2,参数列表String line	 */		public static String revString(String line) &#123;		StringBuffer sb = new StringBuffer(line);			//将字符串转换为StringBuffer对象		sb.reverse();										//将缓冲区的内容反转				return sb.toString();	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-22"><a href="#1-22" class="headerlink" title="1-22"></a>1-22</h2><p>String,StringBuffer与StringBuilder的区别</p>
<p>String                          不可变的字符串                              线程不安全</p>
<p>StringBuilder                      可变                                    线程不安全  速度快</p>
<p>StringBuffer                        可变                                    线程安全的  速度慢</p>
<p>String 字符串常量</p>
<p>StringBuffer 字符串变量（线程安全）</p>
<p>StringBuilder 字符串变量（非线程安全）</p>
<p>包裹类 </p>
<p>包裹类的 作用 就是 将字符串 和 对应的数据类型之间进行转换 </p>
<p> Integer  parseInt();</p>
<p> valueOf();</p>
<p> toString();  也可以进行字符串的拼接</p>
<p>八个基本数据类型都有对应的包裹类 </p>
<p> int  Integer</p>
<p>char  Character</p>
<p> byte  Btye</p>
<p> short  Short</p>
<p> long  Long</p>
<p> float  Float</p>
<p> double  Double</p>
<p> boolean Boolean</p>
<p>包裹类 的作用 基本方法 </p>
<p>  parseXxx();  </p>
<p>  valueOf()；</p>
<p>  toString();</p>
<p>StringBuilder  </p>
<p> append();</p>
<p>insert(0,”abc”);</p>
<p>  replace(0,1,”bbb”);</p>
<p>  delete(0,2)</p>
<p>  reverse(); </p>
<p> char[] value 16 </p>
<p>count </p>
<p>例：</p>
<p>Integer.parseInt(“123”);–&gt; 123</p>
<p>Integer.valueOf(“123”);–&gt;123</p>
<p>字符串 转成 小数</p>
<p>Double.parseDouble(“123.21”); –&gt;123.21 </p>
<p>Double. valueOf (“123.21”); –&gt;123.21 </p>
<p>int a=123;</p>
<p> String str=a+”321”;–&gt; “123321”</p>
<p> Integer.toString(123)+”321”;–&gt;”123321”</p>
<p>  String str=”123”;</p>
<p>   int  x=(int)str; X转不过去  只能通过 包裹类 </p>
<p>String  str=”abc”;</p>
<p>   str= str+”bb”+”cc”;</p>
<pre><code> abcbb  +cc

   abcbbcc
</code></pre>
<p>   str–&gt; abcbbcc</p>
<p>在频繁进行字符串拼接时 不建议使用 原始的字符串 </p>
<p>SB系列 </p>
<p> StringBuilder  线程不安全  快</p>
<p> StringBuffer  线程安全   慢</p>
<p>内部 的字符是可以 改变的 </p>
<p> char []  value</p>
<p>StringBuilder 中的常用方法 </p>
<p>  append(); 追加  在最后面拼接上字符串 </p>
<p>  insert(索引位置,内容);将内容插入到索引位置上 </p>
<p>  delete(起始位置,结束位置) 前包 后不包</p>
<p>  setCharAt(位置,’字符’) 替换掉对应位置的字符</p>
<p>  replace(起始位置,结束位置,替换成啥);替换指定区间的内容(前包后不包)</p>
<p>  reverse();反转  正序转为倒序</p>
<p>链式的方法调用方式  </p>
<p> 把其自身返回回去  供我们使用 </p>
<p>StringBuilder</p>
<p> 内部结构 </p>
<p>重点</p>
<p>== 是比较 地址  基本数据类型中的值 ，equals ()  是比较内容 </p>
<h2 id="1-25"><a href="#1-25" class="headerlink" title="1-25"></a>1-25</h2><p>正则表达式</p>
<p> 按照给定的规则进行匹配  匹配成功 </p>
<p> 返回true 否则false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		<span class="comment">//        .           代表任意一个字符       		//      [abc]         代表abc中的任意一个字符		//    (a|b|c|d)       代表任意选项        //        *           代表任意次数				//        +           代表至少一次		//        ?           代表零次或一次		//       &#123;n&#125;          代表正好是n次		//      &#123;n,m&#125;         代表n-m次		</span></span><br><span class="line">   String regex=<span class="string">&quot;.Hello.&quot;</span>;<span class="comment">//规则		</span></span><br><span class="line">   String suibian=<span class="string">&quot;hHelloh&quot;</span>;<span class="comment">//true		</span></span><br><span class="line">   Pattern.matches(regex, suibian);<span class="comment">//匹配方法	</span></span><br><span class="line">   	<span class="keyword">boolean</span> a=Pattern.matches(regex, suibian);		</span><br><span class="line">       System.out.println(a);	&#125;</span><br></pre></td></tr></table></figure>
<p>[]代表一个字符（）代表多个字符</p>
<ul>
<li>任意次数</li>
</ul>
<ul>
<li>至少一次</li>
</ul>
<p>?  0次或者1次</p>
<p>{n} 正好是n次</p>
<p>{n,m} n到m次</p>
<p>^  取反 </p>
<p>[0-9]  区间范围</p>
<p>[a-z]  小写字母</p>
<p>[A-Z]  大写字母</p>
<p>[a-zA-Z] 字母 </p>
<p>\转义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 校验器：利用正则表达式校验邮箱、手机号等 <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span>   <span class="title">Validator</span> </span>&#123;        * 正则表达式：验证用户名 <span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">final</span>   String REGEX_USERNAME =  <span class="string">&quot;^[a-zA-Z]\\w&#123;5,17&#125;$&quot;</span> ;   	* 正则表达式：验证密码 <span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">final</span>   String REGEX_PASSWORD =  <span class="string">&quot;^[a-zA-Z0-9]&#123;6,16&#125;$&quot;</span> ;       	* 正则表达式：验证手机号  <span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">final</span>   String REGEX_MOBILE =  <span class="string">&quot;^((13[0-9])|(15[^4,\\D])|(18[0,5-9]))\\d&#123;8&#125;$&quot;</span> ;     * 正则表达式：验证邮箱 <span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">final</span>   String REGEX_EMAIL =  <span class="string">&quot;^([a-z0-9A-Z]+[-|\\.]?)+[a-z0-9A-Z]@([a-z0-9A-Z]+(-[a-z0-9A-Z]+)?\\.)+[a-zA-Z]&#123;2,&#125;$&quot;</span> ;     * 正则表达式：验证汉字 <span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">final</span>   String REGEX_CHINESE =  <span class="string">&quot;^[\u4e00-\u9fa5],&#123;0,&#125;$&quot;</span> ;     * 正则表达式：验证身份证 <span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">final</span>   String REGEX_ID_CARD =  <span class="string">&quot;(^\\d&#123;18&#125;$)|(^\\d&#123;15&#125;$)&quot;</span> ;     * 正则表达式：验证URL <span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">final</span>   String REGEX_URL =  <span class="string">&quot;http(s)?://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?&quot;</span> ;     * 正则表达式：验证IP地址  <span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">final</span>   String REGEX_IP_ADDR =  <span class="string">&quot;(25[0-5]|2[0-4]\\d|[0-1]\\d&#123;2&#125;|[1-9]?\\d)&quot;</span> ;       	* 校验用户名 <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">boolean</span>   <span class="title">isUsername</span><span class="params">(String username)</span> </span>&#123;           <span class="keyword">return</span> Pattern.matches(REGEX_USERNAME, username);    &#125;     * 校验密码 <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">boolean</span>   <span class="title">isPassword</span><span class="params">(String password)</span> </span>&#123;           <span class="keyword">return</span> Pattern.matches(REGEX_PASSWORD, password);       &#125;     * 校验手机号<span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">boolean</span>   <span class="title">isMobile</span><span class="params">(String mobile)</span> </span>&#123;           <span class="keyword">return</span> Pattern.matches(REGEX_MOBILE, mobile);       &#125;     * 校验邮箱<span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">boolean</span>   <span class="title">isEmail</span><span class="params">(String email)</span> </span>&#123;           <span class="keyword">return</span> Pattern.matches(REGEX_EMAIL, email);       &#125;     * 校验汉字 <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">boolean</span>   <span class="title">isChinese</span><span class="params">(String chinese)</span> </span>&#123;           <span class="keyword">return</span> Pattern.matches(REGEX_CHINESE, chinese);      &#125;     * 校验身份证 <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">boolean</span>   <span class="title">isIDCard</span><span class="params">(String idCard)</span> </span>&#123;           <span class="keyword">return</span> Pattern.matches(REGEX_ID_CARD, idCard);     &#125;     * 校验<span class="function">URL <span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">boolean</span>   <span class="title">isUrl</span><span class="params">(String url)</span> </span>&#123;           <span class="keyword">return</span> Pattern.matches(REGEX_URL, url);      &#125;      * 校验IP地址 <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">boolean</span>   <span class="title">isIPAddr</span><span class="params">(String ipAddr)</span> </span>&#123;           <span class="keyword">return</span> Pattern.matches(REGEX_IP_ADDR, ipAddr);       &#125;           <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>   <span class="keyword">void</span>   <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;           String username =  <span class="string">&quot;fdsdfsdj&quot;</span> ;           System.out.println(Validator.isUsername(username));           System.out.println(Validator.isChinese(username));       &#125;  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>异常 </p>
<p>   不正常  报错信息 </p>
<p>异常 程序在执行的过程中遇到问题导致后续无法执行</p>
<p>常见的异常包括:</p>
<p>空指针异常 </p>
<p>数组下标越界异常</p>
<p>类型转换异常 </p>
<pre><code> 能治的           治不了的       

                                                            Throwable 

                                                             ↙      ↘

                                         Exception                 Error 无法挽回 oom 内存或硬盘蹦了

                                         ↙    ↘

    RunTimeException                其他的异常类

        (运行时异常)                       (非运行时异常)
</code></pre>
<p>Throwable类是所有异常类的父类</p>
<p>异常捕获机制  </p>
<p> 1.通过 try catch 进行异常的捕获(匹配对应的异常类型) 而后进行处理 保证后续代码可以正常执行而不是终止程序</p>
<p>异常的 东西 </p>
<p>try{</p>
<p> 可能出现异常的代码</p>
<p>}catch(异常类型  e){</p>
<p> 异常的处理 </p>
<p>}finally{</p>
<p> 一定会执行</p>
<p>}</p>
<p>try  catch()  finally  </p>
<p>1.try 可以和 catch 以及 finally 进行 组合使用  但不能单独存在 </p>
<p>  如 try{} catch(){}   try {}finally{}  try{} catch(){}finally{}  try{}catch(){}catch(){}   </p>
<p>2.try 可以跟0~多个的catch  最多 只能跟一个finally</p>
<p> throw   抛出异常对象的处理 </p>
<p>抛出 异常对象 </p>
<p>   throw  new  NullPointerException(“自定义信息”);</p>
<p>   throw 抛出 异常 </p>
<p>  抛出异常 可以是 运行时异常  不需要特殊处理 try 不try 都行</p>
<pre><code> 也可以是 受检查异常 必须加trycatch  或 通过throws 进行声明让调用者trycatch
</code></pre>
<p>thorws  声明异常处理 </p>
<p>  代表当前方法中会出现 该类型的异常 需要 调用者进行try catch 处理或者</p>
<p>接着 throws </p>
<h2 id="1-27"><a href="#1-27" class="headerlink" title="1-27"></a>1-27</h2><p>设计模式</p>
<p> 设计模式   用来 解决某类固定问题的 解决方案 </p>
<p> gof23种  单例模式  工厂模式  代理  动态代理  适配器模式  责任链  观察者模式  </p>
<p>程序  数据结构+算法 </p>
<p>设计模式的特点  增加其可扩展性 增强内聚性  提高可复用性</p>
<p>会把简单的代码变得复杂化  但是能有效的解决这类问题</p>
<p>工厂模式 Factory</p>
<p> 对象创建的问题 </p>
<p>工厂是用来生产 产品的   </p>
<p>工厂类  </p>
<p>  工厂方法  –&gt; 根据你告诉的内容 返回  你需要的对象信息 </p>
<pre><code> public  class Factory&#123;   public  static  Car  getCar(String  type)&#123;         if(&quot;奥迪&quot;.equals(type))&#123;           return  new  奥迪();          &#125;else if(&quot;bwm&quot;.equals(type))&#123;           return  new Bwm();          &#125;else if(&quot;q7&quot;.equals(type))&#123;           return new Q7();          &#125;  &#125;&#125;
</code></pre>
<p>单例模式  Singleton</p>
<p>在系统中 只能拥有一个 该对象的实例  问题 </p>
<p>public class  HaHa{</p>
<p> public static void main(){</p>
<p>  HaHa  haha=new HaHa();</p>
<p>  HaHa  haha1=new HaHa();</p>
<p>  发射导弹    有一个最高统帅 必须是唯一的  </p>
<p> 编号  生成器  1 2 3 4 5 6 7 8 </p>
<p>全球性的公司  </p>
<p>中国  </p>
<p>A库  产品表  id自增   1,2,3,3,4,5，，6</p>
<pre><code>        大白兔
</code></pre>
<p>希腊 </p>
<p>B库  产品表  id 自增   1,2,3,4,5,6，，,,8，</p>
<pre><code>        酸奶
</code></pre>
<p>}</p>
<p>}</p>
<p>如何实现单例模式 </p>
<p>1.将其构造方法私有化 </p>
<p>2.将其自身作为自身的属性 静态 私有化 </p>
<p>3.提供共有静态的 getInstance()方法 返回当前对象  </p>
<p>懒汉式  lazy 延时加载  lazy-load  </p>
<p>饿汉式 </p>
<p>单例模式的应用1则</p>
<h2 id="1-28"><a href="#1-28" class="headerlink" title="1-28"></a>1-28</h2><p>集合</p>
<p> 集合： 容器             多个变量       个数可变</p>
<p> 数组： 同种类型     多个变量        个数不可变</p>
<p>  接口                                                                              collection </p>
<p>  接口                                List                                           Set                                         Map</p>
<hr>
<p> 实现类                           ArrayList                                   HashSet                            HashTable</p>
<p> 实现类                           LinkedList                                 TreeSet                              HashMap</p>
<p> 实现类                          Vectory</p>
<p>ArrayList集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> jihe;<span class="keyword">import</span> java.util.ArrayList;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArrayList</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		ArrayList  arr=<span class="keyword">new</span> ArrayList();		<span class="comment">//集合元素的遍历		arr.add(&quot;a&quot;);//添加元素		arr.add(&quot;b&quot;);		arr.add(&quot;c&quot;);		</span></span><br><span class="line">System.out.println(arr.size());	<span class="comment">//元素个数		</span></span><br><span class="line">	System.out.println(arr.get(<span class="number">0</span>));<span class="comment">//--&gt;&quot;a&quot;		</span></span><br><span class="line">    System.out.println(arr.get(<span class="number">1</span>));		</span><br><span class="line">    System.out.println(arr.get(<span class="number">2</span>));				</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------------------------------------------------&quot;</span>);		</span><br><span class="line">    arr.add(<span class="number">0</span>,<span class="string">&quot;d&quot;</span>);<span class="comment">//插入数据到第一个位置		</span></span><br><span class="line">    System.out.println(arr.remove(<span class="number">0</span>));<span class="comment">//删除第一个元素   并返回这个元素		</span></span><br><span class="line">    System.out.println(arr.contains(<span class="string">&quot;b&quot;</span>));<span class="comment">//是否包含元素		</span></span><br><span class="line">    System.out.println(arr.indexOf(<span class="string">&quot;c&quot;</span>));<span class="comment">//左往右的   索引位置	</span></span><br><span class="line">    	System.out.println(arr.lastIndexOf(<span class="string">&quot;c&quot;</span>));		                                               </span><br><span class="line">         <span class="comment">//ArrayList的遍历方式		</span></span><br><span class="line">         <span class="comment">//1.for循环的遍历		</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.size();i++)&#123;			</span><br><span class="line">         System.out.println(arr.get(i));		&#125;	</span><br><span class="line">         	<span class="comment">//2.转成数组形式输出		</span></span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------------------------------------------------&quot;</span>);		</span><br><span class="line">            Object[] oo=arr.toArray();		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;oo.length;i++)&#123;			System.out.println(oo[i]);		&#125;		</span><br><span class="line">            <span class="comment">//3.for的增强型		</span></span><br><span class="line">            System.out.println(<span class="string">&quot;--------------------------------------------------------------------&quot;</span>);		</span><br><span class="line">            <span class="keyword">for</span>(Object tmp:arr)&#123;			System.out.println(tmp);		&#125;	</span><br><span class="line">            	<span class="comment">//4.Iterator 迭代器	</span></span><br><span class="line">                	System.out.println(<span class="string">&quot;--------------------------------------------------------------------&quot;</span>);		</span><br><span class="line">                    Iterator it=  arr.iterator();		System.out.println(it.hasNext());<span class="comment">//true		</span></span><br><span class="line">                    	System.out.println(it.next());<span class="comment">//a	</span></span><br><span class="line">                        	System.out.println(it.hasNext());<span class="comment">//true			</span></span><br><span class="line">                            System.out.println(it.next());<span class="comment">//b	</span></span><br><span class="line">                            	System.out.println(it.hasNext());<span class="comment">//true			</span></span><br><span class="line">                                System.out.println(it.next());<span class="comment">//c	</span></span><br><span class="line">                                	System.out.println(it.hasNext());<span class="comment">//flase			//		</span></span><br><span class="line">                                    	<span class="keyword">while</span>(it.hasNext())&#123;<span class="comment">//				</span></span><br><span class="line">                                        System.out.println(it.next());<span class="comment">//			&#125;					&#125;		&#125;</span></span><br><span class="line">                                        运行结果：<span class="number">3</span>   a   b   c--------------------------------------------------------------------d   <span class="keyword">true</span>  </span><br><span class="line">                                         <span class="number">2</span>   <span class="number">2</span>   a   b   c--------------------------------------------------------------------</span><br><span class="line">                                         a   b   c--------------------------------------------------------------------</span><br><span class="line">                                         a   b   c--------------------------------------------------------------------</span><br><span class="line">                                         <span class="keyword">true</span>   a   <span class="keyword">true</span>   b   <span class="keyword">true</span>   c   <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>特点和原理</p>
<p> 特点：长度可变</p>
<p> 不用给初始容量大小</p>
<p>底层原理：数组</p>
<p>ArrayList</p>
<p> 底层  object 类型的数组默认长度为10 扩展0.5倍   内容</p>
<p> 访问效率 高   操作效率 低</p>
<p>方法</p>
<p>add()</p>
<p>add(0,””)</p>
<p>remove(index) // 删除指定位置的元素</p>
<p>remove(对象)//删除指定的对象</p>
<p>set(   索引位置   ,    值    ) 替换指定索引位置的值</p>
<p>size()</p>
<p>contains();</p>
<p>indexOf()</p>
<p>lastIndexOf() </p>
<p>iterator() 迭代遍历 </p>
<p>源代码 </p>
<p>泛型  限定集合中元素的类型 </p>
<p>数组集合的排序 </p>
<p> 冒泡  可以比较 数字 </p>
<p>Collections.sort(数组);排序方法</p>
<h2 id="1-29"><a href="#1-29" class="headerlink" title="1-29"></a>1-29</h2><p>LinkedList    </p>
<p> 链表集合</p>
<p>链表数据结构</p>
<p>单链表</p>
<pre><code>                 查询效率      操作效率(删除 增加元素)
</code></pre>
<p>ArrayList          高         低          （ 常用）</p>
<p>LinkedList        低         高</p>
<p>线性的  有序 可重复的 </p>
<p>Vector</p>
<p>线程安全的   Vector   </p>
<p>线程不安全的  ArrayList</p>
<pre><code>package jihe;import java.util.Vector;public class TestVector &#123;    public static void main(String[] args) &#123;        Vector&lt;String&gt; v=new Vector();            v.add(&quot;abc&quot;);            System.out.println(v.size());            System.out.println(v.get(0));    &#125;&#125;运行结果：    1    abc
</code></pre>
<p>Stack 栈 </p>
<p>push（）压栈；</p>
<p>pop（）出栈；</p>
<p>peek（）查找栈顶元素</p>
<pre><code>package jihe;import java.util.Stack;public class TestStack&#123;    public static void main(String[] args)&#123;        Stack&lt;String&gt; s=new Stack&lt;&gt;();        s.push(&quot;a&quot;);        s.push(&quot;b&quot;);        s.push(&quot;c&quot;);        System.out.println(s.size());        System.out.println(s.peek());        System.out.println(s.size());        System.out.println(s.pop());        System.out.println(s.size());    &#125;&#125;运行结果：    3    c    3    c    2
</code></pre>
<p>Set 集合  </p>
<p> ***无序  </p>
<p>***不可重复  </p>
<p>HashSet  哈希表 </p>
<pre><code>package jihe;import java.util.HashSet;import java.util.HashSet;import java.util.Iterator;public class TestHashSet &#123;    public static void main(String[] args) &#123;        HashSet&lt;String&gt; hs=new HashSet&lt;&gt;();        hs.add(&quot;a&quot;);        hs.add(&quot;b&quot;);        hs.add(&quot;b&quot;);        hs.add(&quot;c&quot;);        System.out.println(hs.size());        System.out.println(hs);//1.第一种输出方式                        Object[] arr=hs.toArray();//2.第二种输出方式        System.out.println(Arrays.toString(arr));                Iterator&lt;String&gt; it=hs.iterator();//3.第三种方式输出方式        while(it.hasNext)&#123;            System.out.println(it.next());        &#125;    &#125;&#125;运行结果：    3    无序排列！！！！并且不会输出重复元素
</code></pre>
<h2 id="2-1"><a href="#2-1" class="headerlink" title="2-1"></a>2-1</h2><p>Map集合</p>
<p>HashSet 无序  不可重复  允许null 存在    hash(值)–&gt;对应的索引值</p>
<p>无序 和存入顺序不一致 </p>
<p>不可重复  1.hashCode()  2.equals()</p>
<p>TreeSet 无序  不可重复  不允许null 存在 </p>
<pre><code>树化   5

 3   根  7

 左     右 
</code></pre>
<p>   1    4</p>
<p>   左    右</p>
<p>区别 </p>
<p>HashSet 不允许重复元素 无序 可以存  null值 底层 hashmap</p>
<p>遍历  iterator  toArray</p>
<p>TreeSet 不允许重复 无序   不能存 null值   底层 treemap</p>
<p>遍历  iterator  toArray </p>
<p>去重</p>
<p>Map集合 </p>
<p>put 方法表示放入一个键值对，如果键已存在则新值替换旧值_，如果键不存在则<br>增加一个键值对_。<br>remove 方法接受1个参数，表示一个键值对___。<br>get 方法表示_通过键查找对应的__值___，get 方法的参数表示键__，返回值表示值_。<br>要想获得Map 中所有的键，应该使用方法keySet__，该方法返回值类型为_Set。<br>要想获得Map 中所有的值，应该使用方法Values_，该方法返回值类型为collection。<br>要想获得Map 中所有的键值对的集合，应该使用方法entrySet___，该方法返回一个<br>_Map.EntrySet类型所组成的Set。</p>
<p>HashMap  哈希表  </p>
<p> key  value  键值对 </p>
<p>方法</p>
<pre><code>HashMap hm=new HashMap();hm.put(key,value);// key 不重复 可以包含null  hm.get(key);hm.size();hm.keySet();//键的集合 Set hm.values();//值的Collection集合hm.entrySet();//返回键值对 的set集合 hm.remove(key);//删除键对应的键值对
</code></pre>
<p>日期时间处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date d=<span class="keyword">new</span> Date();		System.out.println(d.toLocaleString());		System.out.println( d.getTime());<span class="comment">//  d  距离1970年1月1日的毫秒时间		Thread.sleep(1000);		Date d1=new Date();		System.out.println(d1.toLocaleString());		System.out.println(d1.getTime());//  d1  距离1970年1月1日的毫秒时间		//如何设定一个时间		SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);		Date d2=sdf.parse(&quot;2022-2-3 15:50:20&quot;);		//Date d3=sdf.parse(&quot;2021-2-2 15:54:23&quot;);				System.out.println(d2.toLocaleString());		if(d2.before(d))&#123;			System.out.println(&quot;超时&quot;);		&#125;else&#123;			System.out.println(&quot;时间未截止&quot;);		&#125;运行结果：    2021-2-2 17:56:04	1612259764570	2021-2-2 17:56:05	1612259765622	2022-1-3 15:50:20	时间未截止</span></span><br></pre></td></tr></table></figure>
<p>HashMap 源代码 </p>
<p>hashMap 通过 hash（key）计算得到其索引位置 将值存入到 对应哈希表的索引位置 </p>
<p>hash碰撞 :不同的值可能会得到相同的 索引位置 </p>
<p>采用单链表形式 挂在后面 如果 长度大于8会转为红黑树</p>
<p>table 中存的 是什么?     键值对</p>
<p>HashMap 哈希表+链表+树  key 和 value  都可以是null  </p>
<p>TreeMap  树作为底层  key 绝对不能是null  值无所谓</p>
<h2 id="2-2"><a href="#2-2" class="headerlink" title="2-2"></a>2-2</h2><p>IO</p>
<p>IO  输入和输出  input  output  </p>
<p>1.File  文件类  针对 文件或文件夹本身进行操作  创建 删除文件  但是不能对文件内容操作</p>
<p>2.文件中内容的处理 各种流 </p>
<p>操作文件的内容 读取文件中的字符  写出 文件中的字符信息 </p>
<p>字节流 </p>
<p>字符流 </p>
<p>File 类 </p>
<p>删除文件夹 </p>
<pre><code>    //删除 1-100    文件夹        String c = &quot;c:/io/&quot;;        for (int j = 1; j &lt;= 3; j++) &#123;            c = &quot;c:/io/&quot;;            for (int i = 1; i &lt;= 3 - j; i++) &#123;                File f = new File(c += i + &quot;/&quot;);            &#125;            System.out.println(c);            File f = new File(c);            f.delete();        &#125;//运用递归方法    public static void diguidel(File f) &#123;                if(f.isDirectory())&#123;        File[] child=f.listFiles();//获取文件夹中的子文件及文件夹        for(int i=0;i&lt;child.length;i++)&#123;            File tmp=child[i];            //System.out.println(tmp.getName());            if(tmp.isFile())&#123;                tmp.delete();//删除            &#125;else if(tmp.isDirectory())&#123;                diguidel(tmp);            &#125;        &#125;    &#125;        f.delete();    &#125;
</code></pre>
<p>IO流方法</p>
<p>路径： File f=new File(“路径”); “c:\abc”  “c:/ab/dd/abc.txt”</p>
<p>File 类 操作 文件 或文件夹的 </p>
<p>文件 创建删除  </p>
<p>renameto重命名</p>
<p>createNewFile();  创建文件</p>
<p>mkdir();     创建单层文件夹</p>
<p>mkdirs();    创建多层文件夹</p>
<p>length();    文件大小</p>
<p>delete();    删除空的文件夹</p>
<p>isDirectory()  是否是文件夹</p>
<p>isFile()    是否是文件</p>
<p>getName();  获取文件名称</p>
<p>listFiles();  返回其子文件夹及子文件</p>
<p>getPath();//获取其路径 </p>
<h2 id="2-3"><a href="#2-3" class="headerlink" title="2-3"></a>2-3</h2><p> key-value  非关系型数据库  redis </p>
<p>io 各种流 </p>
<p> 输入   输出  方向性</p>
<pre><code>                  输入              输出
</code></pre>
<p>字节流         input           output          按字节形式处理</p>
<p>字符流        reader           writer          按字符形式处理 </p>
<p>FileInputStream   文件输入字节流</p>
<p>FileOutputStream  文件输出字节流</p>
<p>FileReader     文件字符输入流</p>
<p>FileWriter      文件字符输出流</p>
<p>DataInputStream   数据输入字节流</p>
<p>DataOutputStream  数据输出字节流</p>
<p>ObjectOutputStream  对象输出字节流</p>
<p>Bufferedreader    缓冲字符输入流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">复制图片</span><br><span class="line"></span><br><span class="line">    			<span class="comment">//复制照片		FileInputStream fis=new FileInputStream(&quot;c:/io/1.jpg&quot;);		FileOutputStream fos=new FileOutputStream(&quot;c:/io/3.jpg&quot;);		byte[] b=new byte[10];		int length=fis.read(b);		while(length!=-1)&#123;			fos.write(b,0,length);			length=fis.read(b);		&#125;		fis.close();		fos.close();</span></span><br><span class="line"></span><br><span class="line">文件拆分</span><br><span class="line"></span><br><span class="line">    		File f=<span class="keyword">new</span> File(<span class="string">&quot;c:/io/1.jpg&quot;</span>);		FileInputStream fis=<span class="keyword">new</span> FileInputStream(<span class="string">&quot;c:/io/1.jpg&quot;</span>);		FileOutputStream fos1=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c:/io/4.jpg&quot;</span>);		FileOutputStream fos2=<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;c:/io/3.jpg&quot;</span>);		<span class="keyword">long</span> xx=f.length()/<span class="number">2</span>;		<span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];		<span class="keyword">int</span> length=fis.read(b);		<span class="keyword">long</span> he=length;		<span class="keyword">while</span>(length!=-<span class="number">1</span>)&#123;			<span class="keyword">if</span>(he&lt;=xx)&#123;				fos1.write(b,<span class="number">0</span>,length);				&#125;<span class="keyword">else</span>&#123;					fos2.write(b,<span class="number">0</span>,length);				&#125;						length=fis.read(b);			he+=length;		&#125;		fis.close();		fos1.close();		fos2.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件加密  解密</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加密		//a^b-&gt;c		int key=12;		FileInputStream fis=new FileInputStream(&quot;c:/io/1.jpg&quot;);		FileOutputStream fos=new FileOutputStream(&quot;c:/io/2.jpg&quot;);		byte[] b=new byte[100];		int length =fis.read(b);		while(length!=-1)&#123;			for(int i=0;i&lt;b.length;i++)&#123;				b[i]=(byte)(b[i]^key);			&#125;			fos.write(b,0,length);			length=fis.read(b);		&#125;		fis.close();		fos.close();//执行第一遍加密//第二遍解密</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">缓冲流   </span><br><span class="line"></span><br><span class="line">作用： 回车换行 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BufferedReader</span><br><span class="line"></span><br><span class="line">            FileReader fr=<span class="keyword">new</span> FileReader(<span class="string">&quot;c:/io/abc.txt&quot;</span>);		BufferedReader br=<span class="keyword">new</span> BufferedReader(fr);		String xx= br.readLine();		<span class="keyword">while</span>(xx!=<span class="keyword">null</span>)&#123;			System.out.println(xx);			xx=br.readLine();		&#125;		br.close();		fr.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BufferedWriter</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BufferedWrite		FileWriter fw=new FileWriter(&quot;c:/io/cba.txt&quot;);		BufferedWriter bw=new BufferedWriter(fw);				bw.write(&quot;asdfghjk&quot;);		bw.newLine();//换行		bw.write(&quot;asx&quot;);		bw.close();		fw.close();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Perperties 方法</span><br><span class="line"></span><br><span class="line">    		Properties p=<span class="keyword">new</span> Properties();		p.load(TestBuffered.class.getResourceAsStream(<span class="string">&quot;/jdbc.properties&quot;</span>));		String x=p.getProperty(<span class="string">&quot;age&quot;</span>);		System.out.println(x);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">数据流</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对象流</span><br></pre></td></tr></table></figure>


<h2 id="2-4"><a href="#2-4" class="headerlink" title="2-4"></a>2-4</h2><p>转换流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> IO;<span class="keyword">import</span> java.io.BufferedReader;<span class="keyword">import</span> java.io.FileInputStream;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.io.InputStreamReader;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInPutStreamReader</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;	<span class="comment">//转换流	FileInputStream fis=new FileInputStream(&quot;c:/io/abc.txt&quot;);//字符流	InputStreamReader isr=new InputStreamReader(fis);//字节流	BufferedReader br=new BufferedReader(isr);	String x=br.readLine();	System.out.println(x);//输出第一行	x=br.readLine();	System.out.println(x);//输出第二行	x=br.readLine();	System.out.println(x);//输出第三行	x=br.readLine();	System.out.println(x);//第四行为空，输入 null;	br.close();	isr.close();	fis.close();	&#125;	&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>文件的读写流  </p>
<p>网络的流    </p>
<p>  流量    </p>
<p>  B     S</p>
<p> Browser  Server</p>
<p> 浏览器   服务器</p>
<p>协议 protocol</p>
<p>http   https  ftp  </p>
<p>dns 域名解析服务  –&gt;IP地址 </p>
<p>tcp/ip协议 局域网中数据传输的基础协议 配置了ip地址  0<del>255.0</del>255.0<del>255.0</del>255</p>
<p>ipv6 128位  十六进制 可以给每个沙子分配一个ip地址  </p>
<p>   可穿戴设备  手环   耳机   提升自己的价值   马太效应  </p>
<p>ip地址  相当于 门牌号  </p>
<p>TCP/IP协议  进行数据的传输 点对点  确保 数据信息一定到达目标位置 </p>
<p>  C          S</p>
<p> 客户端       服务端 </p>
<p> client        server </p>
<pre><code>       ip  端口
</code></pre>
<p> 套接字</p>
<p> Socket       ServerSocket</p>
<pre><code>  流 
</code></pre>
<p>ServerSocket</p>
<p>   accept()//接收  连接过来的 客户端  socket对象 </p>
<p>规定 客户端 先发出信息 给服务器 </p>
<p> 服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">package</span> IO;<span class="keyword">import</span> java.io.BufferedReader;<span class="keyword">import</span> java.io.BufferedWriter;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.io.InputStream;<span class="keyword">import</span> java.io.InputStreamReader;<span class="keyword">import</span> java.io.OutputStream;<span class="keyword">import</span> java.io.OutputStreamWriter;<span class="keyword">import</span> java.net.ServerSocket;<span class="keyword">import</span> java.net.Socket;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerSocket</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;		ServerSocket ss=<span class="keyword">new</span> ServerSocket(<span class="number">123</span>);		System.out.println(<span class="string">&quot;服务器启动成功，等待接受.......&quot;</span>);		Socket c=ss.accept();		System.out.println(<span class="string">&quot;有客户端连接成功！&quot;</span>+c.getInetAddress());		InputStream is=c.getInputStream();		InputStreamReader isr=<span class="keyword">new</span> InputStreamReader(is);		BufferedReader br=<span class="keyword">new</span> BufferedReader(isr);		String str=br.readLine();		System.out.println(<span class="string">&quot;客户端说了：&quot;</span>+str);				<span class="comment">////////////////////////////////////////////////////////		//向客户端输出内容		OutputStream os=c.getOutputStream();		OutputStreamWriter osw=new OutputStreamWriter(os);		BufferedWriter bw=new BufferedWriter(osw);		bw.write(&quot;谢谢，你也好！&quot;);		bw.newLine();		bw.flush();				///////////////////////////////////////////////////////						bw.close();		osw.close();		os.close();		br.close();		isr.close();		is.close();	&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">客户端</span><br><span class="line"></span><br><span class="line">    <span class="keyword">package</span> IO;<span class="keyword">import</span> java.io.BufferedReader;<span class="keyword">import</span> java.io.BufferedWriter;<span class="keyword">import</span> java.io.IOException;<span class="keyword">import</span> java.io.InputStream;<span class="keyword">import</span> java.io.InputStreamReader;<span class="keyword">import</span> java.io.OutputStream;<span class="keyword">import</span> java.io.OutputStreamWriter;<span class="keyword">import</span> java.net.Socket;<span class="keyword">import</span> java.net.UnknownHostException;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSocket</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException, IOException </span>&#123;		Socket s=<span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">123</span>);		OutputStream os=s.getOutputStream();		</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    os.write(<span class="string">&quot;你好啊，服务器！&quot;</span>.getBytes());		</span><br><span class="line">    OutputStreamWriter osw=<span class="keyword">new</span> OutputStreamWriter(os);		</span><br><span class="line">    BufferedWriter bw=<span class="keyword">new</span> BufferedWriter(osw);		</span><br><span class="line">    bw.write(<span class="string">&quot;你好啊，服务器！&quot;</span>);		bw.newLine();		</span><br><span class="line">    bw.flush();<span class="comment">//清空 强制将缓冲区的内容输出出去				</span></span><br><span class="line">    <span class="comment">/////////////////////////////////////////////////////////////			</span></span><br><span class="line">    	InputStream is=s.getInputStream();	</span><br><span class="line">        	InputStreamReader isr=<span class="keyword">new</span> InputStreamReader(is);	</span><br><span class="line">            	BufferedReader br=<span class="keyword">new</span> BufferedReader(isr);		</span><br><span class="line">                String xx=br.readLine();	</span><br><span class="line">                	System.out.println(<span class="string">&quot;服务器端回来了！&quot;</span>+xx);	</span><br><span class="line">                    			<span class="comment">/////////////////////////////////////////////////////////////	</span></span><br><span class="line">                                	br.close();		</span><br><span class="line">                                    isr.close();	</span><br><span class="line">                                    	is.close();		</span><br><span class="line">                                        bw.close();		</span><br><span class="line">                                        osw.close();	</span><br><span class="line">                                       os.close();	&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
